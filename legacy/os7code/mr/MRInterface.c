// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: mrinterface.c// Auth: dave peck// Date: 7/2/97// Desc: the actual interface codez!// ----------------------------------------------------------------// Includes// ----------------------------------------------------------------#include "MRInterface.h"//#include "MRGfxUtils.h"#include "MRFade.h"#include "MRLoop.h"#include "MacColorOff.h"#include "SWGameUtils.h"#include "MRSound.h"#include "MRError.h"#include "MRPrefs.h"#include <string.h>// ----------------------------------------------------------------// Constants// ----------------------------------------------------------------#define kNoIntfHilite		1#define kMouseIntfHilite	2#define kClickIntfHilite	3#define kWipeStep	32#define kWipeHeight	32#define kWipeDelay  3#define kPrefRevealStep		16#define kPrefRevealDelay	3#define kPrefSoundID		200#define kPrefKeyPressSnd	201#define kPrefBadKeySnd		201// ----------------------------------------------------------------// Data Structures// ----------------------------------------------------------------// ----------------------------------------------------------------// Global Data// ----------------------------------------------------------------int	interface_returnValue;// ----------------------------------------------------------------// Function Prototypes// ----------------------------------------------------------------void DrawInterfaceItem( MRIntfCBData theData,							int which,							int hiliteState );void WipeWindow( WindowPtr wind, Boolean andBanners );void WipePictIntoWindow( WindowPtr wind, int pictID );void UpdateInterface( WindowPtr wind );void DrawInterface( WindowPtr wind );void DrawBanners( WindowPtr wind );Boolean Intf_IdleCallback(int modifiers, MRUData info );Boolean Intf_KeyCallback(char theKey, int modifiers, MRUData info, Boolean keyUp );Boolean Intf_ClickCallback(Point location, int modifiers, MRUData info );void SetInterfaceCallbacks( WindowPtr wind );// ----------------------------------------------------------------// Functions// ----------------------------------------------------------------void CharToCharStr( char c, char* s ) {	if ( c == (char)13 )		strcpy( s, "Ret" );	else if ( c == '\33' )		strcpy( s, "Esc" );	else if ( c == ' ' )		strcpy( s, "Spc" );	else if ( c== '\36' )		strcpy( s, "Up" );	else if ( c== '\34' )		strcpy( s, "Lt" );	else if ( c== '\35' )		strcpy( s, "Rt" );	else if ( c== '\37' )		strcpy( s, "Dn" );	else if ( c== '\3' )		strcpy( s, "Ent" );	else if ( c== '\1' )		strcpy( s, "Home" );	else if ( c== '\5' )		strcpy( s, "Help" );	else if ( c== '\v' )		strcpy( s, "PgUp" );	else if ( c== '\f' )		strcpy( s, "PgDn" );	else if ( c== '\4' )		strcpy( s, "End" );	else if ( c== '\t' )		strcpy( s, "Tab" );	else {		s[0] = c;		s[1] = '\0';	}}int CurrentDrawFontHeight() {	FontInfo finf;		GetFontInfo( &finf );	return (finf.ascent+finf.descent+finf.leading);}void SetRectDelta( Rect *r, short left, short top, short dh, short dv ) {	r->left = left;	r->top = top;	r->right = r->left + dh;	r->bottom = r->top + dv;}void DrawCharBox( char c, Rect r, short fSize ) {	char s[16];	short h, v;	short helveticaNum;		// get the char string	CharToCharStr( c, s );		// set font to draw in	GetFNum("\pHelvetica",  &helveticaNum );	TextSize( fSize );		TextFace( bold );	ForeColor( whiteColor );		// center cursor for drawing	v = (r.top + r.bottom)/2;	v += CurrentDrawFontHeight() / 2;	if (fSize>10)		v -= 3;	else		v -= 2;	h = (r.right + r.left)/2;			// get text size	h -= StringWidth( C2PStr(s) ) / 2;		// now draw it	MoveTo( h, v );	DrawString( (StringPtr)s );		TextFace(0);	ForeColor( blackColor );}void PrefLArrow( short *vol ) {	if ( *vol == kExcruciatingVolume )		*vol = kPleasantVolume;	else if ( *vol == kPleasantVolume )		*vol = kAudibleVolume;	else if ( *vol == kAudibleVolume )		*vol = kSilentVolume;	else if ( *vol == kSilentVolume )		*vol = kExcruciatingVolume;}void PrefRArrow( short *vol ) {	if ( *vol == kExcruciatingVolume )		*vol = kSilentVolume;	else if ( *vol == kPleasantVolume )		*vol = kExcruciatingVolume;	else if ( *vol == kAudibleVolume )		*vol = kPleasantVolume;	else if ( *vol == kSilentVolume )		*vol = kAudibleVolume;}void DrawPrefVolume( MRPrefCBData prefData, short vol, Rect onRect ) {	SetPort( prefData->mainWind );		if ( vol == kExcruciatingVolume ) 		DrawPictureIDAtPoint( kPrefExcruciatingPict, onRect.left, onRect.top );	else if ( vol == kAudibleVolume )		DrawPictureIDAtPoint( kPrefAudiblePict, onRect.left, onRect.top );	else if ( vol == kPlesantVolume )		DrawPictureIDAtPoint( kPrefPleasantPict, onRect.left, onRect.top );	else if ( vol == kSilentVolume )		DrawPictureIDAtPoint( kPrefSilentPict, onRect.left, onRect.top );}// draw all preferencesvoid DrawAllPrefs( MRPrefCBData prefData ) {	MRPrefs mp = GetCurrentPrefs();		// draw keys	DrawCharBox( mp.upKey, prefData->onTrack[kUpPrefBox], 12 );	DrawCharBox( mp.leftKey, prefData->onTrack[kLeftPrefBox], 12 );	DrawCharBox( mp.rightKey, prefData->onTrack[kRightPrefBox], 12 );	DrawCharBox( mp.downKey, prefData->onTrack[kDownPrefBox], 12 );	DrawCharBox( mp.specialKey, prefData->onTrack[kSpecialPrefBox], 10 );	DrawCharBox( mp.pauseKey, prefData->onTrack[kPausePrefBox], 10 );	DrawCharBox( mp.suicideKey, prefData->onTrack[kSuicidePrefBox], 10 );	// draw the volume levels for music:	DrawPrefVolume( prefData, mp.musicVolume, prefData->onTrack[kMusicPictPrefBox] );	DrawPrefVolume( prefData, mp.soundVolume, prefData->onTrack[kSoundPictPrefBox] );				// draw the checkboxes in hilited mode, if necessary	if ( mp.interlacedMode )		CopyOffToOffRect( prefData->hiliteOff, true,						  (GWorldPtr)prefData->mainWind, false,						  prefData->offTrack[kInterlacePrefBox],						  prefData->onTrack[kInterlacePrefBox] );	if ( mp.screenSize > 0 )		CopyOffToOffRect( prefData->hiliteOff, true,						  (GWorldPtr)prefData->mainWind, false,						  prefData->offTrack[kSmallerPrefBox],						  prefData->onTrack[kSmallerPrefBox] );	if ( mp.compatibleDraws )		CopyOffToOffRect( prefData->hiliteOff, true,						  (GWorldPtr)prefData->mainWind, false,						  prefData->offTrack[kCompatiblePrefBox],						  prefData->onTrack[kCompatiblePrefBox] );}// reveal me!void RevealPrefs( MRPrefCBData psd ) {	int		numSteps = (psd->offRect.bottom / kPrefRevealStep)/2;	int 	step;	Rect	topRect, botRect;	Rect 	topRectFrom, botRectFrom;	int		midFitRect = (psd->onRect.top + psd->onRect.bottom)/2;	long 	theTick;		SetRect( &topRect, psd->onRect.left, midFitRect - kPrefRevealStep,					   psd->onRect.right, midFitRect );	SetRect( &botRect, psd->onRect.left, midFitRect, 					   psd->onRect.right, midFitRect + kPrefRevealStep );	SetRect( &topRectFrom, 0, 0, psd->offRect.right, kPrefRevealStep );	SetRect( &botRectFrom, 0, psd->offRect.bottom - kPrefRevealStep,						   psd->offRect.right, 						   psd->offRect.bottom );		PlaySoundID( kPrefSoundID );	for ( step = 0; step < numSteps; step++ ) {		theTick = TickCount();				CopyOffToOffRect( psd->off, true, 						  (GWorldPtr)psd->mainWind, false,						  topRectFrom, topRect );		CopyOffToOffRect( psd->off, true, 						  (GWorldPtr)psd->mainWind, false,						  botRectFrom, botRect );		topRect.top -= kPrefRevealStep;		topRectFrom.bottom += kPrefRevealStep;		botRect.bottom += kPrefRevealStep;		botRectFrom.top -= kPrefRevealStep;				while (TickCount()-theTick<kPrefRevealDelay);	}		DrawPictureID( kPrefLoPict, psd->onRect );}MRPrefCBData MakeNewPrefData( MRIntfCBData cbData ) {	MRPrefCBData 	prefData;	int				i;		// allocate	prefData = (MRPrefCBData) DBG_NewPtrClear(sizeof(struct MRPrefCBDataStruct));		// main window	prefData->mainWind = cbData->mainWind;		// bubble rect	SetRectDelta( &prefData->bubbleRect, 83, 120, 32, 32 );		// set off-tracking rectangles	SetRectDelta( &prefData->offTrack[kUpPrefBox], 77, 68, 44, 42 );	SetRectDelta( &prefData->offTrack[kRightPrefBox], 125, 114, 42, 44 );	SetRectDelta( &prefData->offTrack[kLeftPrefBox], 31, 114, 44, 44 );	SetRectDelta( &prefData->offTrack[kDownPrefBox], 77, 162, 44, 42 );	SetRectDelta( &prefData->offTrack[kSpecialPrefBox], 129, 213, 34, 17 );	SetRectDelta( &prefData->offTrack[kPausePrefBox], 129, 238, 34, 17 );	SetRectDelta( &prefData->offTrack[kSuicidePrefBox], 129, 263, 34, 17 );	SetRectDelta( &prefData->offTrack[kMusicLArrowPrefBox], 27, 317, 10, 11 );	SetRectDelta( &prefData->offTrack[kMusicRArrowPrefBox], 161, 317, 10, 11 );	SetRectDelta( &prefData->offTrack[kSoundLArrowPrefBox], 27, 363, 10, 11 );	SetRectDelta( &prefData->offTrack[kSoundRArrowPrefBox], 161, 363, 10, 11 );	SetRectDelta( &prefData->offTrack[kInterlacePrefBox], 17, 385, 12, 11 );	SetRectDelta( &prefData->offTrack[kSmallerPrefBox], 17, 404, 12, 11 );	SetRectDelta( &prefData->offTrack[kCompatiblePrefBox], 17, 423, 12, 11 );		// more off-tracking rectangles	SetRectDelta( &prefData->offTrack[kMusicPictPrefBox], 37, 313, 0, 0 );	SetRectDelta( &prefData->offTrack[kSoundPictPrefBox], 37, 359, 0, 0 );		// even more!	SetRect( &prefData->offTrack[kCancelPrefBox], 11, 440, 92, 468 );	SetRect( &prefData->offTrack[kOkayPrefBox], 108, 440, 189, 468 );		// now get the big rectangles	prefData->offRect = RectFromPictureID( kPrefLoPict );	prefData->onRect = prefData->offRect;	CenterRect( &prefData->onRect, &prefData->mainWind->portRect );		// now allocate the offscreens!	(void)MacMakeGWorldDepth( prefData->offRect, CURRENT_DEPTH, &prefData->off );	(void)MacMakeGWorldDepth( prefData->offRect, CURRENT_DEPTH, &prefData->hiliteOff );	// draw the images	DrawPictToWorld( prefData->off, kPrefLoPict );	DrawPictToWorld( prefData->hiliteOff, kPrefHiPict );		// offset the onscreen track rectangles	for ( i = 0; i < kMaxPrefBox; i++ ) {		prefData->onTrack[i] = prefData->offTrack[i];		OffsetRect( &prefData->onTrack[i], prefData->onRect.left, prefData->onRect.top );	}		// make the bubble	MRRestoreGfxAlias();		OffsetRect( &prefData->bubbleRect, prefData->onRect.left, prefData->onRect.top );	prefData->bubbleData = MakeNewBubble( prefData->bubbleRect );	MRMainResFile();	MRSetGfxAlias();	MRRestoreResFile();		return prefData;}void UnhilitePrefBox( MRPrefCBData prefData, int i ) {	MRPrefs mp = GetCurrentPrefs();		CopyOffToOffRect( prefData->off, true,					  (GWorldPtr)prefData->mainWind, false,					  prefData->offTrack[i],					  prefData->onTrack[i] );	if ( i == kUpPrefBox )		DrawCharBox( mp.upKey, prefData->onTrack[kUpPrefBox], 12 );	else if ( i == kLeftPrefBox )		DrawCharBox( mp.leftKey, prefData->onTrack[kLeftPrefBox], 12 );	else if ( i == kRightPrefBox )		DrawCharBox( mp.rightKey, prefData->onTrack[kRightPrefBox], 12 );	else if ( i == kDownPrefBox )		DrawCharBox( mp.downKey, prefData->onTrack[kDownPrefBox], 12 );	else if ( i == kSpecialPrefBox )		DrawCharBox( mp.specialKey, prefData->onTrack[kSpecialPrefBox], 10 );	else if ( i == kSuicidePrefBox )		DrawCharBox( mp.suicideKey, prefData->onTrack[kSuicidePrefBox], 10 );	else if ( i == kPausePrefBox )		DrawCharBox( mp.pauseKey, prefData->onTrack[kPausePrefBox], 10 );}void HilitePrefBox( MRPrefCBData prefData, int i ) {	MRPrefs mp = GetCurrentPrefs();		if ( i <= kDownPrefBox ) {		CopyOffToOffRect( prefData->hiliteOff, true,						  (GWorldPtr)prefData->mainWind, false,						  prefData->offTrack[i],						  prefData->onTrack[i] );		if ( i == kUpPrefBox )			DrawCharBox( mp.upKey, prefData->onTrack[kUpPrefBox], 12 );		else if ( i == kLeftPrefBox )			DrawCharBox( mp.leftKey, prefData->onTrack[kLeftPrefBox], 12 );		else if ( i == kRightPrefBox )			DrawCharBox( mp.rightKey, prefData->onTrack[kRightPrefBox], 12 );		else if ( i == kDownPrefBox )			DrawCharBox( mp.downKey, prefData->onTrack[kDownPrefBox], 12 );	} else {		ForeColor(whiteColor);		FrameRect(&prefData->onTrack[i]);		ForeColor(blackColor);	}		prefData->lastHilite = i;}Boolean Pref_IdleCallback(int modifiers, MRUData info ) {	MRPrefCBData	prefData = (MRPrefCBData) info;	KeepMusicGoing();	BubbleOliver( prefData->bubbleData );		return false;}Boolean Pref_KeyCallback(char theKey, int modifiers, MRUData info, Boolean keyUp ) {	MRPrefCBData	prefData = (MRPrefCBData) info;	MRPrefs			mp = GetCurrentPrefs();		if ( prefData->lastHilite && keyUp ) {		int i = prefData->lastHilite;				if ( i == kUpPrefBox ) {			if ( theKey == mp.leftKey || 				 theKey == mp.rightKey ||				 theKey == mp.downKey ||				 theKey == mp.specialKey ||				 theKey == mp.suicideKey ||				 theKey == mp.pauseKey ) {				UnhilitePrefBox( prefData, prefData->lastHilite );				PlaySoundID( kPrefBadKeySnd );				prefData->lastHilite = 0;				return false;			}		} else if ( i == kLeftPrefBox ) {			if ( theKey == mp.upKey || 				 theKey == mp.rightKey ||				 theKey == mp.downKey ||				 theKey == mp.specialKey ||				 theKey == mp.suicideKey ||				 theKey == mp.pauseKey ) {				UnhilitePrefBox( prefData, prefData->lastHilite );				PlaySoundID( kPrefBadKeySnd );				prefData->lastHilite = 0;				return false;			}		} else if ( i == kRightPrefBox ) {			if ( theKey == mp.leftKey || 				 theKey == mp.upKey ||				 theKey == mp.downKey ||				 theKey == mp.specialKey ||				 theKey == mp.suicideKey ||				 theKey == mp.pauseKey ) {				UnhilitePrefBox( prefData, prefData->lastHilite );				PlaySoundID( kPrefBadKeySnd );				prefData->lastHilite = 0;				return false;			}		} else if ( i == kDownPrefBox ) {			if ( theKey == mp.leftKey || 				 theKey == mp.rightKey ||				 theKey == mp.upKey ||				 theKey == mp.specialKey ||				 theKey == mp.suicideKey ||				 theKey == mp.pauseKey ) {				UnhilitePrefBox( prefData, prefData->lastHilite );				PlaySoundID( kPrefBadKeySnd );				prefData->lastHilite = 0;				return false;			}				} else if ( i == kSpecialPrefBox ) {			if ( theKey == mp.leftKey || 				 theKey == mp.rightKey ||				 theKey == mp.downKey ||				 theKey == mp.upKey ||				 theKey == mp.suicideKey ||				 theKey == mp.pauseKey ) {				UnhilitePrefBox( prefData, prefData->lastHilite );				PlaySoundID( kPrefBadKeySnd );				prefData->lastHilite = 0;				return false;			}				} else if ( i == kSuicidePrefBox ) {			if ( theKey == mp.leftKey || 				 theKey == mp.rightKey ||				 theKey == mp.downKey ||				 theKey == mp.specialKey ||				 theKey == mp.upKey ||				 theKey == mp.pauseKey ) {				UnhilitePrefBox( prefData, prefData->lastHilite );				PlaySoundID( kPrefBadKeySnd );				prefData->lastHilite = 0;				return false;			}		} else if ( i == kPausePrefBox ) {			if ( theKey == mp.leftKey || 				 theKey == mp.rightKey ||				 theKey == mp.downKey ||				 theKey == mp.specialKey ||				 theKey == mp.suicideKey ||				 theKey == mp.upKey ) {				UnhilitePrefBox( prefData, prefData->lastHilite );				PlaySoundID( kPrefBadKeySnd );				prefData->lastHilite = 0;				return false;			}		}				if ( i == kUpPrefBox )			mp.upKey = theKey;		else if ( i == kLeftPrefBox )			mp.leftKey = theKey;		else if ( i == kRightPrefBox )			mp.rightKey = theKey;		else if ( i == kDownPrefBox )			mp.downKey = theKey;		else if ( i == kSpecialPrefBox )			mp.specialKey = theKey;		else if ( i == kSuicidePrefBox )			mp.suicideKey = theKey;		else if ( i == kPausePrefBox )			mp.pauseKey = theKey;		SetCurrentPrefs(mp);				UnhilitePrefBox( prefData, prefData->lastHilite );		PlaySoundID( kClickSnd );		prefData->lastHilite = 0;		return false;	}		if ( prefData->lastHilite )		return false;			if ( theKey == (char)13 || theKey == (char)3 ) {		if (!keyUp) {			PlaySoundID( kTickSnd );			CopyOffToOffRect( prefData->hiliteOff, true,							  (GWorldPtr)prefData->mainWind, false,							  prefData->offTrack[kOkayPrefBox],							  prefData->onTrack[kOkayPrefBox] );		} else {			PlaySoundID( kClickSnd );			prefData->okayClicked = true;			CopyOffToOffRect( prefData->off, true,							  (GWorldPtr)prefData->mainWind, false,							  prefData->offTrack[kOkayPrefBox],							  prefData->onTrack[kOkayPrefBox] );			return true;		}	}		return false;}Boolean TrackCheckBox( MRPrefCBData prefData, int i, Boolean isChecked ) {	Boolean hilite = false;	Point mouseLoc;	Rect onRect, offRect;		onRect = prefData->onTrack[i];	offRect = prefData->offTrack[i];		while (Button()) {		BubbleOliver( prefData->bubbleData );				GetMouse( &mouseLoc );				if ( PtInRect( mouseLoc, &onRect ) && !hilite ) {			hilite = true;			ForeColor(whiteColor);			FrameRect( &onRect );			ForeColor(blackColor);		} else if ( !PtInRect( mouseLoc, &onRect ) && hilite ) {			hilite = false;			CopyOffToOffRect( isChecked?prefData->hiliteOff:prefData->off, true,								  (GWorldPtr)prefData->mainWind, false,								  offRect, onRect );										  		}	}		if (hilite) {		CopyOffToOffRect( isChecked?prefData->off:prefData->hiliteOff, true,								  (GWorldPtr)prefData->mainWind, false,								  offRect, onRect );	}		return hilite;}Boolean PrefClickAction( Point location, MRPrefCBData prefData, int i ) {	MRPrefs mp = GetCurrentPrefs();		if ( prefData->lastHilite ) {		UnhilitePrefBox( prefData, prefData->lastHilite );		prefData->lastHilite = 0;	}		if ( i == kInterlacePrefBox || i == kSmallerPrefBox || i == kCompatiblePrefBox ) {		Boolean startHilite;				if ( i == kInterlacePrefBox )			startHilite = ( mp.interlacedMode );		else if ( i == kSmallerPrefBox )			startHilite = ( mp.screenSize );		else			startHilite = ( mp.compatibleDraws );					PlaySoundID( kTickSnd );						if (TrackCheckBox( prefData, i, startHilite )) {			PlaySoundID( kClickSnd );						if ( i == kInterlacePrefBox )				mp.interlacedMode = !mp.interlacedMode;			else if ( i == kSmallerPrefBox )				mp.screenSize = kPrefsSmallScreenSize - mp.screenSize;			else				mp.compatibleDraws = !mp.compatibleDraws;		}	} else if ( i == kMusicPictPrefBox || i == kSoundPictPrefBox ) {	} else if ( i >= kUpPrefBox && i <= kSuicidePrefBox ) {		HilitePrefBox( prefData, i );		PlaySoundID( kTickSnd );//	} else if ( i >= kSpecialPrefBox && i <= kSuicidePrefBox ) {	}	else {				// play the tick snd		PlaySoundID( kTickSnd );				// any 'ol box!		if (TrackGraphicalButton( prefData->mainWind,								  prefData->offTrack[i],								  prefData->onTrack[i],								  prefData->off,								  prefData->hiliteOff,								  prefData->bubbleData )) {			PlaySoundID( kClickSnd );						if ( i == kCancelPrefBox ) 				return true;			if ( i == kOkayPrefBox ) {				prefData->okayClicked = true;				return true;			}						// music volume click			if ( i == kMusicLArrowPrefBox ) {				PrefLArrow( &mp.musicVolume );				DrawPrefVolume( prefData, mp.musicVolume, prefData->onTrack[kMusicPictPrefBox] );			} else if ( i == kMusicRArrowPrefBox ) {				PrefRArrow( &mp.musicVolume );				DrawPrefVolume( prefData, mp.musicVolume, prefData->onTrack[kMusicPictPrefBox] );			}						// sound volume click			if ( i == kSoundLArrowPrefBox ) {				PrefLArrow( &mp.soundVolume );				DrawPrefVolume( prefData, mp.soundVolume, prefData->onTrack[kSoundPictPrefBox] );			} else if ( i == kSoundRArrowPrefBox ) {				PrefRArrow( &mp.soundVolume );				DrawPrefVolume( prefData, mp.soundVolume, prefData->onTrack[kSoundPictPrefBox] );			}					}	}		SetCurrentPrefs( mp );		return false;}Boolean Pref_ClickCallback(Point location, int modifiers, MRUData info ) {	MRPrefCBData	prefData = (MRPrefCBData) info;	int i;		// check the various tracking rectangles	for ( i = 0; i < kMaxPrefBox; i++ )		if ( PtInRect( location, &prefData->onTrack[i] ) )			return PrefClickAction( location, prefData, i );		return false;}void KillPrefData( MRPrefCBData* prefData ) {	DestroyGWorld( &((*prefData)->off) );	DestroyGWorld( &((*prefData)->hiliteOff) );	KillBubble( &((*prefData)->bubbleData) );}void BeginPreferences( MRIntfCBData cbData ) {	MRPrefCBData	prefData;	MRPrefs			oldPrefs = GetCurrentPrefs();	MRPrefs			mp;		// demonstrate modality of the prefs dialog box.	DimRectangle( cbData->mainWind->portRect, true, true );		// set graphics aliases	MRMainResFile();	MRSetGfxAlias();	MRRestoreResFile();	// allocate memory for the prefData cbinfo.	prefData = MakeNewPrefData(cbData);		// make the prefs dialog box appear	RevealPrefs(prefData);		// hack	SetSoundState( true );		// set us up to handle prefs dlog loop	//MRClearCallbacks();	MRSetSleepTime( 0 );	MRSetClickCallback( Pref_ClickCallback );	MRSetKeyUpDownCallback( Pref_KeyCallback );	MRSetIdleCallback( Pref_IdleCallback );		// draw all prefs	SetPort( cbData->mainWind );	DrawAllPrefs( prefData );		// run the main loop!	MREventLoop( (MRUData) prefData );		mp = GetCurrentPrefs();		// now set the prefs back if cancel was clicked	if ( !prefData->okayClicked )		SetCurrentPrefs( oldPrefs );	else if ( oldPrefs.musicVolume != mp.musicVolume ) {		FadeMusicOut();		StopMusic();		if ( mp.musicVolume ) {			SetMusicState(true);			PlayMusic( kInterfaceMusic, true );		} else {			SetMusicState(false);		}	}		mp = GetCurrentPrefs();	if ( mp.soundVolume )		SetSoundState( true );	else		SetSoundState( false );		// kill the pref cbData	KillPrefData( &prefData );		// restore graphics aliases	MRRestoreGfxAlias();		// redraw the interface	UpdateInterface( cbData->mainWind );		// reset the callbacks	SetInterfaceCallbacks( cbData->mainWind );}void DoTempPrefs( MRIntfCBData cbData ) {	DialogPtr		prefsDlog;	short			itemHit;	MRPrefs			mp = GetCurrentPrefs();	short			itemType;	Handle			item;	Rect			itemRect;	char			tStr[256];		// unhide the menubar	ShowMenuBar( cbData->mainWind );		// fade the music out	FadeMusicOut();	StopMusic();		// get the dlog	prefsDlog = GetNewDialog( 8500, NULL, (WindowPtr)-1 );		// set the initial values for the checkboxes	if ( mp.interlacedMode ) {		GetDialogItem( prefsDlog, 5, &itemType, &item, &itemRect );		SetControlValue( (ControlHandle)item, 1 );	}	if ( mp.screenSize != kPrefsNormalScreenSize ) {		GetDialogItem( prefsDlog, 4, &itemType, &item, &itemRect );		SetControlValue( (ControlHandle)item, 1 );	}	if ( mp.musicVolume ) {		GetDialogItem( prefsDlog, 2, &itemType, &item, &itemRect );		SetControlValue( (ControlHandle)item, 1 );	}	if ( mp.soundVolume ) {		GetDialogItem( prefsDlog, 3, &itemType, &item, &itemRect );		SetControlValue( (ControlHandle)item, 1 );	}		// and for the player keys	GetDialogItem( prefsDlog, 6, &itemType, &item, &itemRect );	CharToCharStr( mp.upKey, tStr );	SetDialogItemText( item, C2PStr(tStr ) );		GetDialogItem( prefsDlog, 7, &itemType, &item, &itemRect );	CharToCharStr( mp.downKey, tStr );	SetDialogItemText( item, C2PStr(tStr ) );	GetDialogItem( prefsDlog, 8, &itemType, &item, &itemRect );	CharToCharStr( mp.leftKey, tStr );	SetDialogItemText( item, C2PStr(tStr ) );	GetDialogItem( prefsDlog, 9, &itemType, &item, &itemRect );	CharToCharStr( mp.rightKey, tStr );	SetDialogItemText( item, C2PStr(tStr ) );	GetDialogItem( prefsDlog, 10, &itemType, &item, &itemRect );	CharToCharStr( mp.specialKey, tStr );	SetDialogItemText( item, C2PStr(tStr ) );	GetDialogItem( prefsDlog, 11, &itemType, &item, &itemRect );	CharToCharStr( mp.suicideKey, tStr );	SetDialogItemText( item, C2PStr(tStr ) );	GetDialogItem( prefsDlog, 12, &itemType, &item, &itemRect );	CharToCharStr( mp.pauseKey, tStr );	SetDialogItemText( item, C2PStr(tStr ) );			SetPort( prefsDlog );	ShowWindow( prefsDlog );		do {		ModalDialog( NULL, &itemHit );				if ( itemHit >= 2 && itemHit <= 5 ) {			GetDialogItem( prefsDlog, itemHit, &itemType, &item, &itemRect );			SetControlValue( (ControlHandle)item, 1-GetControlValue((ControlHandle)item) );			if ( itemHit == 2 )				mp.musicVolume = 255 - mp.musicVolume;			else if ( itemHit == 3 )				mp.soundVolume = 255 - mp.soundVolume;			else if ( itemHit == 4 )				mp.screenSize = kPrefsSmallScreenSize - mp.screenSize;			else if ( itemHit == 5 )				mp.interlacedMode = !mp.interlacedMode;		} else if ( itemHit >= 6 && itemHit <= 12 ) {			EventRecord 	theEvent;			// the event we recieved, if any			short			theMask = keyDownMask;			Boolean			done, eventIsOurs;						GetDialogItem( prefsDlog, itemHit, &itemType, &item, &itemRect );			InvertRect( &itemRect );						while (Button());			done = false;			while (!Button() && !done) {									eventIsOurs = WaitNextEvent( theMask, &theEvent, 											 0, NULL );											 				if ( eventIsOurs && theEvent.what == keyDown ) {					char key;										key = (char) ( ( theEvent.message ) & ( charCodeMask ) );									CharToCharStr( key, tStr );					SetDialogItemText( item, C2PStr(tStr) );					InvertRect( &itemRect );					done = true;										// set the key					if ( itemHit == 6 )						mp.upKey = key;					else if ( itemHit == 7 )						mp.downKey = key;					else if ( itemHit == 8 )						mp.leftKey = key;					else if ( itemHit == 9 )						mp.rightKey = key;					else if ( itemHit == 10 )						mp.specialKey = key;					else if ( itemHit == 11 )						mp.suicideKey = key;					else if ( itemHit == 12 )						mp.pauseKey = key;				} else if ( eventIsOurs && theEvent.what == mouseDown )					done = true;			}						//while (Button());			InvertRect( &itemRect );		}			} while ( itemHit != 1 );		DisposeDialog( prefsDlog );		// set the prefs	SetCurrentPrefs( mp );	SetSoundState( mp.soundVolume == 255 );	SetMusicState( mp.musicVolume == 255 );		// reset the port	SetPort( cbData->mainWind );	HideMenuBar( cbData->mainWind );	UpdateInterface( cbData->mainWind );		// fade the music back in again	PlayMusic( kInterfaceMusic, true );	}Rect WindowQSoftRect( WindowPtr wind ) {	Rect r = wind->portRect;	Rect pid = RectFromPictureID( kQSoftBannerPict );		r.bottom = r.top + pid.bottom;	return r;}Rect WindowMRRect( WindowPtr wind ) {	Rect r = wind->portRect;	Rect pid = RectFromPictureID( kMRBannerPict );			r.top = r.bottom - pid.bottom;	return r;}Rect WindowContentRect( WindowPtr wind ) {	// remember that the two banners are the same height!	Rect r = wind->portRect;	Rect pid = RectFromPictureID( kMRBannerPict );		r.top = r.top + pid.bottom;	r.bottom = r.bottom - pid.bottom;	return r;}Boolean BiggerWindow( WindowPtr wind ) {	// return true if it is a bigger than usual window	int he;//, wi;	//	wi = wind->portRect.right - wind->portRect.left;	he = wind->portRect.bottom - wind->portRect.top;		if ( he > 480 )		return true;		return false;}void DrawBanners( WindowPtr wind ) {	Rect qsr, mrr, r;		RGBColor oldColor;	RGBColor topLeft = kTopLeftRGBColor;	RGBColor topRight = kTopRightRGBColor;	RGBColor botLeft = kBotLeftRGBColor;	RGBColor botRight = kBotRightRGBColor;			qsr = WindowQSoftRect( wind );	mrr = WindowMRRect( wind );		// draw the extension colors!	GetForeColor( &oldColor );	RGBForeColor( &topLeft );	r = qsr;	r.right = qsr.right / 2;	FillRect( &r, &qd.black );	RGBForeColor( &topRight );	r = qsr;	r.left = qsr.right / 2;	FillRect( &r, &qd.black );	RGBForeColor( &botLeft );	r = mrr;	r.right = mrr.right / 2;	FillRect( &r, &qd.black );		RGBForeColor( &botRight );	r = mrr;	r.left = mrr.right / 2;	FillRect( &r, &qd.black );	RGBForeColor( &oldColor );		// center the pictures & draw:	DrawPictureIDCentered( kQSoftBannerPict, qsr );	DrawPictureIDCentered( kMRBannerPict, mrr );		}void DrawInterface( WindowPtr wind ) {	DrawPictureIDCentered( kInterfacePict, wind->portRect );}void UpdateInterface( WindowPtr wind ) {	DrawInterface( wind );	DrawBanners( wind );}// blacken that window!void WipeWindow( WindowPtr wind, Boolean andBanners ) {	// this is a visual wipe.	// it wipes the 640x480 center of your screen.	// actually, it wipes the full width of your screen	// this is eye candy at its finest, folks.		// if you specify to wipe the banners, it does that last.	// the spec only makes a difference in big windows.	Rect wipedArea;	Rect wipeRect, newRect;	int stripeCount;	int stepCount;	int numStripes, numSteps;	Boolean whichWay;	Rect blackenRect;	long startTick = 0;			// figure the area to by wiped.	SetRect( &wipedArea, 0, 0, 640, 480 );	CenterRect( &wipedArea, &wind->portRect );		// if we're in no-fades mode, quit quickly	if ( MR_DISABLE_ALL_FADES ) {		FillRect( &wipedArea, &qd.black );		return;	}		// how many stripes will there be?	numStripes = (wipedArea.bottom - wipedArea.top) / kWipeHeight;		// and how many steps will be taken?	numSteps = (wipedArea.right - wipedArea.left) / kWipeStep;		ForeColor( blackColor );	BackColor( whiteColor );		// do the wipe!	for ( stepCount = 0; stepCount<numSteps; stepCount++ ) {			wipeRect = wipedArea;		wipeRect.bottom = wipeRect.top + kWipeHeight;		whichWay = false;				for ( stripeCount = 0; stripeCount<numStripes; stripeCount++ ) {			newRect = wipeRect;						if ( whichWay ) {				OffsetRect( &newRect, -kWipeStep, 0 );				if ( COMPILE_IS_68K )					SetRect( &blackenRect, wipeRect.right - (kWipeStep * (stepCount+1)),										   newRect.top,										   wipeRect.right,										   newRect.bottom );   								else					SetRect( &blackenRect, newRect.right,										   newRect.top,										   wipeRect.right,										   newRect.bottom );													} else {				OffsetRect( &newRect, kWipeStep, 0 );				if ( COMPILE_IS_68K )					SetRect( &blackenRect, wipeRect.left,										   newRect.top,										   wipeRect.left + (kWipeStep* (stepCount+1)),										   newRect.bottom );   				else					SetRect( &blackenRect, wipeRect.left,										   newRect.top,										   newRect.left,										   newRect.bottom );			}						whichWay = (!whichWay);						// don't do the visual slide if we're on a 68k machine:			// it will be too slow. (think of it as eye-candy bonus for			// those of us with PPCs).			if ( COMPILE_IS_68K == 0 ) 				CopyBits( &wind->portBits, &wind->portBits, 					 	  &wipeRect, &newRect,					 	  srcCopy, NULL );						FillRect( &blackenRect, &qd.black );				OffsetRect( &wipeRect, 0, kWipeHeight );		}				while ( TickCount() - startTick < 2 )				KeepMusicGoing();			startTick = TickCount();				}		wipedArea.left = wind->portRect.left;	wipedArea.right = wind->portRect.right;	// and how many steps will be taken?	numSteps = (wipedArea.right - wipedArea.left) / kWipeStep;		if (( andBanners ) && ( BiggerWindow( wind ) )) {		// blacken the banners in some wierd funktified way.		Rect qsr, mrr;		long startTick;				qsr = WindowQSoftRect( wind );		mrr = WindowMRRect( wind );				qsr.right = qsr.left + kWipeStep;		mrr.left = mrr.right - kWipeStep;				for ( stepCount = 0; stepCount<numSteps; stepCount++ ) {			startTick = TickCount();						FillRect( &qsr, &qd.black );			FillRect( &mrr, &qd.black );			qsr.right += kWipeStep;			mrr.left -= kWipeStep;						while (TickCount()-startTick < kWipeDelay)				KeepMusicGoing();		}		}}Boolean TrackIntfHilite( MRIntfCBData theData, int lastHilite, Rect hRect ) {	Boolean hilited = false;	Boolean prevHilite = false;	Point p;		while (Button()) {		GetMouse( &p );		if ((PtInRect( p, &hRect )) && (!hilited)) {			DrawInterfaceItem( theData, lastHilite, kClickIntfHilite );			hilited = true;			if ( !prevHilite ) {				PlaySoundID( kTickSnd );				prevHilite = true;			}					} else if ((!PtInRect(p, &hRect)) && (hilited)) {			DrawInterfaceItem( theData, lastHilite, kNoIntfHilite );			hilited = false;		}				KeepMusicGoing();		BubbleOliver( theData->bubbleData );	}		if ( hilited )		DrawInterfaceItem( theData, lastHilite, kNoIntfHilite );	return hilited;}Boolean Intf_ClickCallback(Point location, int modifiers, MRUData info ) {	MRIntfCBData theData = (MRIntfCBData) info;	if ( theData == NULL )		return true;			switch ( theData->currentState ) {		case kIntroState:		case kCreditsState:		case kHelpState:			WipeWindow( theData->mainWind,false );			theData->currentState = kInterfaceState;			DrawInterface( theData->mainWind );			if (!BiggerWindow( theData->mainWind ))				DrawBanners( theData->mainWind );			return false;			break;			case kInterfaceState:						if ( theData->lastHilite != kNoHilite )				if ( TrackIntfHilite( theData, theData->lastHilite, 									  theData->hiliteRects[theData->lastHilite]									  ) ) {									  					// user clicked - play the sound:					PlaySoundID( kClickSnd );										if ( theData->lastHilite == kQuitHilite ) {						FadeMusicOut();						interface_returnValue = kQuitReturn;						return true;					}										// did they click start?					if ( theData->lastHilite == kStartHilite ) {						FadeMusicOut();						StopMusic();												// the full wipe window also kills the banners at the						// top and bottom for bigger-than windows.						HideCursor();						WipeWindow( theData->mainWind, true );												//DrawPictureIDCentered( kMapPict, theData->mainWind->portRect);												//PlayMusic( kMapRoomMusic, true );												interface_returnValue = kMapRoomReturn;						return true;					}										// otherwise if != prefs					if ( theData->lastHilite != kPrefsHilite ) {						int pictID;												// clean the screen.						WipeWindow( theData->mainWind, false );												// drop image onto screen:						switch( theData->lastHilite ) {							case kIntroHilite:								pictID = kIntroPict;								theData->currentState = kIntroState;								break;							case kCreditsHilite:								pictID = kAboutPict;								theData->currentState = kCreditsState;								break;							case kHelpHilite:								pictID = kHelpPict;								theData->currentState = kHelpState;								break;						}												WipePictIntoWindow( theData->mainWind, pictID );												{ 							Rect r = RectFromPictureID( pictID + kAddForTextPict );														CenterRect( &r, &theData->mainWind->portRect );							OffsetRect( &r, 40, 0 );														DrawPictureID( pictID + kAddForTextPict , r );						}					}										if ( theData->lastHilite == kPrefsHilite ) {						// handle prefs. right now, just switch between						// screen sizes:						BeginPreferences( theData );					}				}							return false;			break;					default:			return true;	}}	void ConvertToLower( char* theKey ) {	if (*theKey >= 'A' && *theKey <= 'Z')		*theKey = (char)(((short)*theKey - (short)'A') + (short)'a');}Boolean Intf_KeyCallback(char theKey, int modifiers, MRUData info, Boolean keyUp ) {	MRIntfCBData theData = (MRIntfCBData) info;	int	theHilite = kNoHilite;		if ( theData == NULL )		return true;			switch ( theData->currentState ) {		case kIntroState:		case kCreditsState:		case kHelpState:			if ( theKey == (char)13 && keyUp ) {				WipeWindow( theData->mainWind,false );				theData->currentState = kInterfaceState;				DrawInterface( theData->mainWind );				if (!BiggerWindow( theData->mainWind ))					DrawBanners( theData->mainWind );			}			return false;			break;				case kInterfaceState:			ConvertToLower( &theKey );						if ( theKey == 'q' )				theHilite = kQuitHilite;			else if ( theKey == 'i' )				theHilite = kIntroHilite;			else if ( theKey == 'c' )				theHilite = kCreditsHilite;			else if ( theKey == 'h' )				theHilite = kHelpHilite;			else if ( theKey == 's' || theKey == (char)13 || theKey == (char)3)				theHilite = kStartHilite;			else if ( theKey == 'p' )				theHilite = kPrefsHilite;							if ( theHilite != kNoHilite ) {				if ( !keyUp ) {					if ( theData->lastHilite != kNoHilite )						DrawInterfaceItem( theData, theData->lastHilite, kNoIntfHilite );					DrawInterfaceItem( theData, theHilite, kClickIntfHilite );					theData->avoidHilite = theData->lastHilite;					theData->lastHilite = theHilite;					theData->lastWasKey = true;					PlaySoundID( kTickSnd );				} else if ( theData->lastHilite == theHilite ) {					DrawInterfaceItem( theData, theHilite, kNoIntfHilite );					theData->lastWasKey = false;					PlaySoundID( kClickSnd );					if ( theData->lastHilite == kQuitHilite ) {						FadeMusicOut();						interface_returnValue = kQuitReturn;						return true;					}										// did they click start?					if ( theData->lastHilite == kStartHilite ) {						FadeMusicOut();						StopMusic();												// the full wipe window also kills the banners at the						// top and bottom for bigger-than windows.						HideCursor();						WipeWindow( theData->mainWind, true );												//DrawPictureIDCentered( kMapPict, theData->mainWind->portRect);												//PlayMusic( kMapRoomMusic, true );												interface_returnValue = kMapRoomReturn;						return true;					}										// otherwise if != prefs					if ( theData->lastHilite != kPrefsHilite ) {						int pictID;												// clean the screen.						WipeWindow( theData->mainWind, false );												// drop image onto screen:						switch( theData->lastHilite ) {							case kIntroHilite:								pictID = kIntroPict;								theData->currentState = kIntroState;								break;							case kCreditsHilite:								pictID = kAboutPict;								theData->currentState = kCreditsState;								break;							case kHelpHilite:								pictID = kHelpPict;								theData->currentState = kHelpState;								break;						}												WipePictIntoWindow( theData->mainWind, pictID );												{ 							Rect r = RectFromPictureID( pictID + kAddForTextPict );														CenterRect( &r, &theData->mainWind->portRect );							OffsetRect( &r, 40, 0 );														DrawPictureID( pictID + kAddForTextPict , r );						}					}										if ( theData->lastHilite == kPrefsHilite ) {						// handle prefs. right now, just switch between						// screen sizes:						BeginPreferences( theData );					}										theData->lastHilite = kNoIntfHilite;				}			}						return false;			break;				default:			return false;	}}int GetSelectedBox( MRIntfCBData theData, Point where ) {	int i;		for ( i = kIntroHilite; i < kMaxHilite; i++ ) {		if ( PtInRect( where, &theData->hiliteRects[i] ) )			return i;	}	return kNoHilite;}void DrawInterfaceItem( MRIntfCBData theData,							int which,							int hiliteState ) {	GWorldPtr fromWorld;	Rect fromRect, toRect;		if ( hiliteState == kClickIntfHilite )		fromWorld = theData->hiliteOff;	else if ( hiliteState == kMouseIntfHilite )		fromWorld = theData->mouseOff;	else		fromWorld = theData->normalOff;		toRect = theData->hiliteRects[which];	fromRect = toRect;	OffsetRect( &fromRect, -theData->adjustAmount.h, -theData->adjustAmount.v );		ForeColor( blackColor );	BackColor( whiteColor );		CopyOffToOffRect( fromWorld, true, (GWorldPtr) theData->mainWind, false, 					   fromRect, toRect );						   }Boolean Intf_IdleCallback(int modifiers, MRUData info ) {	MRIntfCBData theData = (MRIntfCBData) info;	Point mousePoint;	int selBox;		if ( theData == NULL )		return true;	GetMouse( &mousePoint );		KeepMusicGoing();		switch ( theData->currentState ) {		case kInterfaceState:				selBox = GetSelectedBox( theData, mousePoint );						if ( selBox != theData->lastHilite ) {				if (( theData->lastHilite != kNoHilite && !theData->lastWasKey )				    || (theData->lastHilite != kNoHilite && theData->lastWasKey && selBox != theData->avoidHilite )) {					DrawInterfaceItem( theData, theData->lastHilite, kNoIntfHilite );					theData->lastWasKey = false;				}								if ( selBox != kNoHilite && !theData->lastWasKey ) 					DrawInterfaceItem( theData, selBox, kMouseIntfHilite );			}						if ( !theData->lastWasKey )				theData->lastHilite = selBox;			BubbleOliver( theData->bubbleData );						return false;			break; // never reached, but just in case. :P				default:			return false;			break;			}}void SetInterfaceCallbacks( WindowPtr wind ) {	MRClearCallbacks();		MRSetSleepTime( kInterfaceSleepTime );	MRAllowKeyUp();		MRSetClickCallback( Intf_ClickCallback );	MRSetKeyUpDownCallback( Intf_KeyCallback );	MRSetIdleCallback( Intf_IdleCallback );}void SetHiliteRect( WindowPtr wind, MRIntfCBData theData, int whichRect, 							int h, int v, int w, int ht ) {	// must accomodate for centering of rectangle.	Rect pRect = RectFromPictureID( kInterfacePict );	Rect dumb;		CenterRect( &pRect, &wind->portRect );		// remember to offset everything by pRect.topLeft.	if ( whichRect != kOliverSpecialHilite )		SetRect( &theData->hiliteRects[whichRect],				 	h + pRect.left,				 	v + pRect.top,				 	h + w + pRect.left,				 	v + ht + pRect.top );	else		SetRect( &dumb, 				 	h + pRect.left,				 	v + pRect.top,				 	h + w + pRect.left,				 	v + ht + pRect.top );						theData->adjustAmount.h = pRect.left;	theData->adjustAmount.v = pRect.top;}// cryptic name, but obvious what it does.void DrawIntfPicWorld( GWorldPtr world, int picID ) {	Boolean			lockWorked;				// TRUE if locking the pixel map worked	GWorldPtr		oldWorld;				// Older world to remembr	GDHandle		oldGD;					// older GD, whatever that is.			// Lock the world's pixmap	lockWorked = LockPixels( world->portPixMap );	if ( lockWorked == false )		return;			// Remember our current port	GetGWorld( &oldWorld, &oldGD );		// And Set The port for drawing.	SetGWorld( world, NULL );		// Now draw the picture...	DrawPictureID( picID, RectFromPictureID( picID ) );			  	// Set the port back.	SetGWorld( oldWorld, oldGD );		// And unlock the pixels.	UnlockPixels( world->portPixMap );}MRIntfCBData MakeCallbackData( WindowPtr wind ) {	MRIntfCBData retData = (MRIntfCBData) DBG_NewPtrClear( sizeof( struct MRIntfCBDataStruct ) );	Rect picRec = RectFromPictureID( kInterfacePict );	Rect specRect;		if ( retData == NULL )		return NULL;			retData->mainWind = wind;	retData->currentState = kInterfaceState;	retData->lastHilite = kNoHilite;		if ( MacMakeGWorldDepth( picRec, CURRENT_DEPTH, &(retData->hiliteOff) ) != noErr ) {		DBG_DisposePtr( (Ptr) retData );		return NULL;	}		if ( MacMakeGWorldDepth( picRec, CURRENT_DEPTH, &(retData->normalOff) ) != noErr ) {		DestroyGWorld( &(retData->hiliteOff) );		DBG_DisposePtr( (Ptr) retData );		return NULL;	}	if ( MacMakeGWorldDepth( picRec, CURRENT_DEPTH, &(retData->mouseOff) ) != noErr ) {		DestroyGWorld( &(retData->hiliteOff) );		DestroyGWorld( &(retData->normalOff) );		DBG_DisposePtr( (Ptr) retData );		return NULL;	}		CenterRect( &picRec, &wind->portRect );	SetRect( &specRect, 304, 198, 304+32, 198+32 );	OffsetRect( &specRect, picRec.left, picRec.top );	SetPort( wind );	retData->bubbleData = MakeNewBubble( specRect );		// this is bad code, but works.	SetHiliteRect( wind, retData, kIntroHilite, 32, 96, 120, 40 );	SetHiliteRect( wind, retData, kCreditsHilite, 32, 156, 120, 40 );	SetHiliteRect( wind, retData, kHelpHilite, 32, 216, 120, 40 );	SetHiliteRect( wind, retData, kQuitHilite, 32, 276, 120, 40 );		// start hilite is tricky; it depends on the height of the window	if ( !BiggerWindow(wind) )		SetHiliteRect( wind, retData, kStartHilite, 258, 343, 222, 97 );	else		SetHiliteRect( wind, retData, kStartHilite, 258, 343, 222, 129 );			SetHiliteRect( wind, retData, kPrefsHilite, 9, 400, 182, 32 );	SetHiliteRect( wind, retData, kOliverSpecialHilite, 304, 198, 32, 32 );		// draw the pics	DrawIntfPicWorld( retData->hiliteOff, kSelInterfacePict );	DrawIntfPicWorld( retData->normalOff, kInterfacePict );	DrawIntfPicWorld( retData->mouseOff, kMouseInterfacePict );			return retData;}void DisposeCallbackData( MRIntfCBData theData ) {	DestroyGWorld( &theData->hiliteOff );	DestroyGWorld( &theData->normalOff );	DestroyGWorld( &theData->mouseOff );	KillBubble( &theData->bubbleData );	DBG_DisposePtr( (Ptr) theData );}void WipePictIntoWindow( WindowPtr wind, int pictID ) {	GWorldPtr newOffscreen;	Rect pRect = RectFromPictureID( pictID );	Rect fitRect;	int numSteps;	int extraSteps;	int i;	Rect fromRect, toRect;	long startTick;	Rect content = WindowContentRect( wind );		SetRect( &fitRect, 0, 0, 640, 480 );	CenterRect( &fitRect, &wind->portRect );	fitRect.right = fitRect.left + (pRect.right-pRect.left);		if ( MacMakeGWorldDepth( pRect,							CURRENT_DEPTH, 							&newOffscreen) != noErr ) {		// problems with memory? don't wipe. just draw:		DrawPictureID( pictID, fitRect );		return;	}	// Memory is good.	// Draw the picture onto the offscreen:	DrawIntfPicWorld( newOffscreen, pictID );		// calc steps required	numSteps = (fitRect.bottom-fitRect.top) / kWipeStep;		// and the copying rectangle:	toRect = fitRect;	if (BiggerWindow( wind )) {		int totalSteps;				toRect.bottom = content.bottom;				totalSteps = (content.bottom-fitRect.top) / kWipeStep;		extraSteps = totalSteps - numSteps;	}	toRect.top = toRect.bottom - kWipeStep;		fromRect = fitRect;	ZeroRect( &fromRect );	fromRect.bottom = fromRect.top + kWipeStep;		for ( i = 0; i < numSteps; i++ ) {		startTick = TickCount();		CopyOffToOffRect( newOffscreen, true, 						  (GWorldPtr) wind, false,						  fromRect, toRect );		fromRect.bottom += kWipeStep;		toRect.top -= kWipeStep;		while (TickCount()-startTick < kWipeDelay) {			KeepMusicGoing();		}	}		// if bigger window, gotsta go further:	if (BiggerWindow(wind)) {		Rect blackenRect;				SetRect( &blackenRect, toRect.left, 							   toRect.bottom,							   toRect.right,							   content.bottom );							   		for ( i = 0; i<extraSteps; i++ ) {			CopyOffToOffRect( newOffscreen, true, 							  (GWorldPtr) wind, false,							  fromRect, toRect );			blackenRect.top -= kWipeStep;			OffsetRect( &toRect, 0, -kWipeStep );			FillRect( &blackenRect, &qd.black );		}	}		// draw it final:	DrawPictureID( pictID, fitRect );		// Kill offscreen	DestroyGWorld( &newOffscreen );}int RunInterface( WindowPtr wind ) {	// the callback data is special data passed to the interface callbacks.	// I wrote a special event loop skeleton handler long ago, and I still	// use it even for games today.	FadeOut();		MRIntfCBData theCBData = MakeCallbackData( wind );	// assume something went wrong if the interface exits;	// the quit, map, prefs button override this.	interface_returnValue = kErrorReturn;		// Draw the interface. There are basically two modes:	// the 640x480 look, and the bigger-than-640x-480 look.	UpdateInterface( wind );		FadeIn();	if ( theCBData == NULL ) {		// big memory error 		FatalMRError( "Couldn't allocate enough memory. Try increasing with 'Get Info...'." );	}		// Set the event loop to call special procedural hooks.		SetInterfaceCallbacks( wind );	// intf music has its own fade, but	// i've decided to use both at once cuz	// i'm proud of my music fading code.	// :-P	// PlayMusic( kInterfaceMusic, true );		// run the event loop.	MREventLoop( (MRUData) theCBData );		StopMusic( );		// Clear the info about the procedural hooks.	MRClearCallbacks();		// no need to check key up/down	MRRestoreKeyUp();		if ( interface_returnValue != kErrorReturn )		FadeOutImmediate();		ShowCursor();		DisposeCallbackData( theCBData );		// return whatever happened.	return interface_returnValue;}
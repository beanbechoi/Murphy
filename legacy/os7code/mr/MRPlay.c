// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRPlay.c// Auth: Dave Peck// Date: 7/13/97// Desc: This is THE heavy-duty file for MR.//       it contains *all* the code to load a level, and then play it.// -----------------------------------------------------------------------------// Includes// -----------------------------------------------------------------------------#include "MRChore.h"#include "MRPlaySprite.h"#include "MRPlay.h"#include "MRPlayCommon.h"// -----------------------------------------------------------------------------// Constants// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Data Structures// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Global Data// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Function Prototypes// -----------------------------------------------------------------------------void DrawLevelRoom( LevelCBInfo cb );void MakeReplaySprite( LevelCBInfo cbData );// -----------------------------------------------------------------------------// Functions// -----------------------------------------------------------------------------Boolean NoSuchLevel( int levelIndex ) {	Boolean levExists = false;		MRWorldResFile();	levExists = MRResourceExists(kLevelResType, kLevelBaseID+levelIndex);	MRRestoreResFile();		return (!levExists);}Boolean Level_ClickBack( Point location, int modifiers, MRUData info ) {	LevelCBInfo	cbData = (LevelCBInfo) info;		if ( cbData->isPaused )		return false;			if ( cbData->oliverSprite == NULL ) {		if ( cbData->deathSprite == NULL && !cbData->wonLevel )			return false;				if ( cbData->wonLevel ) {			cbData->doneWithLevel = true;			return true;		}				// if mouse is inside one of the rects		if (PtInRect(location, &cbData->noRect)) {					// must keep music working.			MRRestoreSndAlias();			PlaySoundID( kTickSnd );			MRTerrainAlias();			MRSetSndAlias();			MRRestoreResFile();						if (TrackGraphicalButton( cbData->mainWind,									  cbData->noGfxRect,									  cbData->noRect,									  cbData->deathSprite->frameArray[0]->framePort,									  cbData->deathSprite->frameArray[1]->framePort,									  NULL )) {				MRRestoreSndAlias();				PlaySoundID( kClickSnd );				MRTerrainAlias();				MRSetSndAlias();				MRRestoreResFile();				cbData->doneWithLevel = true;			}		} else if (PtInRect(location, &cbData->yesRect)) {			MRRestoreSndAlias();			PlaySoundID( kTickSnd );			MRTerrainAlias();			MRSetSndAlias();			MRRestoreResFile();						if (TrackGraphicalButton( cbData->mainWind,									  cbData->yesGfxRect,									  cbData->yesRect,									  cbData->deathSprite->frameArray[0]->framePort,									  cbData->deathSprite->frameArray[1]->framePort,									  NULL )) {				MRRestoreSndAlias();				PlaySoundID( kClickSnd );				MRTerrainAlias();				MRSetSndAlias();				MRRestoreResFile();				cbData->doneWithLevel = true;				cbData->playAgain = true;			}		}			}		return cbData->doneWithLevel;}Boolean Level_KeyBack( char key, int modifiers, MRUData info, Boolean keyUp ) {	short	newKey = kNoMove;	MRPrefs thePrefs = GetCurrentPrefs();	LevelCBInfo cbData = (LevelCBInfo) info;	short n;		// last key time:	cbData->lastPressTime = TickCount();		// what if they hit the pausekey?	if ( key == thePrefs.pauseKey && cbData->oliverSprite ) {		if ( keyUp && !cbData->isPaused ) {			PlaySoundID( kPauseSnd );			cbData->isPaused = true;			cbData->startPauseTime = TickCount();			DimRectangle( cbData->fitRect, true, true );			DrawPictureIDCentered( kGamePausedPict, cbData->fitRect );			FadeMusicOut();			cbData->timerTickDiff = TickCount() - cbData->timerTicks;						// here's what's cool: I'm a gonna allow switchouts			MRAllowSwitches( true );		} 				else if ( keyUp && cbData->isPaused ) {			// no longer permit switchouts			MRAllowSwitches( false );						Rect r = RectFromPictureID( kGamePausedPict );						CenterRect( &r, &cbData->fitRect );						PlaySoundID( kUnpauseSnd );			cbData->isPaused = false;			cbData->totalPauseTime += (TickCount() - cbData->startPauseTime);			DrawLevelRoom( cbData );			cbData->lastInfotronCount = -1;			cbData->lastRedDiskCount = -1;			cbData->ldHours = cbData->ldMins = cbData->ldSecs = -1;			DrawLevelStatistics( cbData );			FadeMusicIn();						SetPort( cbData->mainWind );			ForeColor(blackColor);			FillRect(&r, &qd.black);						// make sure keys are cleared!			cbData->specialKeyDown = false;			cbData->numKeys = 0;			cbData->theKeys[0] = cbData->theKeys[1] = cbData->theKeys[2] = cbData->theKeys[3] = 0;					// for timer			cbData->timerTicks = TickCount() - cbData->timerTickDiff;		}				return false; 	}		// can go no further in paused mode	if ( cbData->isPaused )		return false;			if ( cbData->oliverSprite == NULL ) {		if ( cbData->deathSprite ) {			long startTick = TickCount();						if ( keyUp )				return false;							if ( key == 'y' || key == 'Y' || key == (char)13 || key == (char)3) {					MRRestoreSndAlias();					PlaySoundID( kTickSnd );					MRTerrainAlias();					MRSetSndAlias();					MRRestoreResFile();										CopyOffToOffRect( cbData->deathSprite->frameArray[1]->framePort, true, 									 (GWorldPtr)cbData->mainWind, false, cbData->yesGfxRect, cbData->yesRect );									 					while (TickCount()-startTick < 7);					CopyOffToOffRect( cbData->deathSprite->frameArray[0]->framePort, true, 									 (GWorldPtr)cbData->mainWind, false, cbData->yesGfxRect, cbData->yesRect );					MRRestoreSndAlias();					PlaySoundID( kClickSnd );					MRTerrainAlias();					MRSetSndAlias();					MRRestoreResFile();						cbData->playAgain = true;					cbData->doneWithLevel = true;					return true;			} else if ( key == 'n' || key == 'N' ) {					MRRestoreSndAlias();					PlaySoundID( kTickSnd );					MRTerrainAlias();					MRSetSndAlias();					MRRestoreResFile();										CopyOffToOffRect( cbData->deathSprite->frameArray[1]->framePort, true, 									 (GWorldPtr)cbData->mainWind, false, cbData->noGfxRect, cbData->noRect );									 					while (TickCount()-startTick < 7);										CopyOffToOffRect( cbData->deathSprite->frameArray[0]->framePort, true, 									 (GWorldPtr)cbData->mainWind, false, cbData->noGfxRect, cbData->noRect );					MRRestoreSndAlias();					PlaySoundID( kClickSnd );					MRTerrainAlias();					MRSetSndAlias();					MRRestoreResFile();										cbData->doneWithLevel = true;					return true;								}				}				return false;	}		// if they hit escape, it's time for oliver to die!	if ( key == thePrefs.suicideKey ) {		KillOliver( cbData->oliverSprite, false );		return false;	}		if ( key == thePrefs.specialKey ) {		cbData->specialKeyDown = (!keyUp);				if ( !cbData->specialKeyDown )			if ( cbData->oliverSprite ) {				MRSpriteTag theTag = (MRSpriteTag) cbData->oliverSprite->userData;				theTag->info.oliver.zappedBlankPiece = false;			}				return false;	}		// the debug-break-in key#ifdef DEBUG_INT_KEY	if ( key == '\'' ) {		int knowSomething = kLastZapInfotronTile;		SysBeep(5);	}#endif		// get the keykind.	if ( key == thePrefs.upKey )		newKey = kMoveUp;	else if ( key == thePrefs.downKey )		newKey = kMoveDown;	else if ( key == thePrefs.leftKey )		newKey = kMoveLeft;	else if ( key == thePrefs.rightKey )		newKey = kMoveRight;			// only update the presses if necessary.	if ( newKey ) {		if ( keyUp ) {			// user released key, so remove it from the list.			(cbData->numKeys)--;						if ( newKey == cbData->specialKeyRelease ) {				if ( cbData->oliverSprite ) {					MRSpriteTag theTag = (MRSpriteTag) cbData->oliverSprite->userData;					theTag->info.oliver.zappedBlankPiece = false;				}				cbData->specialKeyRelease = -1;			}						if ( cbData->numKeys < 0 ) {				cbData->numKeys = 0;			} else {				for ( n = 0; cbData->theKeys[n] != newKey; n++ );				while ( n < cbData->numKeys ) {					cbData->theKeys[n] = cbData->theKeys[n+1];					n++;				}				cbData->theKeys[cbData->numKeys] = kNoMove;					}		} else {			// user pressed the key, so add it into the key info list.			for ( n = cbData->numKeys; n>0; n-- )				cbData->theKeys[n] = cbData->theKeys[n-1];			cbData->theKeys[0] = newKey;			(cbData->numKeys)++;		}	}		return false;}void InitialFalls( LevelCBInfo cb ) {	short row, col;		for ( row = 0; row < cb->levSize.v; row++ )		for ( col = 0; col < cb->levSize.h; col++ )			if (cb->tiles[row][col] == kBlankTile)				DrawLevelTile( cb->sw, row, col, kBlankTile );}void MakeMovers( LevelCBInfo cb ) {	short row, col;	short tile;		for ( row = 0; row < cb->levSize.v; row++ )		for ( col = 0; col < cb->levSize.h; col++ ) {			tile = cb->tiles[row][col];			if ( tile == kQuarkTile )				MakeSprite_Quark( cb, row, col );			else if ( tile == kUpScissorTile )				MakeSprite_Scissor( cb, row, col, kMoverFacingUp );			else if ( tile == kRightScissorTile )				MakeSprite_Scissor( cb, row, col, kMoverFacingRight );			else if (tile == kDownScissorTile )				MakeSprite_Scissor( cb, row, col, kMoverFacingDown );			else if ( tile == kLeftScissorTile )				MakeSprite_Scissor( cb, row, col, kMoverFacingLeft );		}}void HandleAllChores( LevelCBInfo cb, MRQueue chores ) {	short handleCount;	short numToHandle = chores->qSize;	MRChore theChore;	Boolean shouldEnq;		for ( handleCount = 0; handleCount < numToHandle; handleCount++ ) {		// deq it		theChore = (MRChore) Deq( chores );				if ( theChore == NULL ) {			ErrorCheck((OSErr)-1, "GameLogic error: Null Chore deq'd", false);			return;		}				// process it		shouldEnq = (*((MRChoreProcessPtr)theChore->processProc)) ( theChore );				// put it back at the end of the queue		if ( shouldEnq )			Enq( chores, (void*) theChore );			else			DeallocChore( &theChore );	}	}Boolean Level_IdleBack( int modifiers, MRUData info ) {	LevelCBInfo cb = (LevelCBInfo) info;	long timeDiff;		KeepMusicGoing();		// I've decided that two bubbling olivers at once is	// (1) annoying, and (2) slow.	// BubbleOliver( cb->bubbleData );		// have we done the initial falls?	if ( !cb->doneInitialFalls ) {		InitialFalls( cb );		MakeMovers( cb );		cb->doneInitialFalls = true;	}		if ( cb->isPaused )		return false;			if ( cb->oliverSprite == NULL ) {		if ( cb->deathSprite == NULL && !cb->wonLevel )			MakeReplaySprite( cb );		else if ( cb->wonLevel )			cb->doneWithLevel = true;	}		if ( cb->deathSprite ) {		GrafPtr oldPort;		Point mouseLoc;				GetPort( &oldPort );		SetPort( cb->mainWind );		GetMouse( &mouseLoc );		if (PtInRect(mouseLoc, &cb->deathRect)) 			return false;	}		SWProcessScrollingSpriteWorld( cb->sw );	SWAnimateScrollingSpriteWorld( cb->sw );	if ( cb->sw->frameHasOccured )		HandleAllChores( cb, cb->chores );			// time handling	if ( cb->timer ) {		timeDiff = TickCount() - cb->timerTicks;		if ( timeDiff >= 60 ) {			// there has been a second elapsed.			timeDiff -= 60;			cb->timerTicks = TickCount() - timeDiff;						cb->secs -= 1;			if ( cb->secs < 0 && (cb->mins||cb->hours) ) {				cb->secs = 59;				cb->mins -= 1;								if ( cb->mins < 0 ) {					cb->mins = 59;					cb->hours -= 1;				}			} else if ( cb->secs < 0 ) {				cb->secs = 0;				KillOliver( cb->oliverSprite, false );				cb->timer = false;			}						if ( cb->secs <= 10  && cb->mins == 0 && cb->hours == 0 ) {				MRMainResFile();				MRSetSndAlias();				MRRestoreResFile();								PlaySoundIDProx(kNoMoreTimeSnd, (short)((double)cb->secs*(double)(15.0/10.0)));								MRTerrainAlias();				MRSetSndAlias();				MRRestoreResFile();			}						DrawTimeRemaining( cb );		}	}		return cb->doneWithLevel;}void PrepareLevelLoop() {	MRClearCallbacks();	MRSetSleepTime(0);	MRAllowKeyUp();	MRSetClickCallback( Level_ClickBack );	MRSetKeyUpDownCallback( Level_KeyBack ); 	MRSetIdleCallback( Level_IdleBack );}void DrawLevelRoom( LevelCBInfo cb ) {	Rect	levelNameRect;	Rect		offRect;	GWorldPtr	miniOff;	GrafPtr		oldPort;		// remember where we parked	GetPort( &oldPort );	SetPort( cb->mainWind );		if ( cb->timer ) {		// set to the right resource file		MRMainResFile();		MRSetGfxAlias();		MRRestoreResFile();				// draw the stat bar		DrawPictureID( kGameStatMResPict, cb->statRect );				// reset gfx alias		MRRestoreGfxAlias();	} else {		DrawPictureID( kGameStatPict, cb->statRect );	}		// draw the level name	SetRect( &levelNameRect, 11, 73+4, 11+18, 73-4+198 );	OffsetRect( &levelNameRect, cb->statRect.left, cb->statRect.top );	MRLettering( cb->extraInfo.levelTitle, levelNameRect, kGreenLettering );	// draw those crazy mini-icons	SetRect( &offRect, 0, 0, 16*4, 16 );	(void)MacMakeGWorldDepth( offRect, 0, &miniOff );	DrawPictToWorld( miniOff, kInfoMiniPict );	SetRect( &offRect, 0, 0, 16, 16 );	OffsetRect( &offRect, cb->extraInfo.levelWorld * 16, 0 );	CopyOffToOffRect( miniOff, true, (GWorldPtr)cb->mainWind, false, offRect, cb->infoMiniRect );	DrawPictToWorld( miniOff, kRDMiniPict );	CopyOffToOffRect( miniOff, true, (GWorldPtr)cb->mainWind, false, offRect, cb->rdMiniRect );	DestroyGWorld( &miniOff );		// draw level statistics	DrawLevelStatistics( cb );		// flip back the clock	SetPort( oldPort );}void RLEDecompress( short* cFrom, short* cTo ) {	short 	fromIndex, toIndex;	short	count;	short	runLength;	short	runInt;		// prepare	fromIndex = toIndex = 0;		// decompress. incredibly simple, really.	while (cFrom[fromIndex] != kRLEEnd) {		if ( cFrom[fromIndex] == kRLEFlag ) {			runLength = cFrom[++fromIndex];			runInt = cFrom[++fromIndex];			fromIndex += 1;						for ( count = 0; count<runLength; count++ ) 				cTo[toIndex++] = runInt;		} else			cTo[toIndex++] = cFrom[fromIndex++];	}}void LoadLevelIndex( LevelCBInfo cb, int levelIndex ) {	Handle	levelResource;	short*	cph = (short*) DBG_NewPtrClear( sizeof( short ) * kMaxLevelSizeSquared );	short*	cpv = (short*) DBG_NewPtrClear( sizeof( short ) * kMaxLevelSizeSquared );	short*	ckind = (short*) DBG_NewPtrClear( sizeof( short ) * kMaxLevelSizeSquared );	short*	dph = (short*) DBG_NewPtrClear( sizeof( short ) * kMaxLevelSizeSquared );	short*	dpv = (short*) DBG_NewPtrClear( sizeof( short ) * kMaxLevelSizeSquared );	short*	dkind = (short*) DBG_NewPtrClear( sizeof( short ) * kMaxLevelSizeSquared );	Ptr		levelPtr;	short	x,y,count;		// grab the level resource	MRWorldResFile();	levelResource = Get1Resource( kLevelResType, kLevelBaseID + levelIndex );		MRRestoreResFile();		// secure it.	HLockHi( levelResource );		// get the ptr:	levelPtr = (Ptr) (*levelResource);		// reset extra level info	cb->extendedInfo = false;		// set the extra level information	BlockMove( levelPtr, (Ptr) &(cb->extraInfo), sizeof(OldExtraLevelInfo) );		// check to see if it contains extended level data...	if ( cb->extraInfo.reqInfo < 0 ) {		BlockMove( levelPtr, (Ptr)&(cb->extraInfo), sizeof(ExtraLevelInfo) );		cb->extendedInfo = true;		cb->extraInfo.reqInfo = cb->extraInfo.actualInfo;		cb->timer = true;		cb->hours = cb->extraInfo.hours;		cb->mins = cb->extraInfo.mins;		cb->secs = cb->extraInfo.secs;		levelPtr += sizeof(ExtraLevelInfo);	} else		// no it doesn't		levelPtr += sizeof(OldExtraLevelInfo);		// now grab the three compressed data arrays	BlockMove( levelPtr, (Ptr)cph, cb->extraInfo.phCount * sizeof(short) );	levelPtr += cb->extraInfo.phCount * sizeof(short);	BlockMove( levelPtr, (Ptr)cpv, cb->extraInfo.pvCount * sizeof(short) );	levelPtr += cb->extraInfo.pvCount * sizeof(short);	BlockMove( levelPtr, (Ptr)ckind, cb->extraInfo.kindCount * sizeof(short) );	levelPtr += cb->extraInfo.kindCount * sizeof(short);		// decompress them.	RLEDecompress( cph, dph );	RLEDecompress( cpv, dpv );	RLEDecompress( ckind, dkind );		// unflatten the data:	x = y = 0;	for ( count = 0; count < kMaxLevelSizeSquared; count++ ) {		cb->level[x][y].p.h = dph[count];		cb->level[x][y].p.v = dpv[count];		cb->level[x][y].kind = dkind[count];		x += 1;		if ( x >= kMaxLevelSize ) {			x = 0;			y += 1;		}	}		// no more need for resource.	HUnlock( levelResource );	ReleaseResource( levelResource );		// no need for the compression infos	DBG_DisposePtr( (Ptr) cph );	DBG_DisposePtr( (Ptr) cpv );	DBG_DisposePtr( (Ptr) ckind );	DBG_DisposePtr( (Ptr) dph );	DBG_DisposePtr( (Ptr) dpv );	DBG_DisposePtr( (Ptr) dkind );		// convert the strings inside the extra info	P2CStr( (StringPtr) cb->extraInfo.levelTitle );	P2CStr( (StringPtr) cb->extraInfo.levelInfo );}Point GetLevelSize( LevelCBInfo cb ) {	// basically scan the top row until you find the	// top-rt border piece, then go down until you hit	// the bot-rt piece.	// If no border is found, kMaxLevelSize is returned	Point pSize;		pSize.h = kMaxLevelSize;	pSize.v = kMaxLevelSize;		if (( cb->level[0][0].p.v == 3 ) && ( cb->level[0][0].p.h == 0 )) {		// check across		pSize.h = 0;		while ( (cb->level[pSize.h][0].p.v != 3) ||				(cb->level[pSize.h][0].p.h != 2) )			(pSize.h)++;				// check down		pSize.v = 0;		while ( (cb->level[pSize.h][pSize.v].p.v != 3) ||				(cb->level[pSize.h][pSize.v].p.h != 7) )			(pSize.v)++;					(pSize.h)++;		(pSize.v)++;	}		cb->levSize = pSize;		return pSize;}void InitialTileAction( LevelCBInfo cb, short row, short col, short tileID ) {	switch ( tileID ) {		case kOliverTile:			cb->oliverStartLoc.h = col;			cb->oliverStartLoc.v = row;			cb->tiles[row][col] = kBlankTile;			break;					case kBugTile:			{				AllocChore_Bug( cb, col, row );				cb->tiles[row][col] = kCircuitTile;			}			break;					default:			break;	}}void MakeLevelTileGrid( LevelCBInfo cb ) {	Point p;	short tileID;	int row,col;		Point levSize = GetLevelSize(cb);		// set up the (gasp!) actual tile map, as fast as possible.	for ( row = 0; row < levSize.v; row++ ) {		for ( col = 0; col < levSize.h; col++ ) {			p = (cb->level[col][row]).p;			tileID = (p.v*kLevelTilesWide)+p.h;			cb->tiles[row][col] = tileID;						// do stuff with particular tiles here.			InitialTileAction( cb, row, col, tileID );		}	}}void Scroll_LevWorldMove( SpriteWorldPtr theWorld,					   SpritePtr followSprite ) {	LevelCBInfo cbData = (LevelCBInfo) followSprite;	MRSpriteTag	theTag = NULL;	short midTop, midLeft;	MRPrefs	mp = GetCurrentPrefs();		// don't go anywhere if oliver is dead.	if ( cbData->oliverSprite == NULL ) {		cbData->sw->horizScrollDelta = 0;		cbData->sw->vertScrollDelta = 0;		return;	}		// get the tag	theTag = (MRSpriteTag) cbData->oliverSprite->userData;		// set the follow sprite	followSprite = cbData->oliverSprite;		// calc mid points	midTop = cbData->midRect.top + cbData->sw->visScrollRect.top;	midLeft = cbData->midRect.left + cbData->sw->visScrollRect.left;		cbData->sw->horizScrollDelta = 			(kSpriteMoveDelta *				(followSprite->destFrameRect.left - midLeft) ) / kSpriteMoveDistance;	cbData->sw->vertScrollDelta = 			(kSpriteMoveDelta *				(followSprite->destFrameRect.top - midTop) ) / kSpriteMoveDistance;	// interlaced mode can only move every-other pixel in the vert firection	// the >> 1 << 1 just gets rid of the rightmost bit.	if ( mp.interlacedMode )		cbData->sw->vertScrollDelta = (cbData->sw->vertScrollDelta) >> 1 << 1;		}void Tile_ChangeProc( SpriteWorldPtr theWorld ) {	LevelCBInfo	cb = (LevelCBInfo) theWorld->userData;	short curImage;		if ( TickCount() - cb->lastTileAnimTicks > kSpriteFrameTicks ) {		// animate non-moving infotrons		curImage = theWorld->curTileImage[kInfotronTile];		curImage++;		if ( curImage > kLastInfotronTile )			curImage = kFirstInfotronTile;		SWChangeTileImage( theWorld, kInfotronTile, curImage );				// animate the terminals		curImage = theWorld->curTileImage[kTerminalTile];		curImage++;		if ( curImage > kLastTerminalTile )			curImage = kFirstTerminalTile;		SWChangeTileImage( theWorld, kTerminalTile, curImage );				cb->lastTileAnimTicks = TickCount();	}	}void MakeLevelSWorld( LevelCBInfo cbData ) {	Rect offRect = cbData->levelRect;	OSErr err;	Point	levSize;		// offscreen rect is always at position zero, and also	// has size evenly divisible into the tiles.	ZeroRect( &offRect );	if ((offRect.right/kLevelItemSize)*kLevelItemSize != offRect.right)		offRect.right = (offRect.right/kLevelItemSize)*kLevelItemSize + kLevelItemSize;	if ((offRect.bottom/kLevelItemSize)*kLevelItemSize != offRect.bottom)		offRect.bottom = (offRect.bottom/kLevelItemSize)*kLevelItemSize + kLevelItemSize;	cbData->offRect = offRect;		// create a scrolling sprite world	err = SWCreateSpriteWorldFromWindow( &cbData->sw,										 (CWindowPtr) cbData->mainWind,										 &cbData->levelRect,										 &cbData->offRect );	ErrorCheck( err, "SWCreateSpriteWorldFromWindow", true );		// set the userData	cbData->sw->userData = (long) cbData;										 	// setup the tiling code.	err = SWInitTiling( cbData->sw,						kLevelItemSize,						kLevelItemSize,						kMaxLevelTiles );	ErrorCheck( err, "SWInitTiling", true );		// how big is that level, anyway?	levSize = GetLevelSize( cbData );		// allocate space for a (big!) tile map.	err = SWCreateTileMap( cbData->sw,						   &cbData->tiles,						   levSize.v,						   levSize.h );	ErrorCheck( err, "SWCreateTileMap", true );		// DKP HERE		// load in the tile graphics	MRTerrainAlias();		// A	err = SWLoadTilesFromPictResource( cbData->sw,									   kCircuitTile,									   kOliverTile,									   kTilesAPict,									   0,									   kNoMask,									   0,									   0 );	//AddTileBound( cbData, kCircuitTile, kOliverTile, 0 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// B - ports with masks	err = SWLoadTilesFromPictResource( cbData->sw,									   kLeftPortTile,									   kFourWayPortTile,									   kTilesBPict,									   0,									   kSolidMask,									   0,									   0 );	//AddTileBound( cbData, kLeftPortTile, kFourWayPortTile, 0 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// C	err = SWLoadTilesFromPictResource( cbData->sw,									   kZonkTile,									   kInfotronTile,									   kTilesCPict,									   0,									   kNoMask,									   0,									   0 );	//AddTileBound( cbData, kZonkTile, kInfotronTile, 0 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// Load in only if you're HAPPY.	if ( cbData->extraInfo.levelWorld != kInfotronTerrain ) {		// D		err = SWLoadTilesFromPictResource( cbData->sw,										   kQuarkTile,										   kPhantomTile, //kEmptyTile9										   kTilesDPict,										   0,										   kNoMask,										   0,										   0 );		//AddTileBound( cbData, kQuarkTile, kEmptyTile4, 0 );		ErrorCheck( err, "SWLoadTilesFromPictResource", true );	} else {		// special pieces for the infotron terrain: lasers.		err = SWLoadTilesFromPictResource( cbData->sw,										   kQuarkTile,										   kEmptyTile9,										   kTilesDPict,										   0,										   kNoMask,										   0,										   0 );		//AddTileBound( cbData, kQuarkTile, kEmptyTile4, 0 );		ErrorCheck( err, "SWLoadTilesFromPictResource", true );			err = SWLoadTilesFromPictResource( cbData->sw,										   kBlankLaserPiece,										   kBLTRLaserBackMirrorLightPiece,										   kLaserPiecesPict,										   0,										   kNoMask,										   0,										   1 );		ErrorCheck( err, "SWLoadTilesFromPictResource", true );	}		// Infotron animation	err = SWLoadTilesFromPictResource( cbData->sw,									   kFirstInfotronTile,									   kLastInfotronTile,									   kInfotronSpritePict,									   0,									   kNoMask,									   0,									   1 );	//AddTileBound( cbData, kFirstInfotronTile, kLastInfotronTile, 1 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// Terminal animation	err = SWLoadTilesFromPictResource( cbData->sw,									   kFirstTerminalTile,									   kLastTerminalTile,									   kTerminalSpritePict,									   0,									   kNoMask,									   0,									   1 );	//AddTileBound( cbData, kFirstTerminalTile, kLastTerminalTile, 1 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );		// Bug-zap animation	err = SWLoadTilesFromPictResource( cbData->sw,									   kFirstBugTile,									   kLastBugTile,									   kBugSpritePict,									   0,									   kNoMask,									   0,									   1 );	//AddTileBound( cbData, kFirstBugTile, kLastBugTile, 1 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// Explosion animation	err = SWLoadTilesFromPictResource( cbData->sw,									   kFirstExplTile,									   kLastExplTile,									   kExplosionPict,									   0,									   kNoMask,									   0,									   1 );	//AddTileBound( cbData, kFirstExplTile, kLastExplTile, 1 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// Exit openining animation	err = SWLoadTilesFromPictResource( cbData->sw,									   kFirstExitTile,									   kLastExitTile,									   kExitPict,									   0,									   kNoMask,									   0,									   1 );	//AddTileBound( cbData, kFirstExitTile, kLastExitTile, 1 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// Piece-zapping animations	err = SWLoadTilesFromPictResource( cbData->sw,									   kFirstZapRedDiskTile,									   kLastZapInfotronTile,									   kZapsPict,									   0,									   kNoMask,									   0,									   1 );	//AddTileBound( cbData, kFirstZapRedDiskTile, kLastZapInfotronTile, 1 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// RD-Blink animations	err = SWLoadTilesFromPictResource( cbData->sw,									   kFirstRDBlinkTile,									   kLastRDBlinkTile,									   kRedDiskBlinkPict,									   0,									   kNoMask,									   0,									   1 );	//AddTileBound( cbData, kFirstRDBlinkTile, kLastRDBlinkTile, 1 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// zonk tiles	err = SWLoadTilesFromPictResource( cbData->sw,									   kFirstZonkTile,									   kLastZonkTile,									   kZonkPict,									   0,									   kNoMask,									   0,									   1 );	//AddTileBound( cbData, kFirstZonkTile, kLastZonkTile, 1 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// upZonk tiles	err = SWLoadTilesFromPictResource( cbData->sw,									   kFirstUpZonkTile,									   kLastUpZonkTile,									   kUpZonkPict,									   0,									   kNoMask,									   0,									   1 );	//AddTileBound( cbData, kFirstUpZonkTile, kLastUpZonkTile, 1 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// quark tiles	err = SWLoadTilesFromPictResource( cbData->sw,									   kFirstQuarkTile,									   kLastQuarkTile,									   kQuarkSpritePict,									   0,									   kNoMask,									   0,									   1 );	//AddTileBound( cbData, kFirstUpZonkTile, kLastUpZonkTile, 1 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	// scissor tiles	err = SWLoadTilesFromPictResource( cbData->sw,									   kFirstUpScissorTile,									   kUpLeftScissorTile,									   kScissorSpritePict,									   0,									   kNoMask,									   0,									   1 );	//AddTileBound( cbData, kFirstUpZonkTile, kLastUpZonkTile, 1 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	MRRestoreResFile();		// Set up the actual tile data:	MakeLevelTileGrid( cbData );			// that's all folks!}void MakeReplaySprite( LevelCBInfo cbData ) {	OSErr err;	MRPlayerData	pd = GetCurrentPlayer();	MRPrefs			mp = GetCurrentPrefs();	Rect			funkRect;		// grab the image.	MRGeneralResFile();	err = SWCreateSpriteFromPictResource( cbData->sw,					  					  &cbData->deathSprite,										  NULL,										  kDeathPict,										  kDeathPict,										  2,										  kNoMask );	ErrorCheck( err, "SWCreateSpriteFromPictResource", true );		SetPort( cbData->mainWind );	DrawPictureIDCentered( kDeathPict, cbData->levelRect );	cbData->deathRect = RectFromPictureID( kDeathPict );	MRRestoreResFile();		// Set the position, but be careful about the position of the scrolling world!	funkRect = cbData->levelRect;	ZeroRect( &funkRect );	SWSetSpriteLocation( cbData->deathSprite, ((funkRect.right / 2)-100)+cbData->sw->visScrollRect.left, 											  ((funkRect.bottom/2)-73)+cbData->sw->visScrollRect.top );			SWSetSpriteMoveDelta( cbData->deathSprite, 0, 0 );		// set up the rectangles:	SetRect( &cbData->noRect, 26, 111, 26+66, 111+20 );	SetRect( &cbData->yesRect, 108, 111, 108+66, 111+20 );	cbData->yesGfxRect = cbData->yesRect;	cbData->noGfxRect = cbData->noRect;	OffsetRect( &cbData->noRect, ((funkRect.right / 2)-100), ((funkRect.bottom/2)-73) );	OffsetRect( &cbData->yesRect, ((funkRect.right / 2)-100), ((funkRect.bottom/2)-73) );	OffsetRect( &cbData->noRect, cbData->levelRect.left, cbData->levelRect.top );	OffsetRect( &cbData->yesRect, cbData->levelRect.left, cbData->levelRect.top );	OffsetRect( &cbData->deathRect, ((funkRect.right / 2)-100), ((funkRect.bottom/2)-73) );	OffsetRect( &cbData->deathRect, cbData->levelRect.left, cbData->levelRect.top );		// Set the sprite drawproc.	if ( mp.interlacedMode )		SWSetSpriteDrawProc( cbData->deathSprite, SPRITEDRAWPROCINT() );	else		SWSetSpriteDrawProc( cbData->deathSprite, SPRITEDRAWPROC() );		// the frame-change proc:	SWSetSpriteFrameAdvance( cbData->deathSprite, 0 );		// push it under the ports	SWSetSpriteUnderTiles( cbData->deathSprite, false );		// lock the sprite.	SWLockSprite( cbData->deathSprite );	// add the sprite.	SWAddSprite( cbData->againLayer, cbData->deathSprite );		// show the cursor	ShowCursor();}void SetupLevelAnimation( LevelCBInfo cbData ) {	Rect moveBounds;	MRPrefs	mp = GetCurrentPrefs();	Point	levSize = GetLevelSize( cbData );		// set up the rectangle used for smooth following	cbData->midRect = cbData->oliverSprite->curFrameP->frameRect;	CenterRect( &cbData->midRect, &cbData->sw->backRect );		// speed info	SWSetSpriteWorldMaxFPS( cbData->sw, kMaxLevelFPS );	SWSyncSpriteWorldToVBL( cbData->sw, false );		// move bounds are the size of the tile map	SetRect( &moveBounds, 0, 0, levSize.h * kLevelItemSize,								levSize.v * kLevelItemSize );	SWSetScrollingWorldMoveBounds( cbData->sw, &moveBounds );	SWSetScrollingWorldMoveProc( cbData->sw, Scroll_LevWorldMove,								 (SpritePtr) cbData );		// Could set up a tile change proc here. 	SWSetTileChangeProc( cbData->sw, Tile_ChangeProc );	SWChangeTileImage( cbData->sw, kInfotronTile, kFirstInfotronTile );	SWChangeTileImage( cbData->sw, kTerminalTile, kFirstTerminalTile );		// woo-hoo	SetPort( cbData->mainWind );		// Put the scrolled world in starting position.	SWMoveVisScrollRect( cbData->sw,						 cbData->oliverSprite->destFrameRect.left -						 		cbData->sw->backRect.right / 2,						 cbData->oliverSprite->destFrameRect.top -						 		cbData->sw->backRect.bottom / 2 );		// Set the drawing routines for the world.	if ( mp.interlacedMode ) {		SWSetSpriteWorldOffscreenDrawProc( cbData->sw, OFFDRAWPROCINT() );		SWSetSpriteWorldScreenDrawProc( cbData->sw, ONDRAWPROCINT() );		SWSetTileMaskDrawProc( cbData->sw, TILEDRAWPROCINT() );	} else {		SWSetSpriteWorldOffscreenDrawProc( cbData->sw, OFFDRAWPROC() );		SWSetSpriteWorldScreenDrawProc( cbData->sw, ONDRAWPROC() );		SWSetTileMaskDrawProc( cbData->sw, TILEDRAWPROC() );	}		// set up simple stuff!	ForeColor( blackColor );	BackColor( whiteColor );		// lock! (Again!)	SWLockSpriteWorld( cbData->sw );	// draw!	SWDrawTilesInBackground( cbData->sw );	SWUpdateScrollingSpriteWorld( cbData->sw, true );}void InfoWorld_PhaseTerm( LevelCBInfo cb ) {	// check for phase data if necessary.	if ( cb->extraInfo.levelWorld == kInfotronTerrain ) {		Point levSize = GetLevelSize( cb );		short lv, lh;				cb->phase = (PhaseInfo*) DBG_NewPtrClear(sizeof(PhaseInfo));				// scan level and find phase hardware, if it exists		for ( lv = 0; lv < levSize.v; lv++ )			for ( lh = 0; lh < levSize.h; lh++ ) 				if ( cb->tiles[lv][lh] == kEmptyPhaseTile ||					 cb->tiles[lv][lh] == kFullPhaseTile )					cb->phase->phaseCount += 1;				// alloc and do it, if necessary		if ( cb->phase->phaseCount ) {			short cnt = 0;						cb->phase->phaseState = (short*) DBG_NewPtrClear(sizeof(short)*cb->phase->phaseCount);			cb->phase->phaseLoc = (Point*) DBG_NewPtrClear(sizeof(Point)*cb->phase->phaseCount);					for ( lv = 0; lv < levSize.v; lv++ )				for ( lh = 0; lh < levSize.h; lh++ ) {									if ( cb->tiles[lv][lh] == kEmptyPhaseTile ) {						cb->tiles[lv][lh] = kBlankTile;						cb->phase->phaseState[cnt] = kPhasedOut;						cb->phase->phaseLoc[cnt].h = lh;						cb->phase->phaseLoc[cnt].v = lv;												cnt += 1;						} else if ( cb->tiles[lv][lh] == kFullPhaseTile ) {						cb->phase->phaseState[cnt] = kPhasedIn;						cb->phase->phaseLoc[cnt].h = lh;						cb->phase->phaseLoc[cnt].v = lv;						cnt += 1;					}								}		}			}}LevelCBInfo MakeLevelCBData( WindowPtr wind, int levelIndex ) {	LevelCBInfo cb = (LevelCBInfo) DBG_NewPtrClear( sizeof ( struct LevelCBInfoStruct ) );	MRPrefs		mp = GetCurrentPrefs();	Rect		bubbleRect;		// setup basic information	cb->mainWind = wind;	SetRect( &cb->fitRect, 0, 0, 640, 480 );	CenterRect( &cb->fitRect, &wind->portRect );	cb->specialKeyRelease = -1;	cb->statRect = RectFromPictureID( kGameStatPict );	cb->levelRect = cb->fitRect;	cb->levelRect.right -= cb->statRect.right;	OffsetRect( &cb->statRect, cb->fitRect.right - cb->statRect.right,							   cb->fitRect.top );	InsetRect( &cb->levelRect, mp.screenSize, mp.screenSize );		// roll direction	cb->nextRollDirection = -1;		// the bubble information	SetRect( &bubbleRect, 0, 0, 32, 32 );	OffsetRect( &bubbleRect, 4, 4 );	OffsetRect( &bubbleRect, cb->statRect.left, cb->statRect.top );	SetPort( wind );	cb->bubbleData = MakeNewBubble( bubbleRect );		// create the chores queue	cb->chores = MakeQueue();		// load the actual level & extraInfo	LoadLevelIndex( cb, levelIndex );		// init the level stats	cb->infotronCount = cb->extraInfo.reqInfo;	cb->redDiskCount = 0;	cb->lastInfotronCount = -1;	cb->lastRedDiskCount = -1;		// set the rectangles for stat info	SetRect( &cb->infoMiniRect, 4, 324, 4+16, 324+16 );	OffsetRect( &cb->infoMiniRect, cb->statRect.left, cb->statRect.top );	cb->infoCountRect = cb->infoMiniRect;	OffsetRect( &cb->infoCountRect, 16, 0 );	cb->rdMiniRect = cb->infoMiniRect;	OffsetRect( &cb->rdMiniRect, 0, 40 );	cb->rdCountRect = cb->infoCountRect;	OffsetRect( &cb->rdCountRect, 0, 40 );		// and for the timer info	SetRect( &cb->hoursBox, 5, 428, 10, 440 );	SetRect( &cb->minsBox, 12, 428, 22, 440 );	SetRect( &cb->secsBox, 24, 428, 34, 440 );	OffsetRect( &cb->hoursBox, cb->statRect.left, cb->statRect.top );	OffsetRect( &cb->minsBox, cb->statRect.left, cb->statRect.top );	OffsetRect( &cb->secsBox, cb->statRect.left, cb->statRect.top );	cb->ldHours = -1;	cb->ldMins = -1;	cb->ldSecs = -1;		// set up some stuff	MRSetTerrainAlias( cb->extraInfo.levelWorld );	MRTerrainAlias();	MRSetSndAlias();	MRRestoreResFile();		// create the sprite world stuff	MakeLevelSWorld( cb );		// handle phase hardware.	InfoWorld_PhaseTerm( cb );		MakeSprite_Oliver( cb );	SetupLevelAnimation( cb );	cb->lastPressTime = TickCount();		return cb;}void RemoveRemainingSpriteTags( LevelCBInfo cb ) {	SpritePtr theSprite;	SpritePtr oldSprite = NULL;		while ( (theSprite = SWGetNextSprite( cb->sLayer, oldSprite )) != NULL ) {		// must kill the sprite tag		DBG_DisposePtr( (Ptr) theSprite->userData );			oldSprite = theSprite;	}}void DestroyLevelCBData( LevelCBInfo *cb ) {	MRChore		theElement;		// don't need dem sprites	RemoveRemainingSpriteTags( *cb );		// the spriteworld	if ( ((*cb)->sw) )		SWDisposeSpriteWorld( ((*cb)->sw) );	// the chores queue's contents	while (!((*cb)->chores)->qEmpty) {		theElement = (MRChore) Deq( ((*cb)->chores) );		DeallocChore( &theElement );	}		// the chores queue itself	KillQueue( &((*cb)->chores) );		// the bubblely oliver in the top right	KillBubble( &((*cb)->bubbleData) );		// the phase info	if ( (*cb)->phase ) {		if ( (*cb)->phase->phaseCount ) {			DBG_DisposePtr( (Ptr)((*cb)->phase->phaseLoc) );			DBG_DisposePtr( (Ptr)((*cb)->phase->phaseState) );		}		DBG_DisposePtr( (Ptr)((*cb)->phase) );	}		// the actual info.	DBG_DisposePtr( (Ptr)(*cb) );		*cb = NULL;}int RunGameLevel( WindowPtr wind, int levelIndex ) {	LevelCBInfo		cb = NULL;	OSErr			err;	long			totalPlayTime;	MRPlayerData	curPlayer;	Boolean			playAgain = false;		// For debugging purposes, fade in here:	// FadeIn();	// Before doing anything, check to make sure that the level	// that the user wants to play actually exists. Won't be a problem	// in the actual completed version of the game, but for now...	if (NoSuchLevel(levelIndex)) {		SysBeep(5);		FadeOutImmediate();		return kBackToMapReturn;	}		// woohoo, prepare drawprocs	PlayDrawProcsInit();		// Prepare to use spriteworld	err = SWEnterSpriteWorld();	ErrorCheck( err, "SWEnterSpriteWorld", true );	// no cursor during gameplay!		HideCursor();		// make the callback info	cb = MakeLevelCBData( wind, levelIndex );	if (cb==NULL)		return kPlayErrorReturn;		// Work with the MRLoop unit	PrepareLevelLoop();		// Draw the levelroom	DrawLevelRoom( cb );		// Fade in here if you're not debugging	FadeIn();		// Also, start the game play music playing.	PlayMusic( kGamePlayMusic, true );		// get time info	cb->startPlayTime = TickCount();	cb->timerTicks = TickCount();		// run the level	MREventLoop( (MRUData) cb );		// and calculate the total time taken	totalPlayTime = (cb->stopPlayTime - cb->startPlayTime) - (cb->totalPauseTime);		// now credit that time to the player	curPlayer = GetCurrentPlayer();	AddTicksToPlayer( curPlayer, totalPlayTime );		// fix key-related info	MRRestoreKeyUp();		// Fade the music out, then stop it.	FadeMusicOut();	StopMusic();	// no cursor!	HideCursor();			// Neat effect:	WipeWindowFX( wind );		// if they didn't win the level, you've got to move 'em back	// to where they were on the map. If they _did_ win the level,	// you've got to change the player data to reflect it.	{		MRPlayerData 	pd = GetCurrentPlayer();				if (cb->wonLevel) 			pd->passedLevel[levelIndex-1] = true;		//else		//	pd->mapLocation = pd->previousLocation;	}		// check if we should play again	playAgain = cb->playAgain;		// kill the callback data	DestroyLevelCBData( &cb );		// thanks for everything, SW!	SWExitSpriteWorld();		// fade the screen out	FadeOutImmediate();		ShowCursor();		// erase the window:	FillRect( &wind->portRect, &qd.black );		// release sound-related memory	FlushAllSounds();		// fix up them aliases!	MRRestoreGfxAlias();	MRRestoreSndAlias();		if (playAgain)		return kPlayAgainReturn;	else		return kBackToMapReturn;}
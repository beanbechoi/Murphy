// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRMap.c// Auth: Dave Peck// Date: 7/13/97// Desc: Code file for map routines// ----------------------------------------------------------------// Includes// ----------------------------------------------------------------#include "MRMap.h" #include "SWGameUtils.h"#include "MRError.h"#include "MRPrefs.h"#include <string.h>#include <stdio.h>// ----------------------------------------------------------------// Constants// ----------------------------------------------------------------#define kLevInfoUpSnd		128#define kLevInfoDownSnd		129#define kMapSwitchSnd		130#define kUsableTilesWide	9#define kOliverStartTile	18#define kInfoDelayTicks		15#define kMapStatPict		146#define kMapStatHilitePict	147#define kMapTilesPict		148#define kMapSpritesPict		149#define kMapMasksPict		150#define kInfoPict			163#define kInfoBufferSpace	10#define kStartTileLoad		0#define kEndTileLoad		377#define kNumMapTiles		378#define kMaxMapFPS			30#define kSyncMapToVBL		false#define kNoMove				0#define kMoveUp				1#define kMoveDown			2#define kMoveLeft			3#define kMoveRight			4#define kSpriteMoveDelta	4#define kSpriteMoveDistance 100#define kSpriteFrameDelay   30#define kSpriteFrameMilli	500#define kPassablePiece		1#define kSwitchPiece		2#define kLevelPiece			3#define kPassedLevelPiece	4#define kNoPassPiece		5#define kPassedLevelDelay	90#define kWaveTicks			4// constants for junk#define kOceanTick			12#define kOcean2Tick			12#define kOcean3Tick			12#define kOcean4Tick			12#define kLevelTick			10#define kWhirlTick			17#define kMachineTick		15#define kThingTick			15#define kOceanInitTile		0#define kOceanStartTile		238#define kOcean2Tile			239#define kOcean3Tile			240#define kOcean4Tile			241#define kOceanEndTile		241#define kLev1InitTile		1#define kLev1EndTile		8#define kLev2InitTile		19#define kLev2EndTile		26#define kLev3InitTile		37#define kLev3EndTile		44#define kLev4InitTile		55#define kLev4EndTile		62#define kLev5InitTile		73#define kLev5EndTile		80#define kLev6InitTile		91#define kLev6EndTile		98#define kWhirlInitTile		256#define kWhirlEndTile		259#define kThing1InitTile		168#define kThing1EndTile		170#define kThing2InitTile		186#define kThing2EndTile		188#define kMachineInitTile	288#define kMachineEndTile		293// constant from Kubla, another software project of mine.#define NODE_TEXT_LENGTH	256// ----------------------------------------------------------------// Data Structures// ----------------------------------------------------------------// ----------------------------------------------------------------// Global Data// ----------------------------------------------------------------DrawProcPtr MOFFDRAWPROC, MONDRAWPROC, MTILEDRAWPROC, MSPRITEDRAWPROC, MPLAYDRAWPROC;DrawProcPtr MOFFDRAWPROCINT, MONDRAWPROCINT, MTILEDRAWPROCINT, MSPRITEDRAWPROCINT, MPLAYDRAWPROCINT;// ----------------------------------------------------------------// Function Prototypes// ----------------------------------------------------------------void DrawMapRoom( MapCBInfo cbData );void LoadMapWorld( MapCBInfo cbData );int PieceKind( MapCBInfo cbData, Point p );Point PointFromTile( short theTile );void MakeInfoSprite( MapCBInfo cbData );// ----------------------------------------------------------------// Functions// ----------------------------------------------------------------Rect FitRectFromWind( WindowPtr wind ) {	Rect retRect;	Rect fitRect;		SetRect( &fitRect, 0, 0, 640, 480 );		retRect = wind->portRect;	ZeroRect( &retRect );		CenterRect( &fitRect, &retRect );		return fitRect;}void SetUpTileData( MapCBInfo cbData ) {	Point p, tp;	short tileID;	int row,col;			// set up the (gasp!) actual tile map, as fast as possible.	for ( row = 0; row < kMaxWorldSize; row++ ) {		for ( col = 0; col < kMaxWorldSize; col++ ) {			p = (cbData->theWorld[col][row]).p;			tileID = (p.v*kTilesWide)+p.h;			cbData->mapTiles[row][col] = tileID;			if (tileID==kOliverStartTile) {				cbData->spritePt.h = col;				cbData->spritePt.v = row;				tp = (cbData->theWorld[col][row]).trigP;				cbData->mapTiles[row][col] = (tp.v*kTilesWide)+tp.h;			}		}	}}void Tile_MapChangeProc( SpriteWorldPtr theWorld ) {	MapCBInfo	cb = (MapCBInfo) theWorld->userData;	short curImage, ctx, cty, ctv;	long curTick = TickCount();		// grab tile images for each of the ocean tiles, but have 'em go slightly 	// different speeds...	/*if ( curTick - cb->lastWaveTick > kWaveTicks ) {		for ( cty = 9; cty < 18; cty++ ) {			ctv = (cb->waveLineUpdated*18)+cty;			curImage = theWorld->curTileImage[ctv];			curImage += 126;			if ( curImage > 377 )				curImage = ctv;						SWChangeTileImage( theWorld, ctv, curImage );		}		cb->waveLineUpdated += 1;		if ( cb->waveLineUpdated > 6 )			cb->waveLineUpdated = 0;		cb->lastWaveTick = TickCount();	}*/		if ( curTick - cb->lastOceanTick > kOceanTick ) {		curImage = theWorld->curTileImage[kOceanStartTile];		curImage += 1;		if ( curImage > kOceanEndTile )			curImage = kOceanStartTile;		SWChangeTileImage( theWorld, kOceanStartTile, curImage );		cb->lastOceanTick = TickCount();	}		if ( curTick - cb->lastOcean2Tick > kOcean2Tick ) {		curImage = theWorld->curTileImage[kOcean2Tile];		curImage += 1;		if ( curImage > kOceanEndTile )			curImage = kOceanStartTile;		SWChangeTileImage( theWorld, kOcean2Tile, curImage );		cb->lastOcean2Tick = TickCount();	}		if ( curTick - cb->lastOcean3Tick > kOcean3Tick ) {		curImage = theWorld->curTileImage[kOcean3Tile];		curImage += 1;		if ( curImage > kOceanEndTile )			curImage = kOceanStartTile;		SWChangeTileImage( theWorld, kOcean3Tile, curImage );		cb->lastOcean3Tick = TickCount();	}	if ( curTick - cb->lastOcean4Tick > kOcean4Tick ) {		curImage = theWorld->curTileImage[kOcean4Tile];		curImage += 1;		if ( curImage > kOceanEndTile )			curImage = kOceanStartTile;		SWChangeTileImage( theWorld, kOcean4Tile, curImage );		cb->lastOcean4Tick = TickCount();	}	if ( curTick - cb->lastLevelTick > kLevelTick ) {		curImage = theWorld->curTileImage[kLev1InitTile];		curImage += 1;		if ( curImage > kLev1EndTile )			curImage = kLev1InitTile;		SWChangeTileImage( theWorld, kLev1InitTile, curImage );				curImage = theWorld->curTileImage[kLev2InitTile];		curImage += 1;		if ( curImage > kLev2EndTile )			curImage = kLev2InitTile;		SWChangeTileImage( theWorld, kLev2InitTile, curImage );		curImage = theWorld->curTileImage[kLev3InitTile];		curImage += 1;		if ( curImage > kLev3EndTile )			curImage = kLev3InitTile;		SWChangeTileImage( theWorld, kLev3InitTile, curImage );				curImage = theWorld->curTileImage[kLev4InitTile];		curImage += 1;		if ( curImage > kLev4EndTile )			curImage = kLev4InitTile;		SWChangeTileImage( theWorld, kLev4InitTile, curImage );				curImage = theWorld->curTileImage[kLev5InitTile];		curImage += 1;		if ( curImage > kLev5EndTile )			curImage = kLev5InitTile;		SWChangeTileImage( theWorld, kLev5InitTile, curImage );				curImage = theWorld->curTileImage[kLev6InitTile];		curImage += 1;		if ( curImage > kLev6EndTile )			curImage = kLev6InitTile;		SWChangeTileImage( theWorld, kLev6InitTile, curImage );				cb->lastLevelTick = TickCount();	}			if ( curTick - cb->lastWhirlTick > kWhirlTick ) {		curImage = theWorld->curTileImage[kWhirlInitTile];		curImage += 1;		if ( curImage > kWhirlEndTile )			curImage = kWhirlInitTile;		SWChangeTileImage( theWorld, kWhirlInitTile, curImage );								cb->lastWhirlTick = TickCount();	}			if ( curTick - cb->lastGrabTick > kThingTick ) {		if ( cb->doingGrab == 1 ) {			curImage = theWorld->curTileImage[kThing1InitTile];			curImage += 1;			if ( curImage > kThing1EndTile ) {				curImage = kThing1EndTile-1;				cb->doingGrab = 2;			}			SWChangeTileImage( theWorld, kThing1InitTile, curImage );					cb->lastGrabTick = TickCount();		} else if ( cb->doingGrab == 2 ) {			cb->doingGrab = 0;			SWChangeTileImage( theWorld, kThing1InitTile, kThing1InitTile );			cb->lastGrabTick = TickCount();		} else if ( GetRandom(0,1000) < 75 ) {			cb->doingGrab = 1;			cb->lastGrabTick = TickCount();		}	}		if ( curTick - cb->lastThingTick > kThingTick ) {						curImage = theWorld->curTileImage[kThing2InitTile];		curImage += 1;		if ( curImage > kThing2EndTile )			curImage = kThing2InitTile;		SWChangeTileImage( theWorld, kThing2InitTile, curImage );				cb->lastThingTick = TickCount();	}			if ( curTick - cb->lastMachineTick > kMachineTick ) {		curImage = theWorld->curTileImage[kMachineInitTile];		curImage += 1;		if ( curImage > kMachineEndTile )			curImage = kMachineInitTile;		SWChangeTileImage( theWorld, kMachineInitTile, curImage );							cb->lastMachineTick = TickCount();	}		}void TriggerOldSwitch( MapCBInfo cbData, short trigID ) {	short a,b;	Point tempP;	short tileID;		// flip those triggers!	for ( a = 0; a < kMaxWorldSize; a++ ) 		for ( b = 0; b < kMaxWorldSize; b++ ) 			if (cbData->theWorld[a][b].trig == trigID) {				tempP = cbData->theWorld[a][b].p;				cbData->theWorld[a][b].p = cbData->theWorld[a][b].trigP;				cbData->theWorld[a][b].trigP = tempP;				tempP = (cbData->theWorld[a][b]).p;				tileID = (tempP.v*kTilesWide)+tempP.h;				SWDrawTile( cbData->mapWorld, b, a, tileID );			}		// do special things involving trigID}void TriggerPlayerSwitches( MapCBInfo cbData ) {	MRPlayerData pd = GetCurrentPlayer();	short throwCount;		for ( throwCount = 0; throwCount < pd->numThrows; throwCount++ ) {		if ( pd->theThrows[throwCount] != 0 ) {			TriggerOldSwitch( cbData, pd->theThrows[throwCount] );			}	}}void AdjustLevelID( MapCBInfo cbData, short levelID ) {	short a,b;	short tileID;		// flip those levels!	for ( a = 0; a < kMaxWorldSize; a++ ) 		for ( b = 0; b < kMaxWorldSize; b++ ) 			if (cbData->theWorld[a][b].levelID == levelID) {				Point tilePoint;								tileID = (cbData->theWorld[a][b].p.v * kTilesWide) + cbData->theWorld[a][b].p.h;				tilePoint = PointFromTile(tileID);								if (PieceKind(cbData, tilePoint) == kLevelPiece) {					cbData->theWorld[a][b].p.v += 3;  // was p.h+=2;					tileID = (cbData->theWorld[a][b].p.v * kTilesWide) + cbData->theWorld[a][b].p.h;					SWDrawTile( cbData->mapWorld, b, a, tileID );				}			}}void SwapPlayerLevels( MapCBInfo cbData ) {	MRPlayerData pd = GetCurrentPlayer();	short swapCount;		for ( swapCount = 0; swapCount < MAX_LEVELS; swapCount++ )		if ( pd->passedLevel[swapCount] ) 			AdjustLevelID( cbData, swapCount+1 );}void CheckValidity( MapCBInfo cbData, char* theLocation ) {	if (cbData->TFA != cbData->mapWorld->tileFrameArray ||	    cbData->tf0 != cbData->mapWorld->tileFrameArray[0] ||	    cbData->tf1 != cbData->mapWorld->tileFrameArray[1])		ErrorCheck( (OSErr)-1, theLocation, true );}void RedrawAllTiles( MapCBInfo cbData ) {	/*for ( a = 0; a < kMaxWorldSize; a++ ) 		for ( b = 0; b < kMaxWorldSize; b++ ) {			SWDrawTile( cbData->mapWorld, b, a, cbData->mapTiles[b][a] );			sprintf( outStr, "redTile (%d,%d:%d).", (int)b, (int)a, (int)cbData->mapTiles[b][a] );			CheckValidity( cbData, outStr );		}*/			SWDrawTilesInBackground( cbData->mapWorld );	SWUpdateScrollingSpriteWorld( cbData->mapWorld, true );}void PlayerThrowUpdate( int trigID ) {	MRPlayerData pd = GetCurrentPlayer();	short throwCount;	short inCount;		for ( throwCount = 0; throwCount < pd->numThrows; throwCount++ )		if ( pd->theThrows[throwCount] == trigID ) {			for ( inCount = throwCount; inCount < pd->numThrows; inCount++ )				pd->theThrows[inCount] = pd->theThrows[inCount+1];			pd->numThrows -= 1;			return;		}		pd->theThrows[ pd->numThrows ] = trigID;	pd->numThrows += 1;}void ReturnFromPS( MapCBInfo cbData ) {	MRPlayerData pd = GetCurrentPlayer();	short tile;	int theKind;	Point tilePoint;	Point newLoc;		PSDestroy( &cbData->playerSelect );		// reset the map for the current player	CheckValidity(cbData, "Before LoadMapWorld");	LoadMapWorld( cbData );	CheckValidity(cbData, "Before SetUpTileData");	SetUpTileData( cbData );	CheckValidity(cbData, "Before TriggerPlayerSwitches");	TriggerPlayerSwitches( cbData );	CheckValidity(cbData, "Before SwapPlayerLevels");	SwapPlayerLevels( cbData );	CheckValidity(cbData, "Before RedrawAllTiles");	RedrawAllTiles( cbData );	CheckValidity(cbData, "After RedrawAllTiles");		if (( pd->mapLocation.h == 0 ) && ( pd->mapLocation.v == 0 )) {		SWSetSpriteLocation( cbData->mapSprite, cbData->spritePt.h*kWorldItemSize, 												cbData->spritePt.v*kWorldItemSize );			newLoc = cbData->spritePt;		} else {		SWSetSpriteLocation( cbData->mapSprite, pd->mapLocation.h*kWorldItemSize, 												pd->mapLocation.v*kWorldItemSize );		newLoc = pd->mapLocation;	}	DrawMapRoom( cbData );				// if there is a levelinfo, erase it, then make it again	if ( cbData->infoSprite ) {		SWRemoveSpriteFromAnimation( cbData->mapWorld, cbData->infoSprite, true );		cbData->infoSprite = NULL;		SetPort( cbData->mainWind );		FillRect( &cbData->infoRect, &qd.black );		cbData->onLevel = false;		PlaySoundID( kLevInfoDownSnd );	}	    // get new tile    tile = cbData->mapTiles[newLoc.v][newLoc.h];	tilePoint = PointFromTile( tile );	theKind = PieceKind( cbData, tilePoint );	if ( theKind == kLevelPiece || theKind == kPassedLevelPiece ) {		cbData->onLevel = true;		cbData->canProceed = ( theKind == kPassedLevelPiece );		cbData->levelEnterTime = TickCount();		cbData->levelNumber = cbData->theWorld[newLoc.h][newLoc.v].levelID;			//MakeInfoSprite( cbData );	}	}Boolean Map_ClickBack( Point location, int modifiers, MRUData info ) {	MapCBInfo		cbData = (MapCBInfo) info;	GrafPtr			oldPort;	Boolean			toReturn = false;		GetPort( &oldPort );	SetPort( cbData->mainWind );		if ( cbData->playerSelect ) {		if (PSClick( cbData->playerSelect, location ))			ReturnFromPS( cbData );		return false;	}		if ( PtInRect( location, &cbData->baRect ) ) {		PlaySoundID( kTickSnd );		toReturn = TrackBackArrow( &cbData->baRect, cbData->bubbleData );		if ( toReturn )			PlaySoundID( kClickSnd );	} else if (( PtInRect( location, &cbData->switchPlayerRect ) ) && (cbData->safeToSwitch)){		Rect nomRect = cbData->switchPlayerRect;				OffsetRect( &nomRect, -cbData->statAdjust.h, -cbData->statAdjust.v );				PlaySoundID( kTickSnd );				if (TrackGraphicalButton( cbData->mainWind, 								  nomRect,								  cbData->switchPlayerRect,								  cbData->statOff,								  cbData->statHiliteOff,								  cbData->bubbleData )) {			PlaySoundID( kClickSnd );			DimRectangle( cbData->fitRect, true, true );			cbData->playerSelect = PSCreate( cbData->mainWind );								// wierd bug fix: need to reset the internal keyboard status here.			// this is because if the user is holding down a key while entering the			// ps dialog, their key-up event won't be registered.			cbData->theKeys[0] = cbData->theKeys[1] = cbData->theKeys[2] = cbData->theKeys[3] = 0;			cbData->numKeys = 0;		}	} else if ( cbData->infoSprite && PtInRect( location, &cbData->infoPlayRect ) ) {			// track the play button:		PlaySoundID( kTickSnd );				if (TrackGraphicalButton( cbData->mainWind,								  cbData->infoPlayGfxRect,								  cbData->infoPlayRect,								  cbData->infoSprite->frameArray[0]->framePort,								  cbData->infoSprite->frameArray[1]->framePort,								  NULL )) {			PlaySoundID( kClickSnd );			cbData->quitForLevel = true;			return true;		}				}		SetPort( oldPort );	return toReturn;}Boolean Map_KeyBack( char key, int modifiers, MRUData info, Boolean keyUp ) {	short	newKey = kNoMove;	MRPrefs thePrefs = GetCurrentPrefs();	MapCBInfo cbData = (MapCBInfo) info;	short n;		if ( cbData->playerSelect ) {		if (PSKey( cbData->playerSelect, key, modifiers, keyUp ))			ReturnFromPS( cbData );		return false;	}		if ( (key == (char)13||key==(char)3) && cbData->onLevel ) {		long startTick;				if ( cbData->infoSprite ) {			PlaySoundID( kTickSnd );						CopyOffToOffRect( cbData->infoSprite->frameArray[1]->framePort, true, 							 (GWorldPtr)cbData->mainWind, false, cbData->infoPlayGfxRect, cbData->infoPlayRect );						startTick=TickCount();				 			while (TickCount()-startTick < 7);			CopyOffToOffRect( cbData->infoSprite->frameArray[0]->framePort, true, 							 (GWorldPtr)cbData->mainWind, false, cbData->infoPlayGfxRect, cbData->infoPlayRect );			PlaySoundID( kClickSnd );			cbData->quitForLevel = true;			return true;		} else if (keyUp) {			// woohoo! play the level			cbData->quitForLevel = true;			return true;		}		}		ObscureCursor();		// get the keykind.	if ( key == thePrefs.upKey )		newKey = kMoveUp;	else if ( key == thePrefs.downKey )		newKey = kMoveDown;	else if ( key == thePrefs.leftKey )		newKey = kMoveLeft;	else if ( key == thePrefs.rightKey )		newKey = kMoveRight;				// only update the presses if necessary.	if ( newKey ) {		if ( keyUp ) {			// user released key, so remove it from the list.			(cbData->numKeys)--;			if ( cbData->numKeys < 0 ) {				cbData->numKeys = 0;			} else {				for ( n = 0; cbData->theKeys[n] != newKey; n++ );				while ( n < cbData->numKeys ) {					cbData->theKeys[n] = cbData->theKeys[n+1];					n++;				}				cbData->theKeys[cbData->numKeys] = kNoMove;					}		} else {			// user pressed the key, so add it into the key info list.			for ( n = cbData->numKeys; n>0; n-- )				cbData->theKeys[n] = cbData->theKeys[n-1];			cbData->theKeys[0] = newKey;			(cbData->numKeys)++;		}	}		if ( cbData->frozeLast ) {		SWProcessScrollingSpriteWorld( cbData->mapWorld );		// keep the infoSprite in place		if ( cbData->infoSprite ) {			SWSetSpriteLocation(  cbData->infoSprite, cbData->mapWorld->visScrollRect.left + cbData->infoAdjust.h,													  cbData->mapWorld->visScrollRect.top + cbData->infoAdjust.v );		}				SWAnimateScrollingSpriteWorld( cbData->mapWorld );	}		return false;}Boolean Map_IdleBack( int modifiers, MRUData info ) {	MapCBInfo cbData = (MapCBInfo) info;	Point mouseLoc;	GrafPtr oldPort;		KeepMusicGoing();		if ( cbData->onLevel && cbData->infoSprite == NULL ) {		long elapsedTime = TickCount() - cbData->levelEnterTime;				if ( elapsedTime > kInfoDelayTicks ) {			MakeInfoSprite( cbData );			// play a sound		}	}		if ( cbData->infoSprite && !cbData->onLevel ) {		// kill the infosprite		SWRemoveSpriteFromAnimation( cbData->mapWorld, cbData->infoSprite, true );		cbData->infoSprite = NULL;		SetPort( cbData->mainWind );		FillRect( &cbData->infoRect, &qd.black );		// play a sound!		PlaySoundID( kLevInfoDownSnd );	}		if ( cbData->playerSelect ) {				if (PSIdle( cbData->playerSelect ))			ReturnFromPS( cbData );			return false;	}			BubbleOliver( cbData->bubbleData );	GetPort( &oldPort );	SetPort( cbData->mainWind );	GetMouse( &mouseLoc );	SetPort( oldPort );	if ( cbData->infoSprite && PtInRect( mouseLoc, &cbData->infoRect ) ) {		cbData->frozeLast = true;		return false;	}		cbData->frozeLast = false;		SWProcessScrollingSpriteWorld( cbData->mapWorld );	// keep the infoSprite in place	if ( cbData->infoSprite ) {		SWSetSpriteLocation(  cbData->infoSprite, cbData->mapWorld->visScrollRect.left + cbData->infoAdjust.h,												  cbData->mapWorld->visScrollRect.top + cbData->infoAdjust.v );	}		SWAnimateScrollingSpriteWorld( cbData->mapWorld );		return false;}void PrepareEventLoop( ) {	MRClearCallbacks();	MRSetSleepTime(0);	MRAllowKeyUp();	MRSetClickCallback( Map_ClickBack );	MRSetKeyUpDownCallback( Map_KeyBack ); 	MRSetIdleCallback( Map_IdleBack );}void LoadMapWorld( MapCBInfo cbData ) {	Handle worldRes;	Size theSize;	 	// allocate space (lots of it!) and check...	/*cbData->theWorld = (WorldArrayPtr) DBG_NewPtrClear(							sizeof( WorldPoint ) * kMaxWorldSize * kMaxWorldSize );	if ( cbData->theWorld == NULL )		ErrorCheck( (OSErr)-1, "World memory allocation error.", true );	*/		// now load in the resource itself:	MRWorldResFile();	worldRes = Get1Resource( kWorldResType, kWorldResID );	if ( worldRes == NULL )		ErrorCheck( ResError(), "World resource load error.", true );	MRRestoreResFile();		// copy it into our dataspace.	HLockHi( worldRes );	theSize = sizeof( WorldPoint ) * kMaxWorldSize * kMaxWorldSize;	BlockMove( (Ptr) (*worldRes), (Ptr) &(cbData->theWorld[0][0]), theSize );	HUnlock( worldRes );		// no longer need resource.	ReleaseResource( worldRes );}void MakeMapSWorld( MapCBInfo cbData ) {	Rect offRect = cbData->mapRect;	OSErr err;		// offscreen rect is always at position zero, and also	// has size evenly divisible into the tiles.	ZeroRect( &offRect );	if ((offRect.right/kWorldItemSize)*kWorldItemSize != offRect.right)		offRect.right = (offRect.right/kWorldItemSize)*kWorldItemSize + kWorldItemSize;	if ((offRect.bottom/kWorldItemSize)*kWorldItemSize != offRect.bottom)		offRect.bottom = (offRect.bottom/kWorldItemSize)*kWorldItemSize + kWorldItemSize;	cbData->offRect = offRect;		// create a scrolling sprite world	err = SWCreateSpriteWorldFromWindow( &cbData->mapWorld,										 (CWindowPtr) cbData->mainWind,										 &cbData->mapRect,										 &cbData->offRect );	ErrorCheck( err, "SWCreateSpriteWorldFromWindow", true );										 	// setup the tiling code.	err = SWInitTiling( cbData->mapWorld,						kWorldItemSize,						kWorldItemSize,						kNumMapTiles );	ErrorCheck( err, "SWInitTiling", true );		// allocate space for a (big!) tile map.	err = SWCreateTileMap( cbData->mapWorld,						   &cbData->mapTiles,						   kMaxWorldSize,						   kMaxWorldSize );	ErrorCheck( err, "SWCreateTileMap", true );		// load in the tile graphics	MRGeneralResFile();	err = SWLoadTilesFromPictResource( cbData->mapWorld,									   kStartTileLoad,									   kEndTileLoad,									   kMapTilesPict,									   0,									   kNoMask,									   0,									   0 );	ErrorCheck( err, "SWLoadTilesFromPictResource", true );	MRRestoreResFile();		// set up the tiles, draw 'em, etc.	LoadMapWorld( cbData );	SetUpTileData( cbData );		// that's all folks!}Point PointFromTile( short theTile ) {	Point p;		p.v = theTile/kTilesWide;	p.h = theTile-(p.v*kTilesWide);		if ( p.v >= kTilesDeep || p.h >= kTilesWide || p.v < 0 || p.h < 0 )		ErrorCheck( (OSErr)-1, "Strange error: fatal tile point.", true );			return p;}int PieceKind( MapCBInfo cbData, Point p ) {	return cbData->pieceKinds[p.v][p.h];}void TriggerSwitch( MapCBInfo cbData, short h, short v ) {	short trigID;	short a,b;	Point tempP;	short tileID;	MRPlayerData pd = GetCurrentPlayer();	Rect* storedRectArray;	short storedRectCount;	short repairTile;		// get the trigger info	trigID = cbData->theWorld[h][v].trig;		// SpriteWorld hack #1: we only want to see transitions	// for those tiles affected by this trigger.	SWStoreAllTileChanges( cbData->mapWorld, &storedRectArray, &storedRectCount ); 	SWClearAllTileChanges( cbData->mapWorld );		// flip those triggers!	for ( a = 0; a < kMaxWorldSize; a++ ) 		for ( b = 0; b < kMaxWorldSize; b++ ) 			if (cbData->theWorld[a][b].trig == trigID) {				tempP = cbData->theWorld[a][b].p;				cbData->theWorld[a][b].p = cbData->theWorld[a][b].trigP;				cbData->theWorld[a][b].trigP = tempP;								// now check to see if it is a level,				// and if so, have they passed it?				if ( cbData->theWorld[a][b].p.v < 3 &&					 cbData->theWorld[a][b].p.h > 0 &&					 cbData->theWorld[a][b].levelID > 0 )					if ( pd->passedLevel[cbData->theWorld[a][b].levelID-1] )						cbData->theWorld[a][b].p.v += 3;  // p.h+=2;								// draw it.				tempP = (cbData->theWorld[a][b]).p;				tileID = (tempP.v*kTilesWide)+tempP.h;				if ( a!=h || b!=v )					SWDrawTile( cbData->mapWorld, b, a, tileID );				else					repairTile = tileID;			}		// let player know about updates	PlayerThrowUpdate( trigID );	// do a special cross-fade or other blend	SWPerformVisualTransition( cbData->mapWorld, SWCrossFadeTransition, 4, 4 );	SWRestoreAllTileChanges( cbData->mapWorld, &storedRectArray, storedRectCount );	SWDrawTile( cbData->mapWorld, v, h, repairTile );		// do special things involving trigID}void InfoSprite_MoveProc( SpritePtr theSprite ) {	MapCBInfo cbData = (MapCBInfo) theSprite->userData;	SWSetSpriteLocation( theSprite, cbData->mapWorld->visScrollRect.left + cbData->infoAdjust.h,									cbData->mapWorld->visScrollRect.top + cbData->infoAdjust.v );}void Sprite_KeyMoveProc( SpritePtr theSprite ) {	MapCBInfo cbData = (MapCBInfo) theSprite->userData;	short row, col;	short rowDelta, colDelta;	short tile;	short curKey;	Point tilePoint;	int theKind;	MRPlayerData pd = GetCurrentPlayer();		// the cbData has info about which directions the sprite should move.		// figure out about where we are.	row = theSprite->destFrameRect.top / kWorldItemSize;	col = theSprite->destFrameRect.left / kWorldItemSize;		// if we're in-between grid spaces, keypresses are ignored.	if ( (row * kWorldItemSize == theSprite->destFrameRect.top) &&	     (col * kWorldItemSize == theSprite->destFrameRect.left ) ) {	    // okay, we're on-grid, so we're good to go!	    tile = cbData->mapTiles[row][col];	    	    // set the deltas	    rowDelta = colDelta = 0;	    curKey = cbData->theKeys[0];	    if ( curKey == kMoveLeft )	    	colDelta = -1;	    else if ( curKey == kMoveRight )	    	colDelta = 1;	    else if ( curKey == kMoveUp )	    	rowDelta = -1;	    else if ( curKey == kMoveDown )	    	rowDelta = 1;	     	    // get new tile	    tile = cbData->mapTiles[row+rowDelta][col+colDelta];		tilePoint = PointFromTile( tile );		theKind = PieceKind( cbData, tilePoint );			    // check for impaction here	    if ( theKind == kSwitchPiece || theKind == kPassablePiece) {			if (!cbData->onLevel || 				( cbData->onLevel && cbData->canProceed ) ||				(cbData->onLevel && !cbData->canProceed && 					pd->previousLocation.h == col+colDelta &&					pd->previousLocation.v == row+rowDelta ) ) {				// either we're not coming from a level,				// or we are but we've passed it,				// or we are but we haven't passed, yet it's okay since we're going to whence				//    we came. Ew.   				theSprite->vertMoveDelta = rowDelta * kSpriteMoveDelta;				theSprite->horizMoveDelta = colDelta * kSpriteMoveDelta;				pd->mapLocation.h = col+colDelta;				pd->mapLocation.v = row+rowDelta;				if ( curKey && theKind == kSwitchPiece ) {					PlaySoundID( kMapSwitchSnd );					TriggerSwitch(cbData, col+colDelta, row+rowDelta);				}								cbData->onLevel = false;				cbData->levelNumber = 0;			} else {				// we're on a level that we haven't passed AND we're trying to move off it.				// don't think so, buster.				theSprite->vertMoveDelta = 0;				theSprite->horizMoveDelta = 0;			}	    }	    	    else if ( theKind == kLevelPiece || theKind == kPassedLevelPiece ) {			theSprite->vertMoveDelta = rowDelta * kSpriteMoveDelta;			theSprite->horizMoveDelta = colDelta * kSpriteMoveDelta;			pd->mapLocation.h = col+colDelta;			pd->mapLocation.v = row+rowDelta;			if ( curKey ) {				pd->previousLocation.h = col;				pd->previousLocation.v = row;				cbData->onLevel = true;				cbData->canProceed = ( theKind == kPassedLevelPiece );				cbData->levelEnterTime = TickCount();				cbData->levelNumber = cbData->theWorld[col+colDelta][row+rowDelta].levelID;			}	    }	    		// else set moveDeltas to zero.		else {			theSprite->vertMoveDelta = 0;			theSprite->horizMoveDelta = 0;		}	}		// check if it is safe to switch players.	// it is "safe" if the current sprite is not moving.	if ( (theSprite->horizMoveDelta == 0) && (theSprite->vertMoveDelta == 0)) 		cbData->safeToSwitch = true;	else {		cbData->safeToSwitch = false;	}		// move the sprite	SWOffsetSprite( theSprite, theSprite->horizMoveDelta, theSprite->vertMoveDelta );	}/*void Sprite_FrameProc( SpritePtr theSprite, FramePtr curFrame, long *frameIndex ) {	MapCBInfo cbData = (MapCBInfo) theSprite->userData;		if ( TickCount() - cbData->lastSpriteFrame > kSpriteFrameDelay ) {		(*frameIndex) = (1-(*frameIndex));		cbData->lastSpriteFrame = TickCount();	}}*/void MakeMapSprites( MapCBInfo cbData ) {	SpriteLayerPtr	theLayer;	OSErr err;	MRPlayerData	pd = GetCurrentPlayer();	MRPrefs			mp = GetCurrentPrefs();	Point			spriteLoc;		// the layer	err = SWCreateSpriteLayer( &theLayer );	ErrorCheck( err, "SWCreateSpriteLayer", true );		// the main sprites	MRGeneralResFile();	err = SWCreateSpriteFromSinglePict( cbData->mapWorld,										&cbData->mapSprite,										NULL,										kMapSpritesPict,										kMapMasksPict,										kWorldItemSize,										kFatMask );	ErrorCheck( err, "SWCreateSpriteFromSinglePict", true );	MRRestoreResFile();		// set the userData	cbData->mapSprite->userData = (long) cbData;		// Set sprite-related infos	SWSetSpriteMoveProc( cbData->mapSprite, Sprite_KeyMoveProc );	if ( pd->mapLocation.h == 0 && pd->mapLocation.v == 0 ) {		SWSetSpriteLocation( cbData->mapSprite, cbData->spritePt.h*kWorldItemSize, 												cbData->spritePt.v*kWorldItemSize );		spriteLoc = cbData->spritePt;	} else {		SWSetSpriteLocation( cbData->mapSprite, pd->mapLocation.h*kWorldItemSize, 												pd->mapLocation.v*kWorldItemSize );		spriteLoc = pd->mapLocation;	}		SWSetSpriteMoveDelta( cbData->mapSprite, 0, 0 );		// Set the sprite drawproc.	if ( mp.interlacedMode )		SWSetSpriteDrawProc( cbData->mapSprite, MSPRITEDRAWPROCINT );	else		SWSetSpriteDrawProc( cbData->mapSprite, MSPRITEDRAWPROC );		// the frame-change proc:	//SWSetSpriteFrameProc( cbData->mapSprite, Sprite_FrameProc );	SWSetSpriteFrameRange( cbData->mapSprite, 0, 1 );	SWSetSpriteFrameTime( cbData->mapSprite, kSpriteFrameMilli );		// add the sprite.	SWAddSprite( theLayer, cbData->mapSprite );	SWAddSpriteLayer( cbData->mapWorld, theLayer );			// lock!	SWLockSpriteWorld( cbData->mapWorld );}void Scroll_WorldMove( SpriteWorldPtr theWorld,					   SpritePtr followSprite ) {	MapCBInfo cbData = (MapCBInfo) followSprite->userData;	short midTop, midLeft;	MRPrefs	mp = GetCurrentPrefs();		// calc mid points	midTop = cbData->midRect.top + cbData->mapWorld->visScrollRect.top;	midLeft = cbData->midRect.left + cbData->mapWorld->visScrollRect.left;		cbData->mapWorld->horizScrollDelta = 			(kSpriteMoveDelta *				(followSprite->destFrameRect.left - midLeft) ) / kSpriteMoveDistance;	cbData->mapWorld->vertScrollDelta = 			(kSpriteMoveDelta *				(followSprite->destFrameRect.top - midTop) ) / kSpriteMoveDistance;	// interlaced mode can only move every-other pixel in the vert firection	// the >> 1 << 1 just gets rid of the rightmost bit.	if ( mp.interlacedMode )		cbData->mapWorld->vertScrollDelta = (cbData->mapWorld->vertScrollDelta) >> 1 << 1;		// keep that info sprite in place!//	if ( cbData->infoSprite )//		SWOffsetSprite( cbData->infoSprite, -cbData->mapWorld->horizScrollDelta, -cbData->mapWorld->vertScrollDelta );}void SetupMapAnimation( MapCBInfo cbData ) {	Rect moveBounds;	MRPrefs	mp = GetCurrentPrefs();		// set up the rectangle used for smooth following	cbData->midRect = cbData->mapSprite->curFrameP->frameRect;	CenterRect( &cbData->midRect, &cbData->mapWorld->backRect );		// speed info	SWSetSpriteWorldMaxFPS( cbData->mapWorld, kMaxMapFPS );	SWSyncSpriteWorldToVBL( cbData->mapWorld, false );		// move bounds are the size of the tile map	SetRect( &moveBounds, 0, 0, kMaxWorldSize * kWorldItemSize,								kMaxWorldSize * kWorldItemSize );	SWSetScrollingWorldMoveBounds( cbData->mapWorld, &moveBounds );	SWSetScrollingWorldMoveProc( cbData->mapWorld, Scroll_WorldMove,								 cbData->mapSprite );		// Could set up a tile change proc here. 		// Put the scrolled world in starting position.	SWMoveVisScrollRect( cbData->mapWorld,						 cbData->mapSprite->destFrameRect.left -						 		cbData->mapWorld->backRect.right / 2,						 cbData->mapSprite->destFrameRect.top -						 		cbData->mapWorld->backRect.bottom / 2 );		// Set the drawing routines for the world.	if ( mp.interlacedMode ) {		SWSetSpriteWorldOffscreenDrawProc( cbData->mapWorld, MOFFDRAWPROCINT );		SWSetSpriteWorldScreenDrawProc( cbData->mapWorld, MONDRAWPROCINT );		SWSetTileMaskDrawProc( cbData->mapWorld, MTILEDRAWPROCINT );	} else {		SWSetSpriteWorldOffscreenDrawProc( cbData->mapWorld, MOFFDRAWPROC );		SWSetSpriteWorldScreenDrawProc( cbData->mapWorld, MONDRAWPROC );		SWSetTileMaskDrawProc( cbData->mapWorld, MTILEDRAWPROC );	}		SWSetTileChangeProc( cbData->mapWorld, Tile_MapChangeProc );	cbData->mapWorld->userData = (long) cbData;		// set up simple stuff!	ForeColor( blackColor );	BackColor( whiteColor );		// draw!	SWDrawTilesInBackground( cbData->mapWorld );	SWUpdateScrollingSpriteWorld( cbData->mapWorld, true );}void MakePieceKinds( MapCBInfo cbData ) {	int i, j;		for (i=0; i<kTilesDeep; i++)		for (j=0; j<kTilesWide; j++)			cbData->pieceKinds[i][j] = kNoPassPiece;	//cbData->[0][0] = kPassablePiece;		cbData->pieceKinds[0][1] = kLevelPiece;	cbData->pieceKinds[1][1] = kLevelPiece;	cbData->pieceKinds[2][1] = kLevelPiece;	cbData->pieceKinds[3][1] = kPassedLevelPiece;	cbData->pieceKinds[4][1] = kPassedLevelPiece;	cbData->pieceKinds[5][1] = kPassedLevelPiece;			for (i=0;i<kUsableTilesWide;i++)		cbData->pieceKinds[6][i] = kSwitchPiece;			for (i=0;i<kUsableTilesWide;i++) {		cbData->pieceKinds[7][i] = kPassablePiece;		cbData->pieceKinds[8][i] = kPassablePiece;	}		/*	//cbData->pieceKinds[0][0] = kPassablePiece;	cbData->pieceKinds[0][2] = kPassablePiece;	cbData->pieceKinds[0][3] = kLevelPiece;	cbData->pieceKinds[0][4] = kLevelPiece;	cbData->pieceKinds[0][5] = kPassedLevelPiece;	cbData->pieceKinds[0][6] = kSwitchPiece;	cbData->pieceKinds[0][7] = kSwitchPiece;	cbData->pieceKinds[0][8] = kSwitchPiece;	cbData->pieceKinds[1][3] = kLevelPiece;	cbData->pieceKinds[1][4] = kLevelPiece;	cbData->pieceKinds[1][5] = kPassedLevelPiece;	cbData->pieceKinds[1][6] = kSwitchPiece;	cbData->pieceKinds[1][7] = kSwitchPiece;	cbData->pieceKinds[1][8] = kSwitchPiece;	cbData->pieceKinds[2][3] = kLevelPiece;	cbData->pieceKinds[2][4] = kLevelPiece;	cbData->pieceKinds[2][5] = kPassedLevelPiece;	cbData->pieceKinds[2][6] = kSwitchPiece;	cbData->pieceKinds[2][7] = kSwitchPiece;	cbData->pieceKinds[2][8] = kSwitchPiece;	cbData->pieceKinds[3][3] = kLevelPiece;	cbData->pieceKinds[3][4] = kLevelPiece;	cbData->pieceKinds[3][5] = kPassedLevelPiece;	cbData->pieceKinds[3][6] = kSwitchPiece;	cbData->pieceKinds[3][7] = kSwitchPiece;	cbData->pieceKinds[3][8] = kSwitchPiece;	cbData->pieceKinds[4][0] = kPassablePiece;	cbData->pieceKinds[4][1] = kPassablePiece;		cbData->pieceKinds[4][2] = kPassablePiece;		cbData->pieceKinds[4][3] = kPassablePiece;		cbData->pieceKinds[4][4] = kPassablePiece;		cbData->pieceKinds[4][5] = kPassablePiece;			cbData->pieceKinds[6][2] = kPassablePiece;		cbData->pieceKinds[11][1] = kPassablePiece;	*/}void GetLevelInfo( short levelNum, MapLevelInfo* theInfo ) {	Handle	levelResource = NULL;	Ptr		levelPtr;		// grab the level resource	MRWorldResFile();	levelResource = Get1Resource( 'MRlv', 300 + levelNum );		MRRestoreResFile();	if ( levelResource ) {		// secure it.		HLockHi( levelResource );				// get the ptr:		levelPtr = (Ptr) (*levelResource);				// set the extra level information		BlockMove( levelPtr, (Ptr)theInfo, sizeof(MapLevelInfo) );		// now release the resource		HUnlock( levelResource );		ReleaseResource( levelResource );				theInfo->isExtended = false;				// and fix up the reqInfo thing:		if ( theInfo->reqInfo<0 ) {			theInfo->isExtended = true;			theInfo->reqInfo = theInfo->actualInfo;		}			} else {		theInfo->reqInfo = 0;		theInfo->isExtended = false;		strcpy( theInfo->levelTitle, "Nonexistant Level" );		strcpy( theInfo->levelInfo, "This level doesn't exist yet." );		C2PStr( theInfo->levelTitle );		C2PStr( theInfo->levelInfo );	}}int CurrentFontHeight() {	FontInfo finf;		GetFontInfo( &finf );	return (finf.ascent+finf.descent+finf.leading);}int* GetWordBreaks( char* theText, int* numBreaks, char delimChar ) {	int index;	int* breaks;	int breakCount;		// first count the number of delimChars	*numBreaks = 0;	index=0;	while ( theText[index] != '\0' ) {		if (( theText[index] == delimChar ) || (theText[index]==0x0D))			(*numBreaks) += 1;		index++;	}		// now alloc memory	breaks = (int*) DBG_NewPtrClear( sizeof( int ) * ((*numBreaks)+2) );		// and set up the junk	index=0; breakCount = 0;	breaks[breakCount++]=-1;	while ( theText[index] != '\0' ) {		if (( theText[index] == delimChar ) || (theText[index]==0x0D))			breaks[breakCount++] = index;		index++;	}		breaks[(*numBreaks)] = strlen( theText ) ;//- 1;		return breaks;}// return true on hard-break.Boolean MakeStringPortion( char* theText, int start, int finish, char* part ) {	int fromIndex, toIndex;		fromIndex = start+1;	toIndex = 0;		while ( fromIndex < finish ) {		part[toIndex] = theText[fromIndex];		fromIndex += 1;		toIndex += 1;	}		part[toIndex] = ' ';	part[toIndex+1] = '\0';		if (theText[finish]==0x0D)		return true;		return false;}void FlowWordsInRect( char* theText, Rect flowRect, char delimChar ) {	Point currentPoint;	int oldLeftPoint;	int* breaks;	int numBreaks;	int numOnLine = 0;	int breakIndex;	char* stringPortion;	char* tempString;	Boolean hardBreak;		GetPen( &currentPoint );	oldLeftPoint = currentPoint.h;		// Make tmep string	tempString = (char*) DBG_NewPtrClear( sizeof( char ) * NODE_TEXT_LENGTH );	stringPortion = (char*) DBG_NewPtrClear( sizeof( char ) * NODE_TEXT_LENGTH );		// Get the breaking locations:	breaks = GetWordBreaks( theText, &numBreaks, delimChar );		for (breakIndex = 0; breakIndex < numBreaks; breakIndex++) {		GetPen( &currentPoint );				hardBreak = MakeStringPortion( theText, breaks[breakIndex], breaks[breakIndex+1], stringPortion );		strcpy( tempString, stringPortion );		if (StringWidth(C2PStr(tempString)) + currentPoint.h <= flowRect.right) {			strcpy( tempString, stringPortion );			DrawString( C2PStr(tempString) );			numOnLine++;			if ( hardBreak )				MoveTo( oldLeftPoint, currentPoint.v + CurrentFontHeight() );		} else if ( numOnLine == 0 ) {			strcpy( tempString, stringPortion );			DrawString( C2PStr(tempString) );			numOnLine++;			if ( hardBreak )				MoveTo( oldLeftPoint, currentPoint.v + CurrentFontHeight() );		} else {			MoveTo( oldLeftPoint, currentPoint.v + CurrentFontHeight() );			strcpy( tempString, stringPortion );			DrawString( C2PStr(tempString) );			numOnLine = 1;		}	}		// Kill breaking locations	DBG_DisposePtr( (Ptr) breaks );	DBG_DisposePtr( (Ptr) tempString );	DBG_DisposePtr( (Ptr) stringPortion );}void MakeInfoSprite( MapCBInfo cbData ) {	OSErr err;	MRPlayerData	pd = GetCurrentPlayer();	MRPrefs			mp = GetCurrentPrefs();	Rect			picRect = RectFromPictureID( kInfoPict );	Boolean			atTop = true;	MapLevelInfo	mapInfo;	GWorldPtr		oldGW;	GDHandle		oldGD;	char			infoString[255];	GrafPtr			oldPort;	Rect			flowRect;		// grab the image.	MRGeneralResFile();	err = SWCreateSpriteFromPictResource( cbData->mapWorld,					  					  &cbData->infoSprite,										  NULL,										  kInfoPict,										  kInfoPict,										  2,										  kNoMask );	ErrorCheck( err, "SWCreateSpriteFromPictResource", true );		SetPort( cbData->mainWind );	MRRestoreResFile();		// figure if the mapSprite is at the top or bottom of the map screen:	atTop = ( cbData->mapSprite->destFrameRect.top <= 				((cbData->mapWorld->visScrollRect.bottom+cbData->mapWorld->visScrollRect.top)/2) );		// calculate the position of the info rectangle.	// if the mapSprite is up top of the screen, put it at bot right,	// otherwise put it at top left	cbData->infoRect = picRect;	if ( atTop )		OffsetRect( &cbData->infoRect, cbData->mapRect.right - kInfoBufferSpace - picRect.right,									   cbData->mapRect.bottom - kInfoBufferSpace - picRect.bottom );	else		OffsetRect( &cbData->infoRect, cbData->mapRect.left + kInfoBufferSpace, 									   cbData->mapRect.top + kInfoBufferSpace );		DrawPictureID( kInfoPict, cbData->infoRect );		// set the onscreen offset	cbData->infoScreenOffset.h = cbData->infoRect.left;	cbData->infoScreenOffset.v = cbData->infoRect.top;		// Set the position, but be careful about the position of the scrolling world!	SWSetSpriteLocation( cbData->infoSprite, cbData->infoRect.left - cbData->mapRect.left + cbData->mapWorld->visScrollRect.left,											 cbData->infoRect.top - cbData->mapRect.top + cbData->mapWorld->visScrollRect.top );	SWSetSpriteMoveDelta( cbData->infoSprite, 0, 0 );	// the adjustment amount	cbData->infoAdjust.h = cbData->infoSprite->destFrameRect.left - cbData->mapWorld->visScrollRect.left;	cbData->infoAdjust.v = cbData->infoSprite->destFrameRect.top - cbData->mapWorld->visScrollRect.top;		// set the userData	cbData->infoSprite->userData = (long) cbData;		// Set sprite-related infos	// SWSetSpriteMoveProc( cbData->infoSprite, InfoSprite_MoveProc );		// set up the play rectangle	SetRect( &cbData->infoPlayGfxRect, 125, 116, 125+64, 116+20 );	cbData->infoPlayRect = cbData->infoPlayGfxRect;	OffsetRect( &cbData->infoPlayRect, cbData->infoRect.left, cbData->infoRect.top );	// Set the sprite drawproc.	if ( mp.interlacedMode )		SWSetSpriteDrawProc( cbData->infoSprite, MPLAYDRAWPROCINT );	else		SWSetSpriteDrawProc( cbData->infoSprite, MPLAYDRAWPROC );		// the frame-change proc:	SWSetSpriteFrameAdvance( cbData->infoSprite, 0 );		// don't push it under the neato tiles	SWSetSpriteUnderTiles( cbData->infoSprite, false );		// lock the sprite.	SWLockSprite( cbData->infoSprite );	// set the port for drawing	GetGWorld( &oldGW, &oldGD );	SetGWorld( (GWorldPtr) cbData->infoSprite->frameArray[0]->framePort, NULL );	// get information about the level	GetLevelInfo( cbData->levelNumber, &mapInfo );			// set the correct color for drawing	{		short helveticaNum;		RGBColor someColor;				GetFNum( "\pHelvetica", &helveticaNum );		TextSize(9);		TextFont(helveticaNum);		someColor.red = 39168;		someColor.green = 52224;		someColor.blue = 52224;		RGBForeColor(&someColor);		BackColor(blackColor);	}		// now draw the text:	MoveTo( 74, 47 );	DrawString( (StringPtr)mapInfo.levelTitle );	MoveTo( 74, 60 );	if ( mapInfo.isExtended ) {		if ( mapInfo.hours && mapInfo.mins)			sprintf( infoString, "%.3d in %.1d hr. %.2d min.", (int)mapInfo.reqInfo, (int)mapInfo.hours, (int)mapInfo.mins );		else if (mapInfo.hours)			sprintf( infoString, "%.3d in %.1d hr.", (int)mapInfo.reqInfo, (int)mapInfo.hours );		else if (mapInfo.mins && mapInfo.secs)			sprintf( infoString, "%.3d in %.2d min., %.2d sec.", (int) mapInfo.reqInfo, (int)mapInfo.mins, (int)mapInfo.secs );	    else if ( mapInfo.mins )	    	sprintf( infoString, "%.3d in %.2d min.", (int) mapInfo.reqInfo, (int)mapInfo.mins );	    else	    	sprintf( infoString, "%.3d in %.2d sec.", (int) mapInfo.reqInfo, (int)mapInfo.secs );	} else		sprintf( infoString, "%.3d", (int)mapInfo.reqInfo );	DrawString( C2PStr(infoString) );	MoveTo( 74, 72 );	if ( pd->passedLevel[cbData->levelNumber-1] )		DrawString( "\pPassed" );	else		DrawString( "\pUndefeated" );	MoveTo( 74, 85 );	P2CStr( (StringPtr)mapInfo.levelInfo );	SetRect( &flowRect, 74, 85 - CurrentFontHeight(), (cbData->infoRect.right-cbData->infoRect.left) - 4, 								110 );	FlowWordsInRect( mapInfo.levelInfo, flowRect, ' ' );	//DrawString( (StringPtr)mapInfo.levelInfo );		// reset the color	ForeColor( whiteColor );	BackColor( blackColor );		// reset the graphics port.	SetGWorld( oldGW, oldGD );		// now we have to draw to the mainWind	// to prevent interlacing graphics artifacts.	GetPort( &oldPort );	SetPort( cbData->mainWind );		// set the correct color for drawing	{		short helveticaNum;		RGBColor someColor;				GetFNum( "\pHelvetica", &helveticaNum );		TextSize(9);		TextFont(helveticaNum);		someColor.red = 39168;		someColor.green = 52224;		someColor.blue = 52224;		RGBForeColor(&someColor);		BackColor(blackColor);	}		// now draw the text:	MoveTo( 74 + cbData->infoScreenOffset.h, 47 + cbData->infoScreenOffset.v );	DrawString( (StringPtr)mapInfo.levelTitle );	MoveTo( 74 + cbData->infoScreenOffset.h, 60 + cbData->infoScreenOffset.v );	if ( mapInfo.isExtended ) {		if ( mapInfo.hours && mapInfo.mins)			sprintf( infoString, "%.3d in %.1d hr. %.2d min.", (int)mapInfo.reqInfo, (int)mapInfo.hours, (int)mapInfo.mins );		else if (mapInfo.hours)			sprintf( infoString, "%.3d in %.1d hr.", (int)mapInfo.reqInfo, (int)mapInfo.hours );		else if (mapInfo.mins && mapInfo.secs)			sprintf( infoString, "%.3d in %.2d min., %.2d sec.", (int) mapInfo.reqInfo, (int)mapInfo.mins, (int)mapInfo.secs );	    else if ( mapInfo.mins )	    	sprintf( infoString, "%.3d in %.2d min.", (int) mapInfo.reqInfo, (int)mapInfo.mins );	    else	    	sprintf( infoString, "%.3d in %.2d sec.", (int) mapInfo.reqInfo, (int)mapInfo.secs );	} else		sprintf( infoString, "%.3d", (int)mapInfo.reqInfo );	DrawString( C2PStr(infoString) );	MoveTo( 74 + cbData->infoScreenOffset.h, 72 + cbData->infoScreenOffset.v );	if ( pd->passedLevel[cbData->levelNumber-1] )		DrawString( "\pPassed" );	else		DrawString( "\pUndefeated" );	MoveTo( 74 + cbData->infoScreenOffset.h, 85 + cbData->infoScreenOffset.v );	OffsetRect( &flowRect, cbData->infoScreenOffset.h, cbData->infoScreenOffset.v );	FlowWordsInRect( mapInfo.levelInfo, flowRect, ' ' );//	DrawString( (StringPtr)mapInfo.levelInfo );		// reset the color	ForeColor( whiteColor );	BackColor( blackColor );	// reset the port, again!		SetPort( oldPort );		// lock the sprite, again.	SWLockSprite( cbData->infoSprite );	// add the sprite.	SWAddSprite( cbData->mapWorld->headSpriteLayerP, cbData->infoSprite );		// play the creation sound	PlaySoundID( kLevInfoUpSnd );}MapCBInfo MakeMapCBData( WindowPtr wind ) {	MapCBInfo cbData = (MapCBInfo) DBG_NewPtrClear( sizeof( struct MapCBInfoStruct ) );	Rect mapRoomRect = RectFromPictureID( kMapRoomPict );	Rect mapStatRect = RectFromPictureID( kMapStatPict );	Rect statOffRect = mapStatRect;	Rect backArrowRect = RectFromPictureID( kBackArrowPict );	Rect bubbleRect;	MRPrefs mp = GetCurrentPrefs();	short			tile;	Point			tilePoint;	int				theKind;	short			row, col;			if ( cbData == NULL )		return NULL;		// basic info		cbData->mainWind = wind;	cbData->fitRect = FitRectFromWind( wind );		// calculate the space the map fits into:	OffsetRect( &mapRoomRect, cbData->fitRect.left, cbData->fitRect.top );	OffsetRect( &mapStatRect, cbData->fitRect.right - mapStatRect.right,							  cbData->fitRect.top );							  	// the size of the mapRect depends heavily on the preferences	SetRect( &cbData->mapRect, mapRoomRect.right, cbData->fitRect.top,							   mapStatRect.left,  cbData->fitRect.bottom );	InsetRect( &cbData->mapRect, mp.screenSize, mp.screenSize );	// The piece kinds array	MakePieceKinds( cbData );		// make the spriteworld and associated info	MakeMapSWorld( cbData );	MakeMapSprites( cbData );	SetupMapAnimation( cbData );		// update for player	TriggerPlayerSwitches( cbData );	SwapPlayerLevels( cbData );	// setup debug	cbData->TFA = cbData->mapWorld->tileFrameArray;	cbData->tf0 = cbData->mapWorld->tileFrameArray[0];	cbData->tf1 = cbData->mapWorld->tileFrameArray[1];		// finish the update	RedrawAllTiles( cbData );	//SWDrawTilesInBackground( cbData->mapWorld );		// don't forget the back arrow!	OffsetRect( &backArrowRect, mapRoomRect.left, mapRoomRect.bottom - backArrowRect.bottom );	cbData->baRect = backArrowRect;		// oliver bubbly, you are lovely	SetRect( &bubbleRect, 0, 0, 32, 32 );	OffsetRect( &bubbleRect, 4, 4 );	OffsetRect( &bubbleRect, mapStatRect.left, mapStatRect.top );	SetPort( wind );	cbData->bubbleData = MakeNewBubble( bubbleRect );		// now create offscreens for the stat-bar on the right side.	(void)MacMakeGWorldDepth( statOffRect, CURRENT_DEPTH, &cbData->statOff );	(void)MacMakeGWorldDepth( statOffRect, CURRENT_DEPTH, &cbData->statHiliteOff );	cbData->statOffRect = statOffRect;	cbData->statAdjust.h = mapStatRect.left;	cbData->statAdjust.v = mapStatRect.top;	SetRect( &cbData->switchPlayerRect, 10, 352, 10+20, 352+115);	OffsetRect( &cbData->switchPlayerRect, cbData->statAdjust.h, cbData->statAdjust.v );		// and draw:	DrawPictToWorld( cbData->statOff, kMapStatPict );	DrawPictToWorld( cbData->statHiliteOff, kMapStatHilitePict );		// figure out about where we are.	row = cbData->mapSprite->destFrameRect.top / kWorldItemSize;	col = cbData->mapSprite->destFrameRect.left / kWorldItemSize;	// what about the levelinfo box?    tile = cbData->mapTiles[row][col];	tilePoint = PointFromTile( tile );	theKind = PieceKind( cbData, tilePoint );	if ( theKind == kLevelPiece || theKind == kPassedLevelPiece ) {		cbData->onLevel = true;		cbData->canProceed = ( theKind == kPassedLevelPiece );		cbData->levelEnterTime = TickCount();		cbData->levelNumber = cbData->theWorld[col][row].levelID;	}		return cbData;}void DestroyMapCBData( MapCBInfo cbData ) {	if ( cbData->mapWorld )		SWDisposeSpriteWorld( cbData->mapWorld );	if ( cbData->statOff )		DestroyGWorld( &cbData->statOff );	if ( cbData->statHiliteOff )		DestroyGWorld( &cbData->statHiliteOff );	KillBubble( &cbData->bubbleData );	DBG_DisposePtr( (Ptr) cbData );}void DrawMapRoom( MapCBInfo cbData ) {	GrafPtr oldPort;	Rect mapRoomRect = RectFromPictureID( kMapRoomPict );	Rect mapStatRect = RectFromPictureID( kMapStatPict );	Rect playerNameRect;	MRPlayerData curPlay = GetCurrentPlayer();	char* tString = NULL;		GetPort( &oldPort );	SetPort( cbData->mainWind );		OffsetRect( &mapRoomRect, cbData->fitRect.left, cbData->fitRect.top );	OffsetRect( &mapStatRect, cbData->fitRect.right - mapStatRect.right,							  cbData->fitRect.top ); 							  	DrawPictureID( kMapRoomPict, mapRoomRect );	DrawPictureID( kMapStatPict, mapStatRect );		// draw the lettering	SetRect( &playerNameRect, 11, 73+4, 11+18, 73-4+198 );	OffsetRect( &playerNameRect, mapStatRect.left, mapStatRect.top );	MRLettering( curPlay->myName, playerNameRect, kGreenLettering );		// and the current time.	{		short helveticaNum;		RGBColor someColor;				GetFNum( "\pHelvetica", &helveticaNum );		TextSize(9);		TextFont(helveticaNum);		someColor.red = 39168;		someColor.green = 52224;		someColor.blue = 52224;		RGBForeColor(&someColor);		BackColor(blackColor);		MoveTo( 3+1+mapStatRect.left, 321+10+mapStatRect.top );		tString = MakePlayerTimeString( curPlay );		DrawString( C2PStr(tString) );		DBG_DisposePtr((Ptr)tString);		ForeColor(blackColor);		BackColor(whiteColor);	}		// so there, punk. Draw the friggin back arrow.	DrawPictureID( kBackArrowPict, cbData->baRect );		SetPort( oldPort );}void SetUpDrawProcs() {	MRPrefs mp = GetCurrentPrefs();		// If they have compatbile draws on, use quickdraw.	// This will be good for future machines, and I can also run MR	// under MAE this way. Which kicks. (!!!)	if (mp.compatibleDraws) {			MOFFDRAWPROC  = SWStdWorldDrawProc;		MONDRAWPROC = SWStdWorldDrawProc;		MTILEDRAWPROC = SWStdWorldDrawProc;		MSPRITEDRAWPROC = SWStdSpriteDrawProc;		MPLAYDRAWPROC = SWStdSpriteDrawProc;		MOFFDRAWPROCINT = SWStdWorldDrawProc;		MONDRAWPROCINT = SWStdWorldDrawProc;		MTILEDRAWPROCINT = SWStdWorldDrawProc;		MSPRITEDRAWPROCINT = SWStdSpriteDrawProc;		MPLAYDRAWPROCINT = SWStdSpriteDrawProc;			} else {			MOFFDRAWPROC  = BlitPixie8BitRectDrawProc;		MONDRAWPROC = BlitPixie8BitRectDrawProc;		MTILEDRAWPROC = BlitPixie8BitPartialMaskDrawProc;		MSPRITEDRAWPROC = BlitPixie8BitMaskDrawProc;		MPLAYDRAWPROC = BlitPixie8BitRectDrawProc;		MOFFDRAWPROCINT = BP8BitInterlacedRectDrawProc;		MONDRAWPROCINT = BP8BitInterlacedRectDrawProc;		MTILEDRAWPROCINT = BP8BitInterlacedPartialMaskDrawProc;		MSPRITEDRAWPROCINT = BP8BitInterlacedMaskDrawProc;		MPLAYDRAWPROCINT = BP8BitInterlacedRectDrawProc;		}}int RunMapRoom( WindowPtr wind ) {	// create the callback data.	MapCBInfo cbData;	OSErr err;	short	theQuitLevel = 0;		// Draw Procs are fun	SetUpDrawProcs();		// prepare to use spriteworld	err = SWEnterSpriteWorld();	ErrorCheck( err, "SWEnterSpriteWorld", true );		// fade in here only for debug	// FadeIn();		// make the callback data	cbData = MakeMapCBData( wind );	// the cb data shouldn't be NULL.	if ( cbData == NULL )		return kMapBackReturn;			// interface with the MRLoop.h unit.	PrepareEventLoop();		// draw the maproom interface	DrawMapRoom( cbData );	// run the spriteworld at least once, to flush out any auto-updates	// involving the current player.	SWProcessScrollingSpriteWorld( cbData->mapWorld );	SWAnimateScrollingSpriteWorld( cbData->mapWorld );	// fade in the screen:	FadeIn();			// cursor stuff	ShowCursor();	ObscureCursor();		(void) SWCreateCrossFadeTable();		// Start the music a-playin!	PlayMusic( kMapRoomMusic, true );		// run the event loop	MREventLoop( (MRUData) cbData );	SWDisposeCrossFadeTable();		// fix up the key-related stuff	MRRestoreKeyUp();		// fade the music, stop it	FadeMusicOut();	StopMusic();		HideCursor();			WipeWindowFX( wind );		// fade out the screen:	FadeOutImmediate();		ShowCursor();		// remember the quit-level, if any	if ( cbData->quitForLevel )		theQuitLevel = cbData->levelNumber;		// kill the cbdata!	DestroyMapCBData( cbData );	 	// okay, we love you, buh-bye!	SWExitSpriteWorld();		// erase it!	FillRect( &wind->portRect, &qd.black );		// release sound related memories	FlushAllSounds();		if ( theQuitLevel )		return (kMapPlayReturn + theQuitLevel);	else		return kMapBackReturn;}
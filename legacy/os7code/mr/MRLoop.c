// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRLoop.c// Auth: Dave Peck// Date: 7/8/97 (one day after wisdom tooth extraction!)// Desc: Main event loop for Murphy's Revenge; usable for any game state.// ----------------------------------------------------------------// Includes// ----------------------------------------------------------------#include "MRLoop.h"#include "MRSound.h"#include "SWGameUtils.h"#include "MRInit.h"#include "MacColorOff.h"#include "MRGfxUtils.h"// ----------------------------------------------------------------// Constants// ----------------------------------------------------------------#define APPLE_MENU_ID		300#define FILE_MENU_ID		301#define QUIT_ITEM			3#define PLAY_ITEM			1#define kMRSmallwindPict	21314// ----------------------------------------------------------------// Data Structures// ----------------------------------------------------------------// ----------------------------------------------------------------// Global Data// ----------------------------------------------------------------MRClickPtr 		loop_clickBack;MRKeyPtr		loop_keyBack;MRIdlePtr		loop_idleBack;MRUpdatePtr		loop_updateBack;MRKeyUpDownPtr  loop_keyUpDownBack;unsigned long	loop_sleepTime, loop_oldSleepTime;Boolean			loop_keyUp;Boolean			loop_userForcedQuit;Boolean			loop_allowSwitches;Boolean			loop_switchedOut;MenuHandle		loop_appleMenu, loop_fileMenu;WindowPtr		loop_switchWind;WindowPtr		loop_beforeSwitchWind;GWorldPtr		loop_windowContents;Rect			loop_monRect;// ----------------------------------------------------------------// Function Prototypes// ----------------------------------------------------------------// ----------------------------------------------------------------// Functions// ----------------------------------------------------------------void MRSetMonRect(Rect monRect) {	loop_monRect = monRect;}void MRLoopPrepare() {	// do that funky force quit init.	loop_userForcedQuit = false;		// and don't allow app switches	loop_allowSwitches = false;		// and we're not switched out. At least, I hope not.	loop_switchedOut = false;	loop_switchWind = NULL;}void MRAllowSwitches( Boolean doAllow ) {	loop_allowSwitches = doAllow;}void MRCreateMenus() {	// the apple menu	loop_appleMenu = GetMenu( APPLE_MENU_ID );	AppendResMenu( loop_appleMenu, 'DRVR' );	MoveHHi( (Handle) loop_appleMenu );	HLock( (Handle) loop_appleMenu );	InsertMenu( loop_appleMenu, 0 );		// the file menu	loop_fileMenu = GetMenu( FILE_MENU_ID );	MoveHHi( (Handle) loop_fileMenu );	HLock( (Handle) loop_fileMenu );	InsertMenu( loop_fileMenu, 0 );			// draw that bar	DrawMenuBar();}void MRDestroyMenus() {	//DisposeMenu( loop_appleMenu );	//DisposeMenu( loop_fileMenu );}void SwitchOutUpdate() {	Rect drawRect;	GrafPtr oldPort;		if ( !loop_switchedOut )		return;			GetPort( &oldPort );	SetPort( loop_switchWind );	FillRect( &loop_switchWind->portRect, &qd.black );	// draw the MR icon in it!	SetRect( &drawRect, 0, 0, 32, 32 );	DrawPictureID( kMRSmallwindPict, drawRect );		SetPort( oldPort );}void SwitchOut() {	// switching out is kinda strange.	// basically take the main window, kill it, 	// and create a new small window at the bottom left corner of the 	// main window.	WindowPtr 	currentWindow;	Rect		drawRect, centeredRect;		if ( loop_switchedOut )		return;			// figure out the window to hide	GetPort( &currentWindow );	loop_beforeSwitchWind = currentWindow;		// make a restorable gworld info thang.	SetRect( &drawRect, 0, 0, 640, 480 );	centeredRect = drawRect;	CenterRect( &centeredRect, &currentWindow->portRect );		// can't just ignore result!	(void) MacMakeGWorld( drawRect, &loop_windowContents ); 	if ( loop_windowContents )		CopyOffToOffRect( (GWorldPtr) currentWindow, false,						  loop_windowContents, true,						  centeredRect, drawRect );	else		SysBeep(5);				  	// drop the menu bar up on screen:	ShowMenuBar( currentWindow );		// draw it	DrawMenuBar();		// hide the window	HideWindow( currentWindow );		// make a phony fun window	loop_switchWind = GetNewCWindow( kMainWindID, NULL, kBringToFront );	MoveWindow( loop_switchWind, loop_monRect.left+2, loop_monRect.bottom-34, true );	SizeWindow( loop_switchWind, 32, 32, false );	ShowWindow( loop_switchWind );	SetPort( loop_switchWind );	ForeColor( blackColor );	FillRect( &loop_switchWind->portRect, &qd.black );	// draw the MR icon in it!	SetRect( &drawRect, 0, 0, 32, 32 );	DrawPictureID( kMRSmallwindPict, drawRect );		// fun repeat.	DrawMenuBar();		// show cursor	ShowCursor();		// switched out!	loop_switchedOut = true;	loop_oldSleepTime = loop_sleepTime;	loop_sleepTime = 0x10;}void SwitchIn() {	Rect fromRect, toRect;		if (!loop_switchedOut)		return;		// hide cursor	HideCursor();			// kill the phony window	DisposeWindow( loop_switchWind );	loop_switchWind = NULL;		// show the big wind	ShowWindow( loop_beforeSwitchWind );	SetPort( loop_beforeSwitchWind );		// hide the menubar	HideMenuBar( loop_beforeSwitchWind );		// blacken and restore contents	if ( loop_windowContents ) {		FillRect( &loop_beforeSwitchWind->portRect, &qd.black );		SetRect( &fromRect, 0, 0, 640, 480 );		toRect = fromRect;		CenterRect( &toRect, &loop_beforeSwitchWind->portRect );		CopyWorldBits( loop_windowContents, loop_beforeSwitchWind, fromRect, toRect );				// now destroy the offscreen		DestroyGWorld( &loop_windowContents );	}		// we're not switched out	loop_switchedOut = false;	loop_sleepTime = loop_oldSleepTime;}void MRClearCallbacks() {	loop_clickBack = NULL;	loop_keyBack = NULL;	loop_keyUpDownBack = NULL;	loop_idleBack = NULL;	loop_updateBack = NULL;	loop_sleepTime = kDefaultSleepTime;	loop_keyUp = false;}void MRSetSleepTime( unsigned long newSleepTime ) {	loop_sleepTime = newSleepTime;}void MRSetClickCallback( MRClickPtr clickBack ) {	loop_clickBack = clickBack;}void MRSetKeyCallback( MRKeyPtr keyBack ) {	loop_keyBack = keyBack;}void MRSetIdleCallback( MRIdlePtr idleBack ) {	loop_idleBack = idleBack;}void MRSetUpdateCallback( MRUpdatePtr updateBack ) {	loop_updateBack = updateBack;}void MRSetKeyUpDownCallback( MRKeyUpDownPtr keyBack ) {	loop_keyUpDownBack = keyBack;}Boolean Loop_ProcessEvent( EventRecord theEvent, MRUData callbackData ) {	int				winClickLocation,		// which part of a window was clicked?					menuIDSelected,			// the menu ID selected					menuItemSelected;		// the menu item selected	WindowPtr		clickedWindow;			// the window which was clicked	long			illogicalMenuInfo;		// see below. It's Apple's fault.	Str255			itemName;				// Text of menu item selected...	GrafPtr			oldGrafPort;			// Old graphics port before a change.	Boolean			goingActive;			// TRUE if a window is becoming active.	char			charPressed;			// The character pressed in a keydown	int				charModifiers;			// Modifiers to a character pressed...	Boolean			retVal = false;		// Before doing standard event stuff, we want to update our menus.	//UpdateMenus();			// What kind of event?	switch ( theEvent.what )	{		case nullEvent:			if (loop_idleBack && !loop_switchedOut)				retVal |= (*loop_idleBack)( theEvent.modifiers, callbackData );			break;				case mouseDown:			// Determine which window, and where in that window, was clicked			winClickLocation = FindWindow( theEvent.where, &clickedWindow );						// Now do something about it			switch ( winClickLocation )			{				case inContent:					// In Content: clicked inside the window's frame					if ( FrontWindow() == clickedWindow )					{						// The window that was clicked is in the foreground already.						// That means that the user probably wants to interact with						// that window's contents, so we pass the message along...												// First, we have to convert the coordinate to the window's local system						GlobalToLocal( &(theEvent.where) );												// NOW PASS IT ALONG, unless we're in allow switches mode:						if ( loop_allowSwitches ) {							// should switch out here							if ( loop_switchedOut )								SwitchIn();							else								SwitchOut();						} else if (loop_clickBack && !loop_switchedOut)							retVal |= (*loop_clickBack) (theEvent.where, theEvent.modifiers, callbackData );											}					else					{						// The user clicked the contents of a non-foreground window.						// And they weren't draggin'!						// Simply move it into the foreground.						SetPort( clickedWindow );						SelectWindow( clickedWindow );						if ( loop_allowSwitches && loop_switchedOut )							SwitchIn();												}					break;													case inDrag:					// In Drag: the top bar of the window which allows click-drags					DragWindow( clickedWindow, theEvent.where, &qd.screenBits.bounds );					break;				case inSysWindow:					// this is an outmoded pre system-7ish thing, because a sysWindow					// really means a DA. In fact, this dates back to MiniFinder in					// system four. But we do it for whatever sense of goodness we					// happen to have in our hearts.					SystemClick( &theEvent, clickedWindow );					break;													case inGoAway:					// The goAway box is that top-left box in most windows.					// They clicked on it...					//if ( TrackGoAway( clickedWindow, theEvent.where ) ) {					//	if (loop_closeBack)					//		(*loop_closeBack)( clickedWindow, callbackData );					//}					break;													case inGrow:				case inZoomIn:				case inZoomOut:					// For windows with grow boxes (bot right) and zoom boxes					break;									case inMenuBar:					// Note for MR: I took out some of this code and made it do nothing.					// MR doesn't use menus. -dkp									// You'll like this one. Apple, being the clever company that					// it is, decided to use FindWindow to determine if the					// user clicked in the menu bar. Um, hello Apple?					// Oh well, we handle it accordingly.										// In order to increase strangeness, apple introduced a function					// called MenuSelect which returns a long, the HiWord of which is					// a menuID if a menu really was selected (don't ask,) and the					// LoWord of which is actually the menu item selected. Gee, we					// make sense, don't we?										// Grab that information...					illogicalMenuInfo = MenuSelect( theEvent.where );										// Now figure out the menu's ID					menuIDSelected = HiWord( illogicalMenuInfo );										// Only go further if we got a valid menu, which Apple					// says it doesn't guarantee. I'd sure love to take a peek					// at the beautiful code behind their system software.					if ( menuIDSelected != 0 )							{						// First, make that menu look like it is selected						HiliteMenu( menuIDSelected );												// and now determine which item inside that menu was picked						menuItemSelected = LoWord( illogicalMenuInfo );																		if ( menuIDSelected == APPLE_MENU_ID )						{							// The user selected something in the apple menu.							// I don't really understand the logic behind this, but							// Apple needs it this way, so we obey.														// Get the text of the menu item selected.							GetMenuItemText( loop_appleMenu, menuItemSelected, itemName );														// Open the desk accessory (DA), or whatever...							// We're ignoring the return value, a boolean, which							// Apple says has no meaning under system 7. How useful.							OpenDeskAcc( itemName );						}							else if ( menuIDSelected == FILE_MENU_ID && loop_switchedOut ) {							// handle the file menu directly -- in MR							// it's pretty easy.							if ( menuItemSelected == PLAY_ITEM )								SwitchIn();							else {								// wierder: switch in then quit								SwitchIn();								loop_userForcedQuit = true;							}						}																		// Now turn off the menu's hilite						HiliteMenu( 0 );					}	// MenuIDSelected != 0					break;	// For inMenuBar mouseDown													}	// End Of Switch for WinClickLocation...			break;		// For the mouseDown event										case updateEvt:			// We need to draw some, or possibly all, of a window's contents.			// First, remember the current graphics port			GetPort( &oldGrafPort );						// Now set the port to that of the window which we are updating			SetPort( (WindowPtr) theEvent.message );						// Let the system know we are updating that window			BeginUpdate( (WindowPtr) theEvent.message );						// Call the appropriate window-updating routine			if (loop_updateBack && !loop_switchedOut)				retVal |= (*loop_updateBack)( (WindowPtr) theEvent.message, callbackData );			else if ( loop_switchedOut && loop_switchWind == (WindowPtr) theEvent.message )				SwitchOutUpdate();							// Let the system know we're done...			EndUpdate((WindowPtr)(theEvent.message));						// Set the port back to its previous state			SetPort( oldGrafPort );			break;								case activateEvt:			// this means that a window is either going into the foreground,			// or coming up from the background. First, figure out which way...						// Yes, this mess uses a bitand operator.			goingActive = ( ( (theEvent.modifiers) & (activeFlag) ) !=0 );			break;		case osEvt:			// Check for suspend/resume, disk insertion, yadda yadda			//if (((theEvent.message >> 24) & 0xFF) == suspendResumeMessage)			//	Event_SuspendResume(theEvent.message & resumeFlag);			break;					case keyDown:		case keyUp:			// A key was pressed. We need to know what character was pressed,			// and what modifiers (shift, command, etc.) were pressed at the same time...			charPressed = (char) ( ( theEvent.message ) & ( charCodeMask ) );			charModifiers = theEvent.modifiers;						// check for cmd-Q (quit!)			if ( (charModifiers & cmdKey) && (charPressed == 'q' || charPressed == 'Q') ) {				loop_userForcedQuit = true;				if ( loop_switchedOut ) {					SwitchIn();					return false;				}			}						// No special situations, so if the wind is up front,			// pass the info onto it.			if ((loop_keyUp) && (loop_keyUpDownBack) && !loop_switchedOut)				retVal |= (*loop_keyUpDownBack)( charPressed, charModifiers, callbackData,												 (theEvent.what == keyUp ) );			else if (loop_keyBack && !loop_switchedOut)				retVal |= (*loop_keyBack)( charPressed, charModifiers, callbackData );			break;	} // End switch of events		return retVal;} // End routine.void MREventLoop( MRUData callbackData ) {	Boolean 		loopFinished = false;	Boolean			eventIsOurs;		// TRUE if we should process the event	EventRecord 	theEvent;			// the event we recieved, if any	short			theMask = everyEvent;	// flush all events	FlushEvents( everyEvent, 0 );	// check for keyup allowed	if ( loop_keyUp )		theMask |= keyUpMask;			while ( !loopFinished ) {		// First, get the event from the system, if any is available		KeepMusicGoing();				if ( loop_sleepTime != 0 ) {			eventIsOurs = WaitNextEvent( theMask, &theEvent, 										 loop_sleepTime, NULL );		} else {			if ( OSEventAvail( theMask, &theEvent ) )				eventIsOurs = WaitNextEvent( theMask, &theEvent, 1, NULL );		}				KeepMusicGoing();		// if the event is ours, or if the system is just idle, then call our processor		if ( ( eventIsOurs ) || ( theEvent.what == nullEvent ) )			loopFinished = Loop_ProcessEvent( theEvent, callbackData );					loopFinished |= loop_userForcedQuit;	}}void MRAllowKeyUp() {	if (!loop_keyUp)		AllowKeyUpEvents();	loop_keyUp = true;}void MRRestoreKeyUp() {	if ( loop_keyUp )		RestoreEventMask();	loop_keyUp = false;}
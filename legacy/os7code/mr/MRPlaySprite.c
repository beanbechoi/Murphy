// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRPlaySprite.c// Auth: Dave Peck// Date: 7/3/98// Desc: Code to deal with smoothly moving game objects in level play.// -----------------------------------------------------------------------------// Includes// -----------------------------------------------------------------------------#include "MRPlayCommon.h"#include "MRPlaySprite.h"#include "MRChore.h"// -----------------------------------------------------------------------------// Constants// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Data Structures// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Global Data// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Function Prototypes// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Functions// -----------------------------------------------------------------------------// spriteworld callback procsvoid _sprite_SWFrameProc( SpritePtr theSprite, FramePtr curFrame, long *frameIndex ) {	MRSpriteTag theTag = (MRSpriteTag) theSprite->userData;	LevelCBInfo cbData = theTag->cb;		if ( theSprite->spriteRemoval == kSWRemoveAndDisposeSprite ||		 theSprite->spriteRemoval == kSWRemoveSprite )		return;	if ( theTag == NULL )		return;			(*((MRSpriteFrameProcPtr) theTag->frameProc)) 		( cbData, theTag, theSprite, curFrame, frameIndex );}void _sprite_SWMoveProc( SpritePtr theSprite ) {	LevelCBInfo cbData;	MRSpriteTag theTag;	short row, col;		if ( theSprite->spriteRemoval == kSWRemoveAndDisposeSprite ||		 theSprite->spriteRemoval == kSWRemoveSprite )		return;		row = theSprite->destFrameRect.top / kLevelItemSize;	col = theSprite->destFrameRect.left / kLevelItemSize;		if ( (row * kLevelItemSize == theSprite->destFrameRect.top) &&		 (col * kLevelItemSize == theSprite->destFrameRect.left) ) {				theTag = (MRSpriteTag) theSprite->userData;		if ( theTag == NULL )			return;		cbData = theTag->cb;				(*((MRSpriteMoveProcPtr) theTag->moveProc))			( cbData, theTag, theSprite, row, col );	}		if ( theSprite->spriteRemoval != kSWRemoveAndDisposeSprite &&		 theSprite->spriteRemoval != kSWRemoveSprite )		SWOffsetSprite( theSprite, theSprite->horizMoveDelta, theSprite->vertMoveDelta );}// low level sprite tag allocation routinesMRSpriteTag _sprite_AllocTag( LevelCBInfo cbData ) {	MRSpriteTag theTag = (MRSpriteTag) DBG_NewPtrClear( sizeof( struct MRSpriteTagStruct ) );		theTag->cb = cbData;		return theTag;}MRSpriteTag _sprite_AllocTagCommon( short spriteType,									LevelCBInfo cbData,									Point loc,									MRSpriteFrameProcPtr frameProc,									MRSpriteMoveProcPtr moveProc,									MRSpriteMoveProcPtr moveDoneProc ) {										MRSpriteTag theTag = _sprite_AllocTag( cbData );	short spriteTile;	spriteTile = cbData->tiles[loc.v][loc.h];		theTag->tileID = spriteTile;	theTag->loc = loc;	theTag->spriteType = spriteType;	theTag->frameProc = (Ptr) frameProc;	theTag->moveProc = (Ptr) moveProc;	theTag->moveDoneProc = (Ptr) moveDoneProc;	GetPieceKind( &(theTag->theKind), spriteTile );			return theTag;}									MRSpriteTag _sprite_AllocTagCommonHV( short spriteType,									  LevelCBInfo cbData,									  short h, short v,   // col, row									  MRSpriteFrameProcPtr frameProc,									  MRSpriteMoveProcPtr moveProc,									  MRSpriteMoveProcPtr moveDoneProc ) {										MRSpriteTag theTag = _sprite_AllocTag( cbData );	short spriteTile;		spriteTile = cbData->tiles[v][h];	theTag->tileID = spriteTile;	theTag->loc.h = h;	theTag->loc.v = v;	theTag->spriteType = spriteType;	theTag->frameProc = (Ptr) frameProc;	theTag->moveProc = (Ptr) moveProc;	theTag->moveDoneProc = (Ptr) moveDoneProc;	GetPieceKind( &(theTag->theKind), spriteTile );			return theTag;}void _sprite_FrameFromTile( SpriteWorldPtr sw, SpritePtr theSprite, short tileID ) {	// this routine is a SW-hack that adds a frame with the same	// appearance as that of the given tileID to the requested sprite.	// it requires explicit knowledge of the tile frame arrays.	FramePtr	newFrame;	FramePtr	dupFrame;	Rect		imageRect;		// prepare by finding the correct frame & initing the image rectangle	dupFrame = sw->tileFrameArray[ tileID ];	imageRect = dupFrame->frameRect;		// create the new frame. It knows that it shares a GWorld.	(void)SWCreateFrameFromGWorldAndRect( &newFrame, 										  dupFrame->framePort,										  NULL,										  &imageRect,										  kNoMask );		// add the frame.	SWAddFrame( theSprite, newFrame );}SpritePtr _sprite_AllocSWSprite( LevelCBInfo cbData,								 MRSpriteTag theTag, 								 void* spriteStorage, 								 short maxFrames,								 long frameTimeInterval ) {	SpritePtr newSprite;	MRPrefs mp = GetCurrentPrefs();		(void) SWCreateSprite( &newSprite, spriteStorage, maxFrames );		// Set useful info.	SWSetSpriteMoveProc( newSprite, _sprite_SWMoveProc );	SWSetSpriteLocation( newSprite, theTag->loc.h*kLevelItemSize, 									theTag->loc.v*kLevelItemSize );	newSprite->userData = (long) theTag;		// Set the sprite drawproc.	if ( mp.interlacedMode )		SWSetSpriteDrawProc( newSprite, SPRITEDRAWPROCINT() );	else		SWSetSpriteDrawProc( newSprite, SPRITEDRAWPROC() );		// the frame-change proc information:	SWSetSpriteFrameTime( newSprite, frameTimeInterval );	// kSpriteFrameMilli	SWSetSpriteFrameRange( newSprite, 0, maxFrames-1 );	SWSetSpriteFrameProc( newSprite, _sprite_SWFrameProc );		// for speed, make it "above" everything.	SWSetSpriteUnderTiles( newSprite, false );	// add sprite to the animation!	// SWLockSprite( newSprite );	if ( theTag->spriteType == kPushSpriteType )		SWInsertSpriteAfterSprite( cbData->sLayer, newSprite, cbData->oliverSprite );	else		SWAddSprite( cbData->sLayer, newSprite );			return newSprite;		}Boolean _sprite_CanRoll( LevelCBInfo cbData, short row, short col,				   		 short dRow, short dCol, Boolean checkOliver ) {	Point	oliverLoc;	short 	rollTopTile, rollBotTile;		if ( cbData->oliverSprite ) {		MRSpriteTag oliverTag = (MRSpriteTag) cbData->oliverSprite->userData;		oliverLoc = oliverTag->loc;	} else {		oliverLoc.h = 0;		oliverLoc.v = 0;	}	rollTopTile = cbData->tiles[row][col+dCol];	rollBotTile = cbData->tiles[row+dRow][col+dCol];		if ( checkOliver )		return ( rollTopTile == kBlankTile && 				 rollBotTile == kBlankTile && 				 ( oliverLoc.h != col+dCol ||				   oliverLoc.v != row ) );	else		return ( rollTopTile == kBlankTile &&				 rollBotTile == kBlankTile );}// MR frame procsvoid _frame_Default( LevelCBInfo cbData,					 MRSpriteTag theTag,					 SpritePtr theSprite, 					 FramePtr curFrame, long *frameIndex ) {	(*frameIndex) += 1;		if ((*frameIndex) >= theSprite->maxFrames)		(*frameIndex) = 0;}void _frame_Scissor( LevelCBInfo cbData,					 MRSpriteTag theTag,					 SpritePtr theSprite, 					 FramePtr curFrame, long *frameIndex ) {					 	if ( theTag->info.scissor.isTurning && theTag->info.scissor.turnedCount == 0 ) {		// figure out the necessary frame based on 		// turningTo, clockwiseTurn, and facing:		if ( theTag->info.scissor.clockwiseTurn ) {			*frameIndex = (theTag->info.scissor.facing*4)-1;		} else {			*frameIndex = ((theTag->info.scissor.facing-1)*4)-1;			if (*frameIndex < 0)				*frameIndex = 15;		}				theTag->info.scissor.internalDir = 1;		theTag->info.scissor.internalFrame = 0;	}		else if ( theTag->info.scissor.isTurning ) {		// draw a closed sprite in turningTo direction		*frameIndex = ((theTag->info.scissor.turningTo-1)*4);	}		else if ( theTag->info.scissor.facing == theTag->info.scissor.lastFacing ) {		theTag->info.scissor.internalFrame += theTag->info.scissor.internalDir;		if ( theTag->info.scissor.internalFrame < 0 || theTag->info.scissor.internalFrame > 2 ) {			theTag->info.scissor.internalDir = - (theTag->info.scissor.internalDir);			theTag->info.scissor.internalFrame += theTag->info.scissor.internalDir;		}			*frameIndex = theTag->info.scissor.internalFrame + theTag->info.scissor.baseFrame;	} else {		theTag->info.scissor.baseFrame = (theTag->info.scissor.facing-1)*4;		theTag->info.scissor.internalDir = 1;		theTag->info.scissor.internalFrame = 0;		theTag->info.scissor.lastFacing = theTag->info.scissor.facing;				*frameIndex = theTag->info.scissor.internalFrame + theTag->info.scissor.baseFrame;	}}void _frame_Oliver_DeathAnim( LevelCBInfo cbData,							  MRSpriteTag theTag,							  SpritePtr theSprite,							  FramePtr curFrame, long *frameIndex ) {	(*frameIndex) = theTag->info.oliver.oliverFrame;	(theTag->info.oliver.oliverFrame)++;	if ( theTag->info.oliver.oliverFrame > theTag->info.oliver.oliverFinalFrame ) {		// can safely remove this sprite:		SWRemoveSpriteFromAnimation( cbData->sw, theSprite, true );		cbData->oliverSprite = NULL;	}}void _frame_Oliver_Yawn( LevelCBInfo cbData,						 MRSpriteTag theTag,						 SpritePtr theSprite,						 FramePtr curFrame, long *frameIndex,						 long timeSincePress ) {	if ( timeSincePress > kYawnDelay ) {		(*frameIndex) = theTag->info.oliver.oliverFrame;		theTag->info.oliver.oliverFrame += 1;		if (*frameIndex > kYawnBubLastFrame) {			theTag->info.oliver.oliverFrame = kYawnBubLastFrame;			*frameIndex = kYawnBubLastFrame;		}	} else if ( timeSincePress > kSadStartTicks && timeSincePress <= kSadEndTicks ) {		(*frameIndex) = kSadBubFrame;	} else if ( timeSincePress > kFUStartTicks && timeSincePress <= kFUEndTicks ) {		(*frameIndex) = kFuckYouBubFrame;	} else if ( timeSincePress > kEurekaStartTicks && timeSincePress <= kEurekaEndTicks ) {		(*frameIndex) = kEurekaBubFrame;	}}void _frame_Oliver_Push( LevelCBInfo cbData,						 MRSpriteTag theTag,						 SpritePtr theSprite,						 FramePtr curFrame, long *frameIndex ) {	(*frameIndex) = theTag->info.oliver.oliverFrame + theTag->info.oliver.oliverFrameDir;	theTag->info.oliver.oliverFrameDir += 1;	if (*frameIndex == theTag->info.oliver.oliverFinalFrame)		theTag->info.oliver.oliverFrameDir = 0;}void _frame_Oliver_ExLax( LevelCBInfo cbData,						  MRSpriteTag theTag,						  SpritePtr theSprite,						  FramePtr curFrame, long *frameIndex ) {	(*frameIndex) = theTag->info.oliver.oliverFrame;	(theTag->info.oliver.oliverFrame) += 1;	if ((theTag->info.oliver.oliverFrame) > kExLaxBubLastFrame)		(theTag->info.oliver.oliverFrame) = kExLaxBubFirstFrame;}void _frame_Oliver_NoMotion( LevelCBInfo cbData,						     MRSpriteTag theTag,						     SpritePtr theSprite,						     FramePtr curFrame, long *frameIndex ) {	// if we weren't in static mode last time,	// switch to it, with a little hack to force	short newAxis;		// standard oliver (frame zero) to reappear first.	if ( theTag->info.oliver.oliverAnimState != kStaticAnimState ) {		theTag->info.oliver.oliverAnimState = kStaticAnimState;		theTag->info.oliver.oliverFrameDir = kBackToStandardDir;		(*frameIndex) = 1;	}			// happily bubble along.	if ( (*frameIndex) == 0 ) {		newAxis = GetRandom( 0, 3 );		(*frameIndex) = 1 + (2*newAxis); 		theTag->info.oliver.oliverFrameDir = kIntoBubbleDir;	} else if ( theTag->info.oliver.oliverFrameDir == kIntoBubbleDir ) {		(*frameIndex) += 1;		theTag->info.oliver.oliverFrameDir = kOutFromBubbleDir;	} else if (theTag->info.oliver.oliverFrameDir == kOutFromBubbleDir ) {		(*frameIndex) -= 1;		theTag->info.oliver.oliverFrameDir = kBackToStandardDir;	} else if ( theTag->info.oliver.oliverFrameDir == kBackToStandardDir ) {		(*frameIndex) = 0;		theTag->info.oliver.oliverFrameDir = kNoAnimDir;	}}void _frame_Oliver_Motion( LevelCBInfo cbData,						   MRSpriteTag theTag,						   SpritePtr theSprite,						   FramePtr curFrame, long *frameIndex ) {	// some local variables	short	lastMotionDir = theTag->info.oliver.oliverMotionDir;		// coming out of a non-moving mode?	if (theTag->info.oliver.oliverAnimState != kMovingAnimState ) {		// you're not in static mode anymore, Dorothy.		theTag->info.oliver.oliverAnimState = kMovingAnimState;					// set the frame correctly		if ( theTag->info.oliver.oliverMotionDir == kLeftMotionDir )			(theTag->info.oliver.oliverFrame) = 9;		else			(theTag->info.oliver.oliverFrame) = 12;				// and the frame dir		theTag->info.oliver.oliverFrameDir = -1;	}		// if they're moving left/right, set the motion dir	// to make oliver face that way.	// if up/down, we simply let oliver face the last way he did.	if ( theTag->info.oliver.oliverMotion.v == 0 ) {		if ( theTag->info.oliver.oliverMotion.h < 0 )			theTag->info.oliver.oliverMotionDir = kLeftMotionDir;		else			theTag->info.oliver.oliverMotionDir = kRightMotionDir;	}		// if the motion dir changed, the frame index did too	if ( theTag->info.oliver.oliverMotionDir != lastMotionDir ) {		if ( theTag->info.oliver.oliverMotionDir == kLeftMotionDir )			(theTag->info.oliver.oliverFrame) = 9;		else			(theTag->info.oliver.oliverFrame) = 12;		theTag->info.oliver.oliverFrameDir = -1;	}		// increment the frame dir	(theTag->info.oliver.oliverFrameDir)++;		// check for bounds:	if ( theTag->info.oliver.oliverFrameDir > 2 )		theTag->info.oliver.oliverFrameDir = 0;			// and set the frame index accordingly	(*frameIndex) = theTag->info.oliver.oliverFrame + theTag->info.oliver.oliverFrameDir;}void _frame_Oliver(  LevelCBInfo cbData,					 MRSpriteTag theTag,					 SpritePtr theSprite, 					 FramePtr curFrame, long *frameIndex ) {	short newAxis;	long timeSincePress;		timeSincePress = TickCount() - cbData->lastPressTime;		// if we're in the kDeathAnimState, die.    if ( theTag->info.oliver.oliverAnimState == kDeathAnimState )     	_frame_Oliver_DeathAnim( cbData, theTag, theSprite, curFrame, frameIndex );		// check to see if we're bored!	else if ( theTag->info.oliver.oliverAnimState != kYawnAnimState &&			  timeSincePress > kSadStartTicks ) {		theTag->info.oliver.oliverAnimState = kYawnAnimState;		theTag->info.oliver.oliverFrame = kYawnBubFirstFrame;	}		// yawning?	else if ( theTag->info.oliver.oliverAnimState == kYawnAnimState && 			  timeSincePress > kSadStartTicks )		_frame_Oliver_Yawn( cbData, theTag, theSprite, curFrame, frameIndex, timeSincePress );		// pushing?	else if ( theTag->info.oliver.isPushing && 			  theTag->info.oliver.oliverAnimState == kPushAnimState )		_frame_Oliver_Push( cbData, theTag, theSprite, curFrame, frameIndex );				// just finished a push?	else if ( theTag->info.oliver.pushHack ) {		_frame_Oliver_Push( cbData, theTag, theSprite, curFrame, frameIndex );		theTag->info.oliver.pushHack = false;	}		// did a zap?	else if ( theTag->info.oliver.didZap && 			  TickCount() - theTag->info.oliver.startAnim <= kZapFreezeTicks )		(*frameIndex) = theTag->info.oliver.oliverFrame;		// in a special-key anim state?	else if ( theTag->info.oliver.specialAnim && 			  theTag->info.oliver.oliverAnimState == kZapAnimState )		(*frameIndex) = theTag->info.oliver.oliverFrame;		// what about the RD special anim state?	else if ( theTag->info.oliver.specialAnim && 			  theTag->info.oliver.oliverAnimState == kRDAnimState ) 		_frame_Oliver_ExLax( cbData, theTag, theSprite, curFrame, frameIndex );		// if there is no motion, go into the static animation state.	else if ( theTag->info.oliver.oliverMotion.h == 0 && 			  theTag->info.oliver.oliverMotion.v == 0 ) 		_frame_Oliver_NoMotion( cbData, theTag, theSprite, curFrame, frameIndex );		// okay, there is motion. 	else 		_frame_Oliver_Motion( cbData, theTag, theSprite, curFrame, frameIndex );}// MR move procsvoid _move_Fall_CheckFurtherMotion( LevelCBInfo cbData,									MRSpriteTag theTag,									short row, short col ) {	// check here to see if i should/can roll:	short	rollTopTile, rollBotTile;		if ( _sprite_CanRoll( cbData, row, col, 					theTag->info.fall.fallRowDelta, 					cbData->nextRollDirection, true) ) {							MakeSprite_Roll( cbData, row, col, cbData->nextRollDirection,						 theTag->info.fall.fallRowDelta );		cbData->nextRollDirection = -(cbData->nextRollDirection);			} else if ( _sprite_CanRoll( cbData, row, col,						   theTag->info.fall.fallRowDelta,						   -(cbData->nextRollDirection), true) ) {		MakeSprite_Roll( cbData, row, col, -(cbData->nextRollDirection),						 theTag->info.fall.fallRowDelta );		cbData->nextRollDirection = -(cbData->nextRollDirection);	}}void _move_Fall( LevelCBInfo cbData,					MRSpriteTag theTag,					SpritePtr theSprite,					short row, short col ) {	short		nextFallTile;	PieceKind	nextFallKind;		if ( theTag->info.fall.firstFall ) {		theTag->info.fall.firstFall = false;		return;	}		// first we blank our old position. (this erases the phantom & gets other things	// falling/rolling, if necessary.)	DrawLevelTile( cbData->sw, row - theTag->info.fall.fallRowDelta, col, kBlankTile );		// then we determine what is at our next space	nextFallTile = cbData->tiles[row+theTag->info.fall.fallRowDelta][col];	GetPieceKind( &nextFallKind, nextFallTile );		// if the next space is blank, we keep going.	if ( nextFallTile == kBlankTile )		DrawLevelTile( cbData->sw, row+theTag->info.fall.fallRowDelta, col, kPhantomTile );		// otherwise we have to stop	else {		Point 		explLoc;		Point		oliverLoc;		MRSpriteTag	oliverTag = NULL;				// play the thud snd - they're a bit lounder than most.		PlaySoundIDStereo( kThudSnd, (short)(ProximityToOliver( cbData, theTag->loc )/2),						   ProximityPanning( cbData, theTag->loc ) );				// we're there now!		DrawLevelTile( cbData->sw, row, col, theTag->tileID );				// where we're going:		explLoc.h = col;		explLoc.v = row + theTag->info.fall.fallRowDelta;				// if we landed on an ignitable piece, blow it up.		if ( nextFallKind.isIgnitable ) 			StartExplosion( cbData, explLoc, true );				explLoc.v = row;				// if we're ignitable, blow us up.		if ( theTag->theKind.isIgnitable )			StartExplosion( cbData, explLoc, true );				// get oliver loc		if ( cbData->oliverSprite )			oliverTag = (MRSpriteTag) cbData->oliverSprite->userData;					if ( oliverTag )			oliverLoc = oliverTag->loc;		else {			oliverLoc.h = -1;			oliverLoc.v = -1;		}				// what happens if i landed on - gasp! - oliver?		if ( oliverTag )			if ( col == oliverTag->loc.h && 				 row+theTag->info.fall.fallRowDelta == oliverTag->loc.v )				KillOliver( cbData->oliverSprite, false );				// if the thing below is a quark or scissor, blow it up:		if ( nextFallTile == kPhantomTile )			HitBottomCheck( cbData, row+theTag->info.fall.fallRowDelta, col );				if ( theTag->theKind.canRoll && nextFallKind.isRounded ) 			_move_Fall_CheckFurtherMotion( cbData, theTag, row, col );				// kill the tag		DBG_DisposePtr( (Ptr) theTag );		// this sprite is no longer needed:		SWRemoveSpriteFromAnimation( cbData->sw, theSprite, true );	}	}void _move_Roll( LevelCBInfo cbData,					MRSpriteTag theTag,					SpritePtr theSprite,					short row, short col ) {	short 	checkFallTile;	// fun roll. but we're done now.	DrawLevelTile( cbData->sw, row, col, theTag->tileID );	// don't forget to blank where we were, provided it is "blank" already:	if ( cbData->tiles[row][col-theTag->info.roll.rollColDelta] == kBlankTile )		DrawLevelTile( cbData->sw, row, col-theTag->info.roll.rollColDelta, kBlankTile );			// can we fall?	checkFallTile = cbData->tiles[row+theTag->info.roll.fallRowDelta][col];	if ( checkFallTile == kBlankTile ) 		MakeSprite_Fall( cbData, row, col, theTag->info.roll.fallRowDelta );		else if ( checkFallTile == kPhantomTile )		HitBottomCheck( cbData, row+theTag->info.roll.fallRowDelta, col );			// kill that sprite!	DBG_DisposePtr( (Ptr) theTag );	SWRemoveSpriteFromAnimation( cbData->sw, theSprite, true );	return;}void _move_Push_GoldDisk( LevelCBInfo cbData,					MRSpriteTag theTag,					SpritePtr theSprite,					short row, short col ) {	Point explLoc;	short nextTile;	PieceKind nextKind;	MRSpriteTag oliverTag = NULL;		if ( cbData->oliverSprite )		oliverTag = (MRSpriteTag) cbData->oliverSprite->userData;			oliverTag->info.oliver.isPushing = false;	oliverTag->info.oliver.pushHack = false;		// set explosion info	explLoc.h = col;	explLoc.v = row;		// what's the piece where we're heading?	nextTile = cbData->tiles[row+theTag->info.push.rowDelta][col+theTag->info.push.colDelta];	GetPieceKind( &nextKind, nextTile );	if ( nextKind.isExplodable && !nextKind.isIgnitable ) {		// keep a trail of fire going behind you.		StartExplosion( cbData, explLoc, false );		PlaySoundIDStereo( kExplodeSnd, ProximityToOliver( cbData, explLoc ),						   ProximityPanning( cbData, explLoc ) );	} else {		// hit the end of the road, so ignite a huge explosion and kill self.		StartExplosion( cbData, explLoc, true );		DBG_DisposePtr( (Ptr) theTag );		SWRemoveSpriteFromAnimation( cbData->sw, theSprite, true );	}}void _move_Push_LaserCheck( LevelCBInfo cbData,					MRSpriteTag theTag,					SpritePtr theSprite,					short row, short col ) {	Boolean didActivate = false;		if ( cbData->tiles[row+1][col] == kLaserTile ) {		ActivateLaser( cbData, row+1, col );		didActivate = true;	}	if ( cbData->tiles[row-1][col] == kLaserTile ) {		ActivateLaser( cbData, row-1, col );		didActivate = true;	}	if ( cbData->tiles[row][col+1] == kLaserTile ) {		ActivateLaser( cbData, row, col+1 );		didActivate = true;	}	if ( cbData->tiles[row][col-1] == kLaserTile ) {		ActivateLaser( cbData, row, col-1 );		didActivate = true;	}		// did we activate any lasers? if so turn into a stupid	// empty piece	if ( didActivate )		DrawLevelTile( cbData->sw, row, col, kLaserEmptyPiece );}					void _move_Push( LevelCBInfo cbData,					MRSpriteTag theTag,					SpritePtr theSprite,					short row, short col ) {						short fallTile;		if ( theTag->info.push.isGoldDisk ) {		_move_Push_GoldDisk( cbData, theTag, theSprite, row, col );		return;	}			// put ourselves down.	DrawLevelTile( cbData->sw, row, col, theTag->tileID );		if ( theTag->tileID == kLaserPowerTile )		_move_Push_LaserCheck( cbData, theTag, theSprite, row, col);				// can we fall now?	if ( theTag->theKind.canFall ) {		fallTile = cbData->tiles[row+theTag->theKind.fallRowDelta][col];		if ( fallTile == kBlankTile )			MakeSprite_Fall( cbData, row, col, theTag->theKind.fallRowDelta );	}		// how about rolling?	if ( theTag->theKind.canRoll ) {		short rollUnderTile;		PieceKind underKind;				rollUnderTile = cbData->tiles[row+theTag->theKind.fallRowDelta][col];		GetPieceKind( &underKind, rollUnderTile );				if ( underKind.isRounded ) 			if ( _sprite_CanRoll( cbData, row, col, theTag->theKind.fallRowDelta,						  theTag->info.push.colDelta, false ) )				MakeSprite_Roll( cbData, row, col, theTag->info.push.colDelta, 							 	 theTag->theKind.fallRowDelta );	}		// clean up this sprite.	DBG_DisposePtr( (Ptr) theTag );	MRSpriteTag oliverTag = (MRSpriteTag) cbData->oliverSprite->userData;	oliverTag->info.oliver.isPushing = false;	oliverTag->info.oliver.pushHack = true;	SWRemoveSpriteFromAnimation( cbData->sw, theSprite, true );	return;}void _move_Quark ( LevelCBInfo cbData,				   MRSpriteTag theTag,				   SpritePtr theSprite,			       short row, short col ) {		       	short	checkDir = kMoverFacingLeft;	Boolean	foundDir = false;	Boolean noDir = false;	short	checkTile;	short	newRowDelta, newColDelta;		// where am i?	theTag->loc.h = col;	theTag->loc.v = row;		while (!foundDir) {		checkTile = GetTileFromFacing( cbData, row, col, theTag->info.quark.facing,														 checkDir );		if ( checkTile == kBlankTile ) {			foundDir = true;			SetDeltasFromFacing( theTag->info.quark.facing, checkDir, &newRowDelta, &newColDelta );			theTag->info.quark.facing = AbsoluteFacing( theTag->info.quark.facing, checkDir );		} else {			if ( checkTile == kPhantomTile ) {				PieceKind newKind;				short rd, cd;                                                                   							SetDeltasFromFacing( theTag->info.quark.facing, checkDir, &rd, &cd );				GetPieceKindFromLoc( cbData, &newKind, row+rd, col+cd );				if ( newKind.isOliver ) {					Point explLoc;					KillOliver( cbData->oliverSprite, false );					explLoc.v = row;					explLoc.h = col;					StartQuarkExplosion( cbData, explLoc, true );					return;				}			}			checkDir = RotateClockwise( checkDir );			if ( checkDir == kMoverFacingLeft ) {				foundDir = true;				noDir = true;				newRowDelta = 0;				newColDelta = 0;				theTag->info.quark.facing = RotateClockwise( theTag->info.quark.facing );			}		}	}		// set sprite movement	SWSetSpriteMoveDelta( theSprite, newColDelta*kMoverSpriteMoveDelta,									 newRowDelta*kMoverSpriteMoveDelta );					if ( theTag->info.quark.rowDelta != 0 || theTag->info.quark.colDelta != 0 )		// blank the spot we were at		DrawLevelTile( cbData->sw, row-theTag->info.quark.rowDelta, col-theTag->info.quark.colDelta, kBlankTile );			 	if ( !noDir ) {		// put a phantom where we're going		DrawLevelTile( cbData->sw, row+newRowDelta, col+newColDelta, kPhantomTile );	}		theTag->info.quark.rowDelta = newRowDelta;	theTag->info.quark.colDelta = newColDelta;	theTag->newLoc.h = theTag->loc.h + newColDelta;	theTag->newLoc.v = theTag->loc.v + newRowDelta;			       }Boolean _move_Scissor_FurtherTurn( LevelCBInfo cbData,				    MRSpriteTag theTag,				    SpritePtr theSprite,			        short row, short col ) {	short checkTile;	// see if we can now go straight	theTag->info.scissor.facing = theTag->info.scissor.turningTo;	checkTile = GetTileFromFacing( cbData, row, col, theTag->info.scissor.facing, kMoverFacingUp );	if ( checkTile == kBlankTile ) {		theTag->info.scissor.isTurning = false;		// continue going in this direction:		SetDeltasFromFacing( theTag->info.scissor.facing, kMoverFacingUp, &theTag->info.scissor.rowDelta, 														    	 	      &theTag->info.scissor.colDelta );		SWDrawTile( cbData->sw, row+theTag->info.scissor.rowDelta, col+theTag->info.scissor.colDelta, kPhantomTile );		SWSetSpriteMoveDelta( theSprite, theTag->info.scissor.colDelta*kMoverSpriteMoveDelta,										 theTag->info.scissor.rowDelta*kMoverSpriteMoveDelta );		SWOffsetSprite( theSprite, theSprite->horizMoveDelta, theSprite->vertMoveDelta );		return true;			} else {		if ( theTag->info.scissor.clockwiseTurn )			theTag->info.scissor.turningTo = RotateClockwise( theTag->info.scissor.turningTo );		else			theTag->info.scissor.turningTo = RotateCounterClockwise( theTag->info.scissor.turningTo );		theTag->info.scissor.turnedCount = 0;	}		return false;}Boolean _move_Scissor_AttemptTurn( LevelCBInfo cbData,								MRSpriteTag theTag,								SpritePtr theSprite,								short row, short col,								short *dCol, 								short *dRow,								short *cDir,								Boolean *nDir ) {	short	checkDir = kMoverFacingLeft;	Boolean	foundDir = false;	short	checkTile;	Boolean noDir = false;	short newRowDelta, newColDelta;		while (!foundDir) {		checkTile = GetTileFromFacing( cbData, row, col, theTag->info.scissor.facing,														 checkDir );		if ( checkTile == kBlankTile ) {			foundDir = true;			SetDeltasFromFacing( theTag->info.scissor.facing, checkDir, &newRowDelta, &newColDelta );			theTag->info.scissor.facing = AbsoluteFacing( theTag->info.scissor.facing, checkDir );		} else {			if ( checkTile == kPhantomTile ) {				PieceKind newKind;				short rd, cd;							SetDeltasFromFacing( theTag->info.scissor.facing, checkDir, &rd, &cd );				GetPieceKindFromLoc( cbData, &newKind, row+rd, col+cd );				if ( newKind.isOliver ) {					Point explLoc;					KillOliver( cbData->oliverSprite, false );					explLoc.v = row;					explLoc.h = col;					StartExplosion( cbData, explLoc, true );					return true;				}			}			checkDir = RotateClockwise( checkDir );			if ( checkDir == kMoverFacingLeft ) {				foundDir = true;				noDir = true;				newRowDelta = 0;				newColDelta = 0;			}		}	} // while !foundDir 		*dCol = newColDelta;	*dRow = newRowDelta;	*cDir = checkDir;	*nDir = noDir;	return false;}void _move_Scissor_DoTurn( MRSpriteTag theTag,						   SpritePtr theSprite,						   short checkDir,						   short tempFacing ){	theTag->info.scissor.clockwiseTurn = ( checkDir == kMoverFacingRight );			theTag->info.scissor.isTurning = true;	theTag->info.scissor.turnTime = TickCount();		if ( checkDir != kMoverFacingDown ) 		theTag->info.scissor.turningTo = theTag->info.scissor.facing;	else 		theTag->info.scissor.turningTo = RotateCounterClockwise( tempFacing );			theTag->info.scissor.facing = tempFacing;	theTag->info.scissor.turnedCount = 0;		SWSetSpriteMoveDelta( theSprite, 0, 0 );}	void _move_Scissor( LevelCBInfo cbData,				    MRSpriteTag theTag,				    SpritePtr theSprite,			        short row, short col ) {		long elapsedTime = TickCount() - theTag->info.scissor.turnTime;	short dRow, dCol, checkDir;	Boolean noDir;	short tempFacing = theTag->info.scissor.facing;		if ( theTag->info.scissor.isTurning ) {		 		if ( elapsedTime < kScissorTurnTime )			return;				if ( theTag->info.scissor.turnedCount < 1 )			theTag->info.scissor.turnedCount += 1;		else if (_move_Scissor_FurtherTurn( cbData, theTag, theSprite, row, col ))			return;		theTag->info.scissor.turnTime = TickCount();		return; 		 	}		// where am i?	theTag->loc.h = col;	theTag->loc.v = row;		if ( theTag->info.scissor.rowDelta != 0 || theTag->info.scissor.colDelta != 0 )		// blank the spot we were at		DrawLevelTile( cbData->sw, row-theTag->info.scissor.rowDelta, col-theTag->info.scissor.colDelta, kBlankTile );			 	if ( _move_Scissor_AttemptTurn( cbData, theTag, theSprite, row, col, 									&dCol, &dRow, &checkDir, &noDir ) )		return;			// set sprite movement	SWSetSpriteMoveDelta( theSprite, dCol*kMoverSpriteMoveDelta,									 dRow*kMoverSpriteMoveDelta );					// if we didn't go straight, bump into turn mode:	if ( checkDir != kMoverFacingUp ) 		_move_Scissor_DoTurn( theTag, theSprite, checkDir, tempFacing );	 else if ( !noDir ) 		// put a phantom where we're going		DrawLevelTile( cbData->sw, row+dRow, col+dCol, kPhantomTile );					theTag->info.scissor.rowDelta = dRow;	theTag->info.scissor.colDelta = dCol;	theTag->newLoc.h = theTag->loc.h + dCol;	theTag->newLoc.v = theTag->loc.v + dRow;		       }Boolean _move_Oliver_SKD_DoZap( LevelCBInfo cb, 								MRSpriteTag theTag, 								SpritePtr theSprite, 								char theKey, 								short tileID ) {	MRChore		zapChore;	short		zapH, zapV;	PieceKind	zapKind;	short		zapTile;		// set up basic stuff.	theTag->info.oliver.oliverAnimState = kZapAnimState;	zapH = theTag->loc.h;	zapV = theTag->loc.v;		// figure out where it takes place	if ( theKey == kMoveUp ) {		zapV -= 1;	} else if ( theKey == kMoveLeft ) {		zapH -=1;	} else if ( theKey == kMoveRight ) {		zapH += 1;	} else if ( theKey == kMoveDown ) {		zapV += 1;	}		// check to see if the piece is edible	zapTile = cb->tiles[zapV][zapH];	GetPieceKind( &zapKind, zapTile );		if ( zapKind.isEdible ) {	    //SysBeep( 10 );	    		// set the frame		if ( theKey == kMoveUp ) {			theTag->info.oliver.oliverFrame = kZapUpBubFrame;		} else if ( theKey == kMoveLeft ) {			theTag->info.oliver.oliverFrame = kZapLeftBubFrame;		} else if ( theKey == kMoveRight ) {			theTag->info.oliver.oliverFrame = kZapRightBubFrame;		} else if ( theKey == kMoveDown ) {			theTag->info.oliver.oliverFrame = kZapDownBubFrame;		}				// make the chore & add to list		AllocChore_Zap( cb, zapH, zapV, zapTile );				theTag->info.oliver.didZap = true;					theTag->info.oliver.startAnim = TickCount();		theTag->info.oliver.lastZapKey = theKey;	} 		else {		// piece wasn't edible, so can't zap it!		theTag->info.oliver.specialAnim = false;		theTag->info.oliver.denySpecial = false;		theTag->info.oliver.zappedBlankPiece = true;		theTag->info.oliver.oliverMotion.h = 0;		theTag->info.oliver.oliverMotion.v = 0;		theTag->info.oliver.startAnim = TickCount();	    cb->specialKeyRelease = theKey;		//theTag->info.oliver.forceStaticMotion = true;		return true; 		// was false -- dave powell suggested that you shouldn't move after a zap		// if your special key is still held down	}		return false;}Boolean _move_Oliver_SpecialKeyDown( LevelCBInfo cb, 									 MRSpriteTag theTag, 									 SpritePtr theSprite ) {	long 		elapsedTime;	short 		theKey = cb->theKeys[0];	Boolean		hasKeys = (cb->numKeys > 0);	short		tileID = cb->tiles[theTag->loc.v][theTag->loc.h];		// if we tried to zap a blank piece, bubble happily along.	if ( theTag->info.oliver.zappedBlankPiece )		return true;		// init the special anim information, if necessary	if ( !theTag->info.oliver.specialAnim ) {		theTag->info.oliver.specialAnim = true;		theTag->info.oliver.startAnim = TickCount();		theTag->info.oliver.denySpecial = false;		theTag->info.oliver.didZap = false;		theTag->info.oliver.lastZapKey = -1;		theTag->info.oliver.allowDiskDrop = 					((tileID == kBlankTile)||(tileID == kPhantomTile));	}		elapsedTime = TickCount() - theTag->info.oliver.startAnim;		// if we just finished a zap, march back to normal state	if (( elapsedTime <= kZapFreezeTicks ) && 		( theTag->info.oliver.didZap ) && 		(hasKeys) && 		(theKey == theTag->info.oliver.lastZapKey)) {				return true;	}		else if ( (elapsedTime <= kZapFreezeTicks) &&			  (theTag->info.oliver.didZap) &&			  (!hasKeys) ) {				return true;	}		else if ( (elapsedTime > kZapFreezeTicks) &&			  (theTag->info.oliver.didZap) &&			  (!hasKeys) ) {		theTag->info.oliver.didZap = false;		theTag->info.oliver.startAnim = TickCount();		return true;	}		else if ( (elapsedTime > kZapFreezeTicks) &&			  (theTag->info.oliver.didZap) &&			  (hasKeys) &&			  (theKey == theTag->info.oliver.lastZapKey) ) {		theTag->info.oliver.didZap = false;		theTag->info.oliver.startAnim = TickCount();		return true;	}		// if the user has pressed a key down other than	// special, we move to the zap anim state & zap that loc.	else if ((hasKeys) && (!theTag->info.oliver.didZap)) {		if ( _move_Oliver_SKD_DoZap( cb, theTag, theSprite, theKey, tileID ) )			return true;	}		// else if we've sat down long enough to drop a red disk,	// and we're already in the RD anim state, then drop 	// the disk:	else if (( TickCount() - theTag->info.oliver.startAnim > kRedDiskDropFinish) &&	 		 (theTag->info.oliver.oliverAnimState == kRDAnimState ) &&	 		 (!theTag->info.oliver.oliverDiskDrop) &&	 		 (theTag->info.oliver.allowDiskDrop)) {	 	MRChore	rdBlinkChore;	 		 	// that's one less red disk for you, oliver!	 	cb->redDiskCount -= 1;	 	PlaySoundID( kRedDiskReadySnd );	 	DrawLevelStatistics( cb );	 		 	// woohoo! no more special anim	 	theTag->info.oliver.specialAnim = false;	 		 	// make the blink chore	 	AllocChore_RedDiskBlink( cb, theTag->loc, kFirstRDBlinkTile );	 		 	// and don't let us drop another disk...	 	theTag->info.oliver.oliverDiskDrop = true;	 	theTag->info.oliver.specialAnim = false;	 	cb->specialKeyDown = false;	}		// else if we've passed the red-disk start time,	// start the RDAnim, assuming they have	// a red-disk to drop, and we haven't already started the anim.	else if (( TickCount() - theTag->info.oliver.startAnim > kRedDiskDropDelay ) &&	         ( cb->redDiskCount > 0 ) &&	         ( theTag->info.oliver.oliverAnimState != kRDAnimState ) && 	         ( !theTag->info.oliver.didZap ) &&	         ( !theTag->info.oliver.oliverDiskDrop) &&	         ( theTag->info.oliver.allowDiskDrop)) {		theTag->info.oliver.oliverAnimState = kRDAnimState;		theTag->info.oliver.oliverFrame = kExLaxBubFirstFrame;	}		// but what if there is no red disk to be had?	else if (( TickCount() - theTag->info.oliver.startAnim > kRedDiskDropDelay ) &&			 (theTag->info.oliver.oliverAnimState != kRDAnimState) &&			 (cb->redDiskCount == 0 )) {		theTag->info.oliver.specialAnim = false;		return false;	}		return true;}// returns TRUE if _move_Oliver should exit immediately// (i.e. if there is a special key held down)Boolean _move_Oliver_DeltasFromKeys( LevelCBInfo cbData,									 MRSpriteTag theTag,									 SpritePtr theSprite,									 short row, short col,									 short *rowDelta, short *colDelta ) {	short curKey;    // what's the current key?	curKey = cbData->theKeys[0];    // blank the deltas    *rowDelta = 0;    *colDelta = 0;	// where are you, oliver?	theTag->loc.h = col;	theTag->loc.v = row;		// the user just stepped through a port,	// so their motion is restricted for one move.	       if ( cbData->lastWasPort ) {    	cbData->lastWasPort = false;    	*colDelta = cbData->portColDelta;    	*rowDelta = cbData->portRowDelta;    	return false;    }     	// what if the special key is down?	if ( !theTag->info.oliver.denySpecial && 		 cbData->specialKeyDown ) {		 		theSprite->vertMoveDelta = 0;		theSprite->horizMoveDelta = 0;				if (_move_Oliver_SpecialKeyDown( cbData, theTag, theSprite ))			return true;	}			// standard do-as-user-keystroke-says routine. 	// Here because it should be.    if ( curKey == kMoveLeft )    	*colDelta = -1;    else if ( curKey == kMoveRight )    	*colDelta = 1;    else if ( curKey == kMoveUp )    	*rowDelta = -1;    else if ( curKey == kMoveDown )    	*rowDelta = 1;    	    return false;}void _move_Oliver_PushPiece( LevelCBInfo cbData,							 SpritePtr theSprite,							 MRSpriteTag theTag,							 short col, short row,							 short colDelta, short rowDelta,							 short newTile,							 PieceKind newKind ) {	MakeSprite_Push( cbData, theSprite, col, row, colDelta, rowDelta, newTile, newKind );	theTag->info.oliver.isPushing = true;	theTag->info.oliver.oliverAnimState = kPushAnimState;	theTag->info.oliver.oliverFrameDir = 0;	theSprite->vertMoveDelta = rowDelta * (kSpriteMoveDelta/2);	theSprite->horizMoveDelta = colDelta * (kSpriteMoveDelta/2);	theTag->loc.h = col+colDelta;	theTag->loc.v = row+rowDelta;	newTile = cbData->tiles[row+rowDelta][col+colDelta];	// and put one where he's going, provided there's a blank there already!	if ( newTile == kBlankTile )		DrawLevelTile( cbData->sw, row+rowDelta, col+colDelta, kPhantomTile );	// murphy really is moving, so get rid of the phantom tile where he was.	DrawLevelTile( cbData->sw, row, col, kBlankTile );	if ( colDelta > 0 ) {		theTag->info.oliver.oliverFrame = kPushRightBubFirstFrame;		theTag->info.oliver.oliverFinalFrame = kPushRightBubLastFrame;	} else if ( colDelta < 0 ) {		theTag->info.oliver.oliverFrame = kPushLeftBubFirstFrame;		theTag->info.oliver.oliverFinalFrame = kPushLeftBubLastFrame;	} else if ( rowDelta > 0 ) {		theTag->info.oliver.oliverFrame = kPushDownBubFirstFrame;		theTag->info.oliver.oliverFinalFrame = kPushDownBubLastFrame;	} else if ( rowDelta < 0 ) {		theTag->info.oliver.oliverFrame = kPushUpBubFirstFrame;		theTag->info.oliver.oliverFinalFrame = kPushUpBubLastFrame;	}}void _move_Oliver_PassPiece( LevelCBInfo cbData,							 SpritePtr theSprite,							 MRSpriteTag theTag,							 short col, short row,							 short colDelta, short rowDelta,							 short newTile,							 PieceKind newKind,							 short curTile,							 PieceKind curKind ) {	theSprite->vertMoveDelta = rowDelta * kSpriteMoveDelta;	theSprite->horizMoveDelta = colDelta * kSpriteMoveDelta;	theTag->loc.h = col+colDelta;	theTag->loc.v = row+rowDelta;	// draw blank phantom where murphy's going, iff it is blank already.	if (( newTile == kBlankTile ) || (newTile == kInfotronTile))		DrawLevelTile( cbData->sw, row+rowDelta, col+colDelta, kPhantomTile );			// can no longer deny the special key	theTag->info.oliver.denySpecial = false;	// if oliver is moving through a port, motion is restricted	// during the next move.	if ( newKind.isPort ) {		cbData->lastWasPort = true;		cbData->portRowDelta = rowDelta;		cbData->portColDelta = colDelta;		PlaySoundIDProx( kPortUseSnd, 8 );	}	// what about if it's edible, like a red disk or infotron	else if ( newKind.isEdible ) {		EatPiece( cbData, newTile );			} else if ( newTile == kLastExitTile ) {		PlaySoundID( kEndLevelSnd );		cbData->wonLevel = true;		// time is important!		theTag->cb->stopPlayTime = TickCount();		theTag->cb->timer = false;		DBG_DisposePtr( (Ptr) theTag );		SWRemoveSpriteFromAnimation( cbData->sw, cbData->oliverSprite, true );		cbData->oliverSprite = NULL;		return;	}	// murphy really is moving, so get rid of the phantom tile.	if (( !curKind.isPort ) && !(( curTile >= kFirstRDBlinkTile) && (curTile<= kLastRDBlinkTile)))		DrawLevelTile( cbData->sw, row, col, kBlankTile );}	void _move_Oliver_NoPassPiece( LevelCBInfo cbData,						  	   SpritePtr theSprite,							   short col, short row,							   short colDelta, short rowDelta,							   short newTile,							   PieceKind newKind ) {	theSprite->vertMoveDelta = 0;	theSprite->horizMoveDelta = 0;	// check for special pieces, such as the terminal	if (newTile == kTerminalTile)		ExplodeYellowDisks( cbData );	else if ( newTile == kPhaseTermTile &&			  cbData->extraInfo.levelWorld == kInfotronTerrain )		PhaseHardware( cbData );			// how about if they hit a (gulp!) mover?	if ( newTile == kPhantomTile ) {		PieceKind 	testKind;		Point		explLoc;				GetPieceKindFromLoc( cbData, &testKind, row+rowDelta, col+colDelta );		if ( testKind.moverSprite ) {			KillOliver( theSprite, false );			explLoc.h = col+colDelta;			explLoc.v = row+rowDelta;			StartExplosion( cbData, explLoc, true );		}	}}void _move_Oliver ( LevelCBInfo cbData,					MRSpriteTag theTag,					SpritePtr theSprite,					short row, short col ) {						short rowDelta, colDelta;	short curTile, newTile;	MRPlayerData pd = GetCurrentPlayer();	PieceKind curKind, newKind;		if ( theTag->info.oliver.isDead )		return;		    curTile = cbData->tiles[row][col];    GetPieceKind( &curKind, curTile );	if ( curKind.isDeadly ) {		KillOliver( theSprite, curKind.isElectric );		return;	}		if ( _move_Oliver_DeltasFromKeys( cbData, theTag, theSprite,									  row, col, &rowDelta, &colDelta ) )		return;		    // turn off special anim if necessary.    // the frame-proc takes care of the rest.    theTag->info.oliver.specialAnim = false;    theTag->info.oliver.oliverDiskDrop = false;        // let the frame proc know about oliver's exploits    theTag->info.oliver.oliverMotion.h = colDelta;    theTag->info.oliver.oliverMotion.v = rowDelta;	// Murphy leaves phantom tiles wherever he goes, except for ports,	// and also rd-blinks. They'll get blanked later.	if ( !curKind.isPort  && 		 !(  curTile >= kFirstRDBlinkTile && curTile<= kLastRDBlinkTile ) )		DrawLevelTile( cbData->sw, row, col, kPhantomTile );			        // get new tile    newTile = cbData->tiles[row+rowDelta][col+colDelta];		// Get info about it	GetPieceKind( &newKind, newTile );	if ( newKind.isPort )    	GetPortPassable( &newKind, cbData->tiles, col+colDelta, row+rowDelta, colDelta, rowDelta );	    // is it gonna kill ya?    if ( newKind.isDeadly )     	KillOliver( theSprite, newKind.isElectric );        // is it pushable & can we push?    else if ( newKind.isPushable &&     		  SafeToPush( cbData, col, row, colDelta, rowDelta ) )    	_move_Oliver_PushPiece( cbData, theSprite, theTag, col, row, colDelta, rowDelta, newTile, newKind );        // check to see if oliver can move into the desired location:    else if ( newKind.isPassable )     	_move_Oliver_PassPiece( cbData, theSprite, theTag,    							col, row, colDelta, rowDelta, newTile, newKind,    							curTile, curKind );		// can't move through this piece, so...	// ...set moveDeltas to zero - piece not passable.	else 		_move_Oliver_NoPassPiece( cbData, theSprite, col, row, colDelta, rowDelta, newTile, newKind );				// set the cbData info	cbData->oliverCurLoc = theTag->loc;}// helper routines for high level sprite allocation stuffvoid _make_MoverFacing( LevelCBInfo cbData,						MRSpriteTag theTag,						short row, short col,						short initFacing ) {							short			facingTest;	Boolean			foundDirection;	short			checkTile;		facingTest = kMoverFacingLeft;	foundDirection = false;	theTag->info.mover.rowDelta = 0;	theTag->info.mover.colDelta = 0;	theTag->info.mover.facing = initFacing;		while (!foundDirection) {		checkTile = GetTileFromFacing( cbData, row, col, 									   initFacing, facingTest );		if ( checkTile == kBlankTile ) {			foundDirection = true;			SetDeltasFromFacing( initFacing, facingTest, 								 &theTag->info.mover.rowDelta,								 &theTag->info.mover.colDelta );			theTag->info.mover.facing = AbsoluteFacing( initFacing, facingTest );		} else {			facingTest = RotateClockwise( facingTest );			if ( facingTest == kMoverFacingLeft )				foundDirection = true;		}	}	}short *_make_PFInfo_Zonk( short lastTile, short firstTile,						  short dRow, short dCol, 						  short *frameCount,						  short *frameSpeedMult ) {	short *frameList;	short i;		*frameCount = lastTile - firstTile + 1;	*frameSpeedMult = 2;	frameList = (short*) DBG_NewPtr(sizeof(short) * (*frameCount));	if ( dCol > 0 )		for ( i = 0; i < *frameCount; i++ )			frameList[i] = firstTile + i;	else {		frameList[0] = firstTile;		frameList[1] = lastTile;		frameList[2] = lastTile-1;		frameList[3] = lastTile-2;	}	return frameList;}short *_make_PushFrameInfo( short tileID,							short dRow, short dCol, 							short *frameCount, 							short *frameSpeedMult ) {	short *frameList;	short i;		switch ( tileID ) {		case kZonkTile:			frameList = _make_PFInfo_Zonk( kLastZonkTile, kFirstZonkTile, 									       dRow, dCol,									       frameCount, frameSpeedMult );			break;					case kUpZonkTile:			frameList = _make_PFInfo_Zonk( kLastUpZonkTile, kFirstUpZonkTile,										   dRow, dCol,										   frameCount, frameSpeedMult );			break;					//case kYellowDiskTile:		//case kGreenDiskTile:		//case kGoldDiskTile:		//case kBlankChipTile:		//case kLaserPowerTile:		//case kForeMirrorTile:		//case kBackMirrorTile:		//case kLaserEmptyPiece:		default:			*frameCount = 1;			*frameSpeedMult = 1;			frameList = (short*) DBG_NewPtr(sizeof(short));			frameList[0] = tileID;			break;		}		return frameList;}// high level sprite allocation routinesvoid MakeSprite_Fall( LevelCBInfo cbData, short row, short col, short fallRowDelta ) {	SpritePtr		fallSprite;	MRSpriteTag		fallTag;	fallTag = _sprite_AllocTagCommonHV( kFallSpriteType,										cbData,										col, row,										_frame_Default,										_move_Fall,										NULL );	fallTag->info.fall.fallRowDelta = fallRowDelta;	fallTag->info.fall.firstFall = true;	// okay, create the sprite to fall & it's graphic.	fallSprite = _sprite_AllocSWSprite( cbData, fallTag, NULL, 1, kSpriteFrameMilli );		SWSetSpriteMoveDelta( fallSprite, 0, fallRowDelta*kSpriteMoveDelta );	_sprite_FrameFromTile( cbData->sw, fallSprite, fallTag->tileID );			SWSetSpriteFrameAdvance( fallSprite, 0 );	SWLockSprite( fallSprite );		// place a phantom tile where we're going & blank space underneath	DrawLevelTile( cbData->sw, row + fallRowDelta, col, kPhantomTile );	SWDrawTile( cbData->sw, row, col, kPhantomTile );		// motion of the sprite is not advanced until the actual moveproc is called.	// this gives oliver some lag-time to beat the bullet, so to speak.}void MakeSprite_Roll( LevelCBInfo cbData, 					 short row, short col, 					 short rollColDelta, 					 short fallRowDelta ) {	// the fallRowDelta is only used to then set off a fall chore,	// because as we all know, once you roll, you try to fall.	SpritePtr		rollSprite;	MRSpriteTag		rollTag;	short			frameCount;	short			frameSpeedMult;	short			*frameList;		rollTag = _sprite_AllocTagCommonHV( kRollSpriteType,										cbData,										col, row,										_frame_Default,										_move_Roll,										NULL );	rollTag->info.roll.fallRowDelta = fallRowDelta;	rollTag->info.roll.rollColDelta = rollColDelta;		frameList = _make_PushFrameInfo( rollTag->tileID,									 0, rollColDelta,									 &frameCount, &frameSpeedMult );	rollSprite = _sprite_AllocSWSprite( cbData, 										rollTag,										NULL,										frameCount,										kSpriteFrameMilli );	for ( short i = 0; i < frameCount; i++ )		_sprite_FrameFromTile( cbData->sw, rollSprite, frameList[i] );	DBG_DisposePtr( (Ptr) frameList );		// Set the sprite speed & direction. (Rolling sprites only roll left/right.)	SWSetSpriteFrameAdvance( rollSprite, 0 );	SWSetSpriteMoveDelta( rollSprite, rollColDelta*kSpriteMoveDelta, 0 );	SWLockSprite( rollSprite );		// blank the space under the piece.	DrawLevelTile( cbData->sw, row, col + rollColDelta, kPhantomTile );	SWDrawTile( cbData->sw, row, col, kBlankTile );		// move the sprite just a tad, to start it on its merry way.	SWOffsetSprite( rollSprite, rollSprite->horizMoveDelta, rollSprite->vertMoveDelta );}void MakeSprite_Quark( LevelCBInfo cbData, short row, short col ) {	SpritePtr		quarkSprite;	MRSpriteTag		quarkTag;	short			count;		quarkTag = _sprite_AllocTagCommonHV( kQuarkSpriteType,										 cbData,										 col, row,										 _frame_Default,										 _move_Quark,										 NULL );	quarkTag->newLoc = quarkTag->loc;		// see if we can find a direction to move for the quark.	// preferences are left, up, right, down. (i.e. a quark always faces up at first.)		// set the deltas	_make_MoverFacing( cbData, quarkTag, row, col, kMoverFacingUp );		// okay, create the sprite to fall & it's graphic frames.	quarkSprite = _sprite_AllocSWSprite( cbData, quarkTag, NULL,										 kLastQuarkTile - kFirstQuarkTile + 1,										 kQuarkFrameMilli );	for ( count = 0; count < kLastQuarkTile - kFirstQuarkTile + 1; count++ )		_sprite_FrameFromTile( cbData->sw, quarkSprite, kFirstQuarkTile + count );		// Set the sprite speed & direction. 	SWSetSpriteFrameAdvance( quarkSprite, 0 );	SWSetSpriteMoveDelta( quarkSprite, quarkTag->info.mover.colDelta * kMoverSpriteMoveDelta, 									   quarkTag->info.mover.rowDelta * kMoverSpriteMoveDelta );	SWLockSprite( quarkSprite );			// place a phantom tile where we're going.	SWDrawTile( cbData->sw, row+quarkTag->info.mover.rowDelta, col+quarkTag->info.mover.colDelta, kPhantomTile );	if ( quarkTag->info.mover.rowDelta != 0 || quarkTag->info.mover.colDelta != 0 )		DrawLevelTile( cbData->sw, row, col, kBlankTile );		// move this sucker.	SWOffsetSprite( quarkSprite, quarkSprite->horizMoveDelta, quarkSprite->vertMoveDelta );}void MakeSprite_Scissor( LevelCBInfo cbData, short row, short col, short initFacing ) {	SpritePtr		sciSprite;	MRSpriteTag		sciTag;		sciTag = _sprite_AllocTagCommonHV( kScissorSpriteType,									   cbData,									   col, row,									   _frame_Scissor,									   _move_Scissor,									   NULL );	sciTag->newLoc = sciTag->loc;	_make_MoverFacing( cbData, sciTag, row, col, initFacing );			// some animation frame info	sciTag->info.scissor.lastFacing = kMoverStatic;	sciTag->info.scissor.internalFrame = 0;	sciTag->info.scissor.internalDir = 1;		// okay, create the sprite to fall & it's graphic frames.	sciSprite = _sprite_AllocSWSprite( cbData, sciTag, NULL,									   kUpLeftScissorTile - kFirstUpScissorTile + 1,									   kQuarkFrameMilli );	for ( short count = 0; count < kUpLeftScissorTile - kFirstUpScissorTile + 1; count++ )		_sprite_FrameFromTile( cbData->sw, sciSprite, kFirstUpScissorTile + count );		// Set the sprite speed & direction. 	SWSetSpriteFrameAdvance( sciSprite, 0 );	SWSetSpriteMoveDelta( sciSprite, sciTag->info.mover.colDelta * kMoverSpriteMoveDelta, 									 sciTag->info.mover.rowDelta * kMoverSpriteMoveDelta );	SWLockSprite( sciSprite );		// place a phantom tile where we're going.	SWDrawTile( cbData->sw, row+sciTag->info.mover.rowDelta, col+sciTag->info.mover.colDelta, kPhantomTile );	if ( sciTag->info.mover.rowDelta != 0 || sciTag->info.mover.colDelta != 0 )		DrawLevelTile( cbData->sw, row, col, kBlankTile );		// move this sucker.	SWOffsetSprite( sciSprite, sciSprite->horizMoveDelta, sciSprite->vertMoveDelta );}void MakeSprite_Push( LevelCBInfo cbData, 					SpritePtr theSprite, 					short col, short row, short colDelta, short rowDelta, 					short newTile, 					PieceKind newKind ) {						SpritePtr		pushSprite;	MRSpriteTag		pushTag;	short			frameCount;	short			frameSpeedMult;		short			*frameList;		pushTag = _sprite_AllocTagCommonHV( kPushSpriteType,										cbData,										col + colDelta, row + rowDelta,										_frame_Default,										_move_Push,										NULL );	pushTag->newLoc.v = row+rowDelta+rowDelta;	pushTag->newLoc.h = col+colDelta+colDelta;	pushTag->info.push.isGoldDisk = (newTile == kGoldDiskTile);	pushTag->info.push.colDelta = colDelta;	pushTag->info.push.rowDelta = rowDelta;		// A bit of hackery ensues. If we're just pushing any-old-piece,	// mark the square we're pushing into as TAKEN with a phantom tile.	// The one exception is if we're pushing a gold disk into a circuit	// tile, which _is_ allowed; in this case, no phantom tile is needed.	if ( pushTag->info.push.isGoldDisk ) {		if ( cbData->tiles[ pushTag->newLoc.v ][ pushTag->newLoc.h ] == kBlankTile )			DrawLevelTile( cbData->sw, pushTag->newLoc.v, pushTag->newLoc.h, kPhantomTile );	}	else		DrawLevelTile( cbData->sw, pushTag->newLoc.v, pushTag->newLoc.h, kPhantomTile );		// create the sprite	frameList = _make_PushFrameInfo( newTile, rowDelta, colDelta, &frameCount, &frameSpeedMult );	pushSprite = _sprite_AllocSWSprite( cbData, pushTag, NULL, 										frameCount, kSpriteFrameMilli * frameSpeedMult );	for ( short i = 0; i < frameCount; i++ )		_sprite_FrameFromTile( cbData->sw, pushSprite, frameList[i] );	DBG_DisposePtr( (Ptr) frameList );		// pushing is hard for a bubble, so things go at half the normal speed,	// except for that oddball gold disk, which takes off under its own power.	if ( newTile == kGoldDiskTile )		SWSetSpriteMoveDelta( pushSprite, colDelta*(kSpriteMoveDelta), rowDelta*(kSpriteMoveDelta));	else		SWSetSpriteMoveDelta( pushSprite, colDelta*(kSpriteMoveDelta/2), rowDelta*(kSpriteMoveDelta/2));		// blank the space under the piece.	// however, since we know that oliver's going to be in this space next time around,	// we do _not_ need to call the DrawLevelTile routine.	// this is because it will check to see if something should fall, which technically it should,	// so then all hell breaks loose.	if (( pushTag->info.push.isGoldDisk ) || 		( pushTag->tileID == kZonkTile ) ||		( pushTag->tileID == kUpZonkTile ))		SWDrawTile( cbData->sw, pushTag->loc.v, pushTag->loc.h, kBlankTile );		// add sprite to the animation!	SWSetSpriteFrameAdvance( pushSprite, 0 );	SWLockSprite( pushSprite );	// now move it along somewhat.	SWOffsetSprite( pushSprite, pushSprite->horizMoveDelta, pushSprite->vertMoveDelta );		// play the push sound	PlaySoundID( kPushSnd );}void MakeSprite_Oliver( LevelCBInfo cbData ) {	SpriteLayerPtr	theLayer;	OSErr err;	MRPlayerData	pd = GetCurrentPlayer();	MRPrefs			mp = GetCurrentPrefs();	MRSpriteTag		theTag;		// the layer	err = SWCreateSpriteLayer( &theLayer );	ErrorCheck( err, "SWCreateSpriteLayer", true );		err = SWCreateSpriteLayer( &cbData->againLayer );	ErrorCheck( err, "SWCreateSpriteLayer", true );		// the main sprites	MRTerrainAlias();	err = SWCreateSpriteFromSinglePictXY( cbData->sw,					  					  &cbData->oliverSprite,										  NULL,										  kOliverSpritePict,										  0,										  kLevelItemSize,										  kLevelItemSize,										  0,										  kMaxBubFrames,										  kNoMask );	ErrorCheck( err, "SWCreateSpriteFromSinglePict", true );	MRRestoreResFile();		// set the userData	theTag = _sprite_AllocTagCommon( kOliverSpriteType,									 cbData,									 cbData->oliverStartLoc,									 _frame_Oliver,									 _move_Oliver,									 NULL );	cbData->oliverSprite->userData = (long) theTag;		// Set sprite-related infos	SWSetSpriteMoveProc( cbData->oliverSprite, _sprite_SWMoveProc );	SWSetSpriteLocation( cbData->oliverSprite, theTag->loc.h*kLevelItemSize, 											   theTag->loc.v*kLevelItemSize );		SWSetSpriteMoveDelta( cbData->oliverSprite, 0, 0 );		// Set the sprite drawproc.	if ( mp.interlacedMode )		SWSetSpriteDrawProc( cbData->oliverSprite, SPRITEDRAWPROCINT() );	else		SWSetSpriteDrawProc( cbData->oliverSprite, SPRITEDRAWPROC() );		// the frame-change proc:	SWSetSpriteFrameProc( cbData->oliverSprite, _sprite_SWFrameProc );	SWSetSpriteFrameTime( cbData->oliverSprite, kOliverBubbleMilli );	SWSetSpriteFrameAdvance( cbData->oliverSprite, 0 );		// push it under the ports	SWSetSpriteUnderTiles( cbData->oliverSprite, true );		// add the sprite.	SWAddSprite( theLayer, cbData->oliverSprite );	SWAddSpriteLayer( cbData->sw, theLayer );	SWAddSpriteLayer( cbData->sw, cbData->againLayer );		// make sure we know about that layer!	cbData->sLayer = theLayer;		// lock!	SWLockSpriteWorld( cbData->sw );}
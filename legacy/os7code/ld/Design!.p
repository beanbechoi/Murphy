program Design30;{Level Designer 4.0}{A Map/level designer for Murphy's Revenge}{©1997 Q Software & Dave Peck, All Rights Reserved}{This is hacked up beyond all recognition. It was hacked up from the old Infotron}{level designer, so don't expect wonders.}	uses		PascalSucks, sound, QDOffScreen, QOffScreen, stacks, QDialog, quickdrawprocs, QAssert, keydowns, QStringInts, MRMap;{---Begin PeckEvents Declarations---}	const		WNE_TRAP_NUM = $60;		UNIMPLEMENTED_TRAP_NUM = $9F;		MaxWind = 20;		MaxMenu = 10;	var		dummy: boolean;		aRecta: rect;		windows: array[0..MaxWind] of WindowPtr;		menus: array[0..MaxMenu] of MenuHandle;		curNumWindows: integer;		curNumMenus: integer;		wantsToQuit: boolean;		gWNEImplemented: boolean;		hisApple: MenuHandle;		currentWindow: integer;		fstPtr: grafPtr;{-----------COPY THE FOLLOWING ROUTINES AT THE FRONT OF YOUR PROGRAM---------}	procedure peckInit (howMany: integer);	forward;	procedure peckQuit;	forward;	procedure peckNewWindow (var aWindow: windowPtr);	forward;	procedure peckKillWindow (var aWindow: windowPtr);	forward;	procedure peckNewMenu (var aMenu: menuHandle;									disp: boolean);	forward;	procedure peckKillMenu (var aMenu: menuHandle);	forward;	procedure peckApple (aboutName: str255);	forward;	procedure peckMain;	forward;	procedure peckHalt;	forward;{--- BEGIN DESIGNER 3.0 ---}	procedure ______________;	forward;	const{menus}		mFile = 128;		mEdit = 129;		mMap = 130;{menu items}		iNewSet = 1;		iOpenSet = 2;		iClose = 3;		iSave = 4;		iSaveAs = 5;		iQuit = 7;		iUndo = 1;		iCut = 3;		iCopy = 4;		iPaste = 5;		iClear = 6;		iNewMap = 1;		iMapInfo = 2;		iGoToPoint = 4;		iWorldID = 4;		iOverview = 5;		iImport = 5;{sounds}		sEdge = 128;{window IDs}		wMap = 128;		wPalette = 129;		wList = 130;{Pict IDs}		pPalette = 128;		pAbout = 129;		pMapGfx = 2000;{Dialog IDs}		dAbout = 128;		dCloseUnsaved = 129;		dLevelInfo = 130;		dWarning = 131;		dSaveAs = 134;		dGoTo = 136;{size restraints}		kMaxMap = 15;		kMaxLevs = 125;{controls}		cScroll = 128;{about the resources}		kFileType = 'MdoC';		kFileCreator = 'Mrfy';{about scroll}		kScrollbarWidth = 16;		kScrollBarAdjust = kScrollBarWidth - 1;		kScrollBarTweek = 2;{drawing stuff}		kStartLoc = 15;		kNumRight = 25;		kStringLeft = 30;		kSkip = 16;{about the palette}		kMaxClass = 8;		kMaxAcross = 7;		kMaxDown = 4;		kNoInfo = -1;		kNoIcon = kNoInfo;		kMaxUndo = 250;{prefs}		kPrefResType = 'ldPf';		kMapPrefResType = 'mSpf';		kPrefResID = 200;		kMapPrefResID = 200;	type		WindArray = array[1..kMaxMap] of WindowPtr;		ScrollArray = array[1..kMaxMap] of ControlHandle;		BoolArray = array[1..kMaxMap] of boolean;		MapType = record				count: integer;				windows: WindArray;				filth: BoolArray;			end;		StringArr = array[1..kMaxLevs] of Str255;		LevelFlagArr = array[1..kMaxLevs] of byte;		ListPtr = ^ListType;		ListType = record				count: integer;				names: StringArr;				flags: LevelFlagArr;			end;		WindowKind = (none, list, map, palette, world);		IconContentArray = array[1..kMaxAcross, 1..kMaxDown] of integer;		ContentType = record				countAcross: integer;				countDown: integer;				data: IconContentArray;			end;		ClassArray = array[1..kMaxClass] of Str255;		ContentArray = array[1..kMaxClass] of ContentType;		PalMenuType = record				numClass: integer;				classNames: ClassArray;				classContents: ContentArray;			end;		UndoInfoRec = record				count: integer;				mapWind: WindowPtr;				loc: array[1..kMaxUndo] of point;				what: array[1..kMaxUndo] of integer;			end;		RectArr = array[1..kMaxLevs] of rect;		MapPrefType = record				count: integer;				locs: RectArr;			end;		MPTP = ^MapPrefType;		MPTH = ^MPTP;		PrefType = record				listRec: rect;				palLoc: point;			end;		PTP = ^PrefType;		PTH = ^PTP;	const		levelInfoResType = 'l”nF';	type		LevelInfoType = Str255;		LevelInfoPtr = ^LevelInfoType;		LevelInfo = ^LevelInfoPtr;	var{my res}		gMyRes: integer;{hack for opening}		gDoingOpenUp: boolean;{prefs}		gPrefs: PrefType;		gMapPrefs: MPTP;{menus}		gFileMenu, gEditMenu, gMapMenu: MenuHandle;{windows}		gListWind: WindowPtr;		gMaps: MapType;		gPalette: WindowPtr;		gWorldWind: WindowPtr;{scroll bars}		gListScroll: ControlHandle;		gListHScroll: ControlHandle;{clip board}		gHaveScrap: boolean;		gCanUndo: boolean;		gUndoInfo: UndoInfoRec;		gHaveSelection: boolean;{info about front window}		gWindKind: WindowKind;{palette pic offscreen}		gPalOff: GWorldPtr;{status of palette / menuing data}		gCurIcon: integer;		gCurClass: integer;		gPalMenu: PalMenuType;		gToolSpace: rect;		gActiveMap: windowPtr;{Set Info}		gSetDirty: boolean;	{true if should be saved}		gSetName: str255;	{name of the set; i.e. levelFile name}		gList: ListPtr;		{the stuffs - the actual list.}{click info}		gLastClick: longint;	{in tickcounts}{$S PartOne}	function ResourceName (id: integer;									daKind: ResType): str255;	forward;	procedure GetLevelInfo (theLevName: str255;									var theInfo: Str255);		var			myLI: LevelInfo;			whatever: integer;	begin		whatever := CurResFile;		UseResFile(gListRes);		myLI := nil;		myLI := LevelInfo(GetNamedResource(levelInfoResType, theLevName));		if (myLI <> nil) and (ResError = noErr) then			begin				MoveHHi(handle(myLI));				HLock(handle(myLI));				theInfo := myLI^^;				HUnlock(handle(myLI));				ReleaseResource(handle(myLI));			end		else			theInfo := '';		UseResFile(whatever);	end;	procedure KillLevelInfo (theLevName: Str255);		var			tempRes: Handle;			whatever: integer;	begin		whatever := CurResFile;		UseResFile(gListRes);		tempRes := nil;		tempRes := GetNamedResource(levelInfoResType, theLevName);		if (tempRes <> nil) and (ResError = noErr) then			begin		{resource exists!}				RemoveResource(tempRes);				UpdateResFile(gListRes);		{byebye!}			end;		UseResFile(whatever);	end;	procedure SetLevelInfo (theLevName: Str255;									theInfo: Str255);		var			myLI: LevelInfo;			whatever: integer;	begin		whatever := CurResFile;		UseResFile(gListRes);		KillLevelInfo(theLevName);		myLI := nil;		myLI := LevelInfo(NewHandleClear(sizeOf(LevelInfoType)));		if (myLI <> nil) then			begin				MoveHHi(handle(myLI));				HLock(handle(myLI));				myLI^^ := theInfo;				AddResource(handle(myLI), levelInfoResType, UniqueID(levelInfoResType), theLevName);				UpdateResFile(gListRes);				ReleaseResource(handle(myLI));			end;		UseResFile(whatever);	end;	procedure UpdateMenus;	begin{file menu}		if gListWind = nil then			begin				EnableItem(gFileMenu, iNewSet);				EnableItem(gFileMenu, iOpenSet);			end		else			begin				DisableItem(gFileMenu, iNewSet);				DisableItem(gFileMenu, iOpenSet);			end;		if (gWindKind = none) or (gWindKind = palette) then			begin				DisableItem(gFileMenu, iClose);				DisableItem(gFileMenu, iSave);				DisableItem(gFileMenu, iSaveAs);			end		else if (gWindKind = map) or (gWindKind = list) then			begin				EnableItem(gFileMenu, iClose);				EnableItem(gFileMenu, iSave);				EnableItem(gFileMenu, iSaveAs);			end		else if (gWindKind = world) then			begin				DisableItem(gFileMenu, iClose);				EnableItem(gFileMenu, iSave);				DisableItem(gFileMenu, iSaveAs);			end;		EnableItem(gFileMenu, iQuit);{edit menu}		if gCanUndo then			EnableItem(gEditMenu, iUndo)		else			DisableItem(gEditMenu, iUndo);		if gHaveScrap then			EnableItem(gEditMenu, iPaste)		else			DisableItem(gEditMenu, iPaste);		if (gWindKind = world) then			begin				if (WorldEditHilites(gWorldWind)) then					begin						DisableItem(gEditMenu, iCopy);						DisableItem(gEditMenu, iCut);						EnableItem(gEditMenu, iPaste);						DisableItem(gEditMenu, iClear);					end				else					begin						DisableItem(gEditMenu, iCut);						DisableItem(gEditMenu, iCopy);						DisableItem(gEditMenu, iClear);						DisableItem(gEditMenu, iPaste);					end;			end		else if gHaveSelection then			begin				EnableItem(gEditMenu, iCut);				EnableItem(gEditMenu, iCopy);				EnableItem(gEditMenu, iClear);				DisableItem(gEditMenu, iPaste);			end		else			begin				DisableItem(gEditMenu, iCut);				DisableItem(gEditMenu, iCopy);				DisableItem(gEditMenu, iClear);				DisableItem(gEditMenu, iPaste);			end;{map menu}		if (gListWind = nil) then			DisableItem(gMapMenu, iNewMap)		else			EnableItem(gMapMenu, iNewMap);		if (gWindKind = map) then			begin				EnableItem(gMapMenu, iMapInfo);				DisableItem(gMapMenu, iGoToPoint);				EnableItem(gMapMenu, iOverview);			end		else			begin				DisableItem(gMapMenu, iMapInfo);				EnableItem(gMapMenu, iGoToPoint);				DisableItem(gMapMenu, iOverview);			end;	end;	function WindowsIntersect (w1, w2: WindowPtr): boolean;		var			theResult: boolean;			r1, r2: rect;			oldPort: GrafPtr;	begin		GetPort(oldPort);		SetPort(w1);		r1 := w1^.portRect;		LocalToGlobal(r1.topLeft);		LocalToGlobal(r1.botRight);		SetPort(w2);		r2 := w2^.portRect;		LocalToGlobal(r2.topLeft);		LocalToGlobal(r2.botRight);		WindowsIntersect := PtInRect(r1.topLeft, r2) or PtInRect(r1.botRight, r2);		SetPort(oldPort);	end;	procedure Make_MapPrefs;	begin		if (gMapPrefs = nil) then			begin				gMapPrefs := MPTP(NewPtrClear(sizeOf(MapPrefType)));				_ASSERT(gMapPrefs <> nil);			end;	end;	procedure Kill_MapPrefs;	begin		if (gMapPrefs <> nil) then			DisposePtr(ptr(gMapPrefs));	end;	procedure Init_Palette;		var			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;			myLoc: point;			r: rect;		procedure ClearData (var data: IconContentArray;										mx, my: integer);			var				x, y: integer;		begin			for x := 1 to mx do				for y := 1 to my do					data[x, y] := kNoIcon;		end;	begin{1 set the data}		gCurTool := kPencil;		gCurIcon := 198;		gCurClass := 8;		gPalMenu.numClass := kMaxClass;		gPalMenu.classNames[1] := 'Main';		gPalMenu.classNames[2] := 'Chips';		gPalMenu.classNames[3] := 'Bombs';		gPalMenu.classNames[4] := 'Enemies';		gPalMenu.classNames[5] := 'Ports';		gPalMenu.classNames[6] := 'Hardware';		gPalMenu.classNames[7] := 'Border';		gPalMenu.classNames[8] := 'Murphy';		with gPalMenu.classContents[1] do			begin				countAcross := 6;				countDown := 1;				ClearData(data, countAcross, countDown);				data[1, 1] := 129;				data[2, 1] := 128;				data[3, 1] := 700;				data[4, 1] := 710;				data[5, 1] := 850;				data[6, 1] := 130;			end;		with gPalMenu.classContents[2] do			begin				countAcross := 3;				countDown := 2;				ClearData(data, countAcross, countDown);				data[1, 1] := 1100;				data[1, 2] := 1104;				data[2, 1] := 1106;				data[3, 1] := 1102;				data[2, 2] := 131;				data[3, 2] := 1101;			end;		with gPalMenu.classContents[3] do			begin				countAcross := 5;				countDown := 1;				ClearData(data, countAcross, countDown);				data[1, 1] := 133;				data[2, 1] := 134;				data[3, 1] := 135;				data[4, 1] := 138;				data[5, 1] := 550;			end;		with gPalMenu.classContents[4] do			begin				countAcross := 4;				countDown := 2;				ClearData(data, countAcross, countDown);				data[1, 1] := 1000;				data[2, 1] := 1002;				data[3, 1] := 1004;				data[4, 1] := 1006;				data[1, 2] := 650;				data[2, 2] := 300;				data[3, 2] := 1400;				data[4, 2] := 1450;			end;		with gPalMenu.classContents[5] do			begin				countAcross := 7;				countDown := 1;				ClearData(data, countAcross, countDown);				data[1, 1] := 900;				data[2, 1] := 902;				data[3, 1] := 904;				data[4, 1] := 906;				data[5, 1] := 950;				data[6, 1] := 952;				data[7, 1] := 132;			end;		with gPalMenu.classContents[6] do			begin				countAcross := 7;				countDown := 4;				ClearData(data, countAcross, countDown);				data[1, 1] := 750;				data[2, 1] := 751;				data[3, 1] := 753;				data[4, 1] := 754;				data[5, 1] := 755;				data[6, 1] := 756;				data[7, 1] := 775;				data[1, 2] := 752;				data[2, 2] := 757;				data[3, 2] := 758;				data[4, 2] := 759;				data[5, 2] := 760;				data[6, 2] := 757;				data[7, 2] := 776;				data[1, 3] := 762;				data[2, 3] := 763;				data[3, 3] := 764;				data[4, 3] := 765;				data[5, 3] := 766;				data[6, 3] := 767;				data[7, 3] := 761;				data[1, 4] := 768;				data[2, 4] := 769;				data[3, 4] := 770;				data[4, 4] := 771;				data[5, 4] := 772;				data[6, 4] := 773;				data[7, 4] := 774;			end;		with gPalMenu.classContents[7] do			begin				countAcross := 3;				countDown := 3;				ClearData(data, countAcross, countDown);				data[1, 1] := 1057;				data[2, 1] := 1050;				data[3, 1] := 1051;				data[1, 2] := 1056;				data[3, 2] := 1052;				data[1, 3] := 1055;				data[2, 3] := 1054;				data[3, 3] := 1053;			end;		with gPalMenu.classContents[8] do			begin				countAcross := 1;				countDown := 1;				ClearData(data, countAcross, countDown);				data[1, 1] := 198;			end;{2 make the offscreen}		r := GetPRect(pPalette);		OffsetRect(r, -r.left, -r.top);		InsetRect(r, -4, -4);		gPalOff := MakeGWorld(r);		InsetRect(r, 4, 4);		GetGWorld(oldGW, oldGD);		SetGWorld(gPalOff, nil);		myLoc.h := 4;		myLoc.v := 4;		ignore := LockPixels(gPalOff^.portPixMap);		DrawPic(pPalette, myLoc);		UnlockPixels(gPalOff^.portPixMap);		SetGWorld(oldGW, oldGD);		gToolSpace := r;		gToolSpace.bottom := gToolSpace.bottom div 2 + 1;		gToolSpace.right := gToolSpace.right div 2 + 1;		OffsetRect(gToolSpace, 4, 4);{3 make the window}		gPalette := GetNewCWindow(wPalette, nil, WindowPtr(-1));		PeckNewWindow(gPalette);		MoveWindow(gPalette, gPrefs.palLoc.h, gPrefs.palLoc.v, FALSE);		SizeWindow(gPalette, gToolSpace.right + 4 + 1, gToolSpace.bottom + 10 + 32 + 6 + kSkip + 4, TRUE);		ShowWindow(gPalette);		SetPort(gPalette);{gWindKind := palette;}	end;	procedure Kill_Palette;		var			oldPort: GrafPtr;	begin		GetPort(oldPort);		SetPort(gPalette);		gPrefs.palLoc := gPalette^.portRect.topLeft;		LocalToGlobal(gPrefs.palLoc);		SetPort(oldPort);		PeckKillWindow(gPalette);		DisposeWindow(gPalette);		gPalette := nil;		DestroyGWorld(gPalOff);	end;	procedure Get_MapPrefs;		var			res: handle;			oldResID: integer;			count: integer;	begin		oldResID := CurResFile;		UseResFile(gListRes);		res := Get1Resource(kMapPrefResType, kMapPrefResID);		if (res = nil) or (resError <> noErr) then			begin	{guaranteed to fit on a 14 inch monitor, which is a program requirement!}				gMapPrefs^.count := gList^.count;				for count := 1 to gList^.count do					with gMapPrefs^.locs[count] do						begin							top := 74;							bottom := 384;							left := 30;							right := 438;						end;			end		else			begin				MoveHHi(res);				HLock(res);				gMapPrefs^ := MPTH(res)^^;				HUnlock(res);				ReleaseResource(res);				for count := 1 to gMapPrefs^.count do{try to be safe on different monitors!}					if (not (PtInRect(gMapPrefs^.locs[count].topLeft, qd.screenBits.bounds))) or (not (PtInRect(gMapPrefs^.locs[count].botRight, qd.screenBits.bounds))) then						with gMapPrefs^.locs[count] do							begin								top := 74;								bottom := 384;								left := 30;								right := 438;							end;			end;		UseResFile(oldResID);	end;	procedure Save_MapPrefs;		var			res: handle;			oldResID: integer;	begin		oldResID := CurResFile;		UseResFile(gListRes);		res := Get1Resource(kMapPrefResType, kMapPrefResID);		if (res = nil) or (resError <> noErr) then			begin				res := NewHandleClear(sizeOf(MapPrefType));				_ASSERT(res <> nil);				_ASSERT(memError = noErr);				MoveHHi(res);				HLock(res);				MPTH(res)^^ := gMapPrefs^;				AddResource(res, kMapPrefResType, kMapPrefResID, 'Map Prefs');				_ASSERT(resError = noErr);				HUnlock(res);			end		else			begin				MoveHHi(res);				HLock(res);				MPTH(res)^^ := gMapPrefs^;				ChangedResource(res);				HUnlock(res);			end;		UpdateResFile(gListRes);		if (res <> nil) then			ReleaseResource(res);		UseResFile(oldResID);	end;{---}	procedure Get_Prefs;		var			res: handle;			oldResID: integer;	begin		oldResID := CurResFile;		UseResFile(gMyRes);		res := Get1Resource(kPrefResType, kPrefResID);		if (res = nil) or (resError <> noErr) then			begin	{guaranteed to fit on a 14 inch monitor, which is a program requirement!}				gPrefs.palLoc.h := 502;				gPrefs.palLoc.v := 56;				gPrefs.listRec.left := 8;				gPrefs.listRec.right := 180;				gPrefs.listRec.top := 68;				gPrefs.listRec.bottom := 424;			end		else			begin				MoveHHi(res);				HLock(res);				gPrefs := PTH(res)^^;				HUnlock(res);				ReleaseResource(res);{try to be safe on different monitors!}				if not (PtInRect(gPrefs.palLoc, qd.screenBits.bounds)) then					begin						gPrefs.palLoc.h := 502;						gPrefs.palLoc.v := 56;					end;				if not (PtInRect(gPrefs.listRec.topLeft, qd.screenBits.bounds)) then					begin						gPrefs.listRec.left := 8;						gPrefs.listRec.right := 180;						gPrefs.listRec.top := 68;						gPrefs.listRec.bottom := 424;					end;				if not (PtInRect(gPrefs.listRec.botRight, qd.screenBits.bounds)) then					begin						gPrefs.listRec.left := 8;						gPrefs.listRec.right := 180;						gPrefs.listRec.top := 68;						gPrefs.listRec.bottom := 424;					end;			end;		UseResFile(oldResID);	end;	procedure Save_Prefs;		var			res: handle;			oldResID: integer;	begin		oldResID := CurResFile;		UseResFile(gMyRes);		res := Get1Resource(kPrefResType, kPrefResID);		if (res = nil) or (resError <> noErr) then			begin				res := NewHandleClear(sizeOf(PrefType));				_ASSERT(res <> nil);				_ASSERT(memError = noErr);				MoveHHi(res);				HLock(res);				PTH(res)^^ := gPrefs;				AddResource(res, kPrefResType, kPrefResID, 'Preferences');				_ASSERT(resError = noErr);				HUnlock(res);			end		else			begin				MoveHHi(res);				HLock(res);				PTH(res)^^ := gPrefs;				ChangedResource(res);				HUnlock(res);			end;		UpdateResFile(gMyRes);		if (res <> nil) then			ReleaseResource(res);		UseResFile(oldResID);	end;	procedure Init_Design;	begin		PeckInit(15);		gList := ListPtr(NewPtrClear(sizeOf(ListType)));		gHaveScrap := FALSE;		gCanUndo := FALSE;		gHaveSelection := FALSE;		gListWind := nil;		gWorldWind := nil;		gMaps.count := 0;		gMyRes := CurResFile;		PeckApple('About Designer...');		gFileMenu := GetMenu(mFile);		PeckNewMenu(gFileMenu, false);		gEditMenu := GetMenu(mEdit);		PeckNewMenu(gEditMenu, false);		gMapMenu := GetMenu(mMap);		PeckNewMenu(gMapMenu, true);{    InitDesBoard;}{Init_Palette;}		Make_MapPrefs;		Get_Prefs;		gLastClick := 0;		gLastCursor := cArrow;		UpdateMenus;	end;	procedure Close_Design;	begin		if (gList <> nil) then			DisposePtr(Ptr(gList));	end;	procedure Update_ListScroll;		var			pr: rect;			r: rect;			newMax: integer;	begin		HideControl(gListScroll);		HideControl(gListHScroll);		pr := gListWind^.portRect;		MoveControl(gListScroll, pr.right - kScrollbarAdjust, -1);		SizeControl(gListScroll, kScrollBarWidth, (pr.bottom - pr.top) - (kScrollBarAdjust - kScrollBarTweek));		MoveControl(gListHScroll, -1, pr.bottom - kScrollBarAdjust);		SizeControl(gListHScroll, (pr.right - pr.left) - (kScrollBarAdjust - kScrollBarTweek), kScrollBarWidth);		r := gListWind^.portRect;		r.right := r.right - kScrollBarAdjust;		r.bottom := r.bottom - kScrollBarAdjust;		if (gList^.count <> 0) then			begin				newMax := gList^.Count - (((r.bottom - r.top) - kStartLoc) div kSkip);				if (newMax < 1) then					newMax := 1;				SetControlMaximum(gListScroll, newMax);			end;		ShowControl(gListHScroll);		ShowControl(gListScroll);	end;	procedure Update_ListWind;		var			oldPort: grafPtr;			gNum: integer;			loc: integer;			count: integer;			startCount, finishCount: integer;			r: rect;	begin		GetPort(oldPort);		SetPort(gListWind);		r := gListWind^.portRect;		r.right := r.right - kScrollBarAdjust;		r.bottom := r.bottom - kScrollBarAdjust;		EraseRect(r);		GetFNum('geneva', gNum);		TextFont(gNum);		TextSize(9);		TextFace([]);		loc := kStartLoc;		startCount := GetControlValue(gListScroll);		finishCount := startCount + ((r.bottom - r.top) - kStartLoc) div kSkip;		if gList^.count < ((r.bottom - r.top) - kStartLoc) div kSkip then			finishCount := gList^.count		else if finishCount > (GetControlMaximum(gListScroll) + (((r.bottom - r.top) - kStartLoc) div kSkip)) then			finishCount := GetControlMaximum(gListScroll) + ((r.bottom - r.top) - kStartLoc) div kSkip;		if gList^.count = 0 then			finishCount := -1;		for count := startCount to finishCount do			begin				TextFace([bold]);				MoveTo(kNumRight - StringWidth(stringof(count : 1)), loc);				DrawString(stringof(count : 1));				TextFace([]);				MoveTo(kStringLeft, loc);				DrawString(gList^.names[count]);				loc := loc + kSkip;			end;		UpdateControls(gListWind, gListWind^.visRgn);		DrawGrowIcon(gListWind);		SetPort(oldPort);	end;	procedure Update_Palette;		var			tr: Rect;			dr: rect;			ignore: OSErr;			drawX, drawY: integer;			fNum: integer;			grayc: rgbcolor;			oldPort: GrafPtr;			arrowStartX, arrowStartY: integer;			halfBlackColor: RGBColor;	begin		GetPort(oldPort);		SetPort(gPalette);{step 1: draw the tools}		tr := gToolSpace;		OffsetRect(tr, -4, -4);		if (gCurTool = kFill) then			OffsetRect(tr, tr.right - 1, 0);		if (gCurTool = kSelect) then			OffsetRect(tr, 0, tr.bottom - 1);		if (gCurTool = kEyedrop) then			OffsetRect(tr, tr.right - 1, tr.bottom - 1);		OffsetRect(tr, 4, 4);		CopyWorldBits2(gPalOff, gPalette, tr, gToolSpace);{step 2: draw the icon - BUT ONLY IF the FRONT WINDOW IS NOT THE OVERWORLD}		drawX := (gToolSpace.right div 2) - 16 + 3;		drawY := gToolSpace.bottom + 10;		dr.left := drawX;		dr.right := dr.left + 32;		dr.top := drawY;		dr.bottom := dr.top + 32;		if (gWindKind = world) then			DrawCurrentMapIcon(gWorldWind, dr)		else if (gWindKind <> list) and (gWindKind <> palette) then			DrawCurrentMapIcon(gActiveMap, dr)		else			EraseRect(dr);{step 3: write the class, box it.}		GetFNum('geneva', fNum);		TextFont(fNum);		TextSize(9);		TextFace([]);		drawX := (gToolSpace.right div 2) - (StringWidth(gPalMenu.classNames[gCurClass]) div 2) + 3 - 4;		drawY := dr.bottom + 3 + kSkip;		dr.top := drawY - kSkip;		dr.bottom := gPalette^.portRect.bottom;		dr.left := 0;		dr.right := gToolSpace.right;		EraseRect(dr);{    if (gWindKind = world) or (gWindKind = map) then}		begin			halfBlackColor.red := (32768);			halfBlackColor.green := (32768);			halfBlackColor.blue := (32768);			RGBForeColor(halfBlackColor);		end;		MoveTo(drawX, drawY);		DrawString(gPalMenu.classNames[gCurClass]);{step 4: draw a little arrow next to the class...}		arrowStartX := drawX + stringWidth(gPalMenu.classNames[gCurClass]) + 1;		arrowStartY := drawY - 5;{if (gWindKind <> world) and (gWindKind <> map) then}		begin			MoveTo(arrowStartX, arrowStartY);			LineTo(arrowStartX + 6, arrowStartY);			MoveTo(arrowStartX + 1, arrowStartY + 1);			LineTo(arrowStartX + 5, arrowStartY + 1);			MoveTo(arrowStartX + 2, arrowStartY + 2);			LineTo(arrowStartX + 4, arrowStartY + 2);			MoveTo(arrowStartX + 3, arrowStartY + 3);			LineTo(arrowStartX + 3, arrowStartY + 3);		end;{step 5: draw a gray box around the class name!}		dr.left := drawX - 3;		dr.right := arrowStartX + 9;		dr.bottom := drawY + 4;		dr.top := drawY - 9;		FrameRect(dr);{step 6: draw a drop-shadow on the bottom and right of the box}		MoveTo(dr.left + 2, dr.bottom);		LineTo(dr.right, dr.bottom);		MoveTo(dr.right, dr.top + 2);		LineTo(dr.right, dr.bottom);{    if (gWindKind = world) or (gWindKind = map) then}		ForeColor(blackColor);		SetPort(oldPort);	end;	function FindMapWind (w: windowptr): integer;		var			count: integer;	begin		FindMapWind := -1;		if w <> nil then			for count := 1 to gMaps.count do				if gMaps.windows[count] = w then					FindMapWind := count;	end;	function IconsDown (w: windowPtr): integer;		var			r: rect;	begin		r := w^.portRect;		r.right := r.right - 15;		r.bottom := r.bottom - 15;		IconsDown := (r.bottom - r.top) div 32 + 1;	end;	function IconsAcross (w: windowPtr): integer;		var			r: rect;	begin		r := w^.portRect;		r.right := r.right - 15;		r.bottom := r.bottom - 15;		IconsAcross := (r.right - r.left) div 32 + 1;	end;	function PtToInt (x, y: integer): integer;	begin		PtToInt := integer((x * 256) + y);	end;	function IntToPt (i: integer): point;	begin		IntToPt.h := i div 256;		IntToPt.v := i mod 256;	end;	procedure Action_ListThumb (control: ControlHandle;									part: integer);	begin	end;	procedure Action_ListScroll (control: ControlHandle;									part: integer);		var			dist: integer;			r, r2, r3: rect;			newSet: integer;			sz, sv: integer;			oldPort: GrafPtr;	begin		GetPort(oldPort);		SetPort(gListWind);		if part <> 0 then			begin				r := gListWind^.portRect;				r.right := r.right - kScrollBarAdjust;				r.bottom := r.bottom - kScrollBarAdjust;				case part of					20, 21: 						dist := 1;					22, 23: 						dist := (((r.bottom - r.top) - kStartLoc) div kSkip);				end;				if (part = 21) or (part = 23) then					dist := -dist;				newSet := GetControlValue(gListScroll) - dist;				if (newSet < 1) then					newSet := 1				else if newSet > GetControlMaximum(gListScroll) then					newSet := GetControlMaximum(gListScroll);				if newSet <> GetControlValue(gListScroll) then					begin						SetControlValue(gListScroll, newSet);						if abs(dist) = 1 then							begin								UpdateControls(gListWind, gListWind^.visRgn);								r2 := r;								r2.bottom := r2.bottom - kSkip;								r3 := r;								r3.top := r3.top + kSkip;								if (dist = 1) then									begin										CopyBits(gListWind^.portBits, gListWind^.portBits, r2, r3, srcCopy, nil);										r.bottom := r.top + kSkip;										EraseRect(r);										TextFace([bold]);										MoveTo(kNumRight - StringWidth(stringof(GetControlValue(gListScroll) : 1)), kStartLoc);										DrawString(stringof(GetControlValue(gListScroll) : 1));										TextFace([]);										MoveTo(kStringLeft, kStartLoc);										DrawString(gList^.names[GetControlValue(gListScroll)]);									end								else									begin										CopyBits(gListWind^.portBits, gListWind^.portBits, r3, r2, srcCopy, nil);										sz := (((r.bottom - r.top) - kStartLoc) div kSkip) + GetControlValue(gListScroll);										sv := ((((r.bottom - r.top) - kStartLoc) div kSkip) * kSkip) + kStartLoc;										r.top := r.bottom - kSkip;										EraseRect(r);										TextFace([bold]);										MoveTo(kNumRight - StringWidth(stringof(sz : 1)), sv);										DrawString(stringof(sz : 1));										TextFace([]);										MoveTo(kStringLeft, sv);										DrawString(gList^.names[sz]);									end;							end						else							Update_ListWind;					end;			end;		SetPort(oldPort);	end;	procedure Close_ListWind;		var			count: integer;			oldPort: GrafPtr;	begin{should cycle through open map windows, and ask about them first...}		Save_MapPrefs;{close the overhead window}		PeckKillWindow(gWorldWind);		CloseWorldWindow(gWorldWind);		for count := gMaps.count downto 1 do			PeckKillWindow(gMaps.windows[count]);		if gSetDirty then			;	{want to save?}		GetPort(oldPort);		SetPort(gListWind);		gPrefs.listRec := gListWind^.portRect;		LocalToGlobal(gPrefs.listRec.topLeft);		LocalToGlobal(gPrefs.listRec.botRight);		SetPort(oldPort);		DisposeWindow(gListWind);		UpdateResFile(gListRes);		CloseResFile(gListRes);		gWindKind := none;		gList^.count := 0;		gListWind := nil;		gWorldWind := nil;		Kill_Palette;		UpdateMenus;	end;	function FindMapInList (w: integer): integer;		var			title: str255;			count: integer;	begin		FindMapInList := -1;		GetWTitle(gMaps.windows[w], title);		for count := 1 to gList^.count do			if title = gList^.names[count] then				FindMapInList := count;	end;	function FindMNInList (title: str255): integer;		var			count: integer;	begin		FindMNInList := -1;		for count := 1 to gList^.count do			if title = gList^.names[count] then				FindMNInList := count;	end;	procedure SaveMap (w: integer);		var			listLoc: integer;			resId: integer;			oldRF: integer;			byeRes: handle;	begin		listLoc := FindMapInList(w);		if listLoc > 0 then			begin				resId := listLoc + 300;				SaveWorldID(gMaps.windows[w], resID);				gMaps.filth[w] := FALSE;			end;	end;{$S PartTwo}	function CloseUnsaved_Map (w: integer): boolean;		var			d: DialogPtr;			whatever: str255;			item: integer;	begin		sysbeep(10);		GetWTitle(gMaps.windows[w], whatever);		ParamText(whatever, '', '', '');		InitCursor;		d := GetNewDialog(dCloseUnsaved, nil, WindowPtr(-1));		ShowWindow(d);		repeat			ModalDialog(nil, item);		until (item > 0) and (item < 4);		DisposeDialog(d);		if (item = 2) then			CloseUnsaved_Map := FALSE		else			begin				CloseUnsaved_Map := TRUE;				if (item = 1) then		{the YES button, they want to save}					SaveMap(w);			end;		if gLastCursor <> -1 then			if gCurrentCurs <> nil then				SetCursor(gCurrentCurs^^)			else				begin					gCurrentCurs := GetCursor(gLastCursor);					SetCursor(gCurrentCurs^^);				end		else			InitCursor;	end;	procedure Close_MapWind (w: integer);		var			count: integer;			shouldClose: boolean;			oldPort: grafPtr;			whichMap: integer;	begin		shouldClose := TRUE;{    if gMaps.filth[w] then}{shouldClose := CloseUnsaved_Map(w);}		if shouldClose or (wantsToQuit) then			begin				_ASSERT(gMaps.windows[w] <> nil);				GetPort(oldPort);				SetPort(gMaps.windows[w]);				whichMap := FindMapInList(w);				_ASSERT(whichMap <> -1);				gMapPrefs^.locs[whichMap] := gMaps.windows[w]^.portRect;				LocalToGlobal(gMapPrefs^.locs[whichMap].topLeft);				LocalToGlobal(gMapPrefs^.locs[whichMap].botRight);				SetPort(oldPort);				CloseWorldWindow(gMaps.windows[w]);{    DisposeWindow(gMaps.windows[w]);}				if w < gMaps.count then					for count := w to gMaps.count - 1 do						begin							gMaps.windows[count] := gMaps.windows[count + 1];							gMaps.filth[count] := gMaps.filth[count + 1];						end;				gMaps.count := gMaps.count - 1;				Save_MapPrefs;			end;	end;	function FigureCell (p: point;									kFigNewton: integer): integer;	begin		if p.v < kStartLoc then			FigureCell := GetControlValue(gListScroll)		else			FigureCell := (((p.v - kStartLoc - kFigNewton) div kSkip)) + GetControlValue(gListScroll) + 1;	end;	procedure MakeNewMap (n: str255);		var			{open up a map resource, this is NOT from scratch}			pr: rect;			whichWind: integer;			whichList: integer;	begin		gMaps.count := gMaps.count + 1;		whichList := FindMNInList(n);		DontShowWorld;		gMaps.windows[gMaps.count] := LoadWorldWindow(n, whichList + 300);		PeckNewWindow(gMaps.windows[gMaps.count]);		MoveWindow(gMaps.windows[gMaps.count], gMapPrefs^.locs[whichList].left, gMapPrefs^.locs[whichList].top, FALSE);		SizeWindow(gMaps.windows[gMaps.count], gMapPrefs^.locs[whichList].right - gMapPrefs^.locs[whichList].left, gMapPrefs^.locs[whichList].bottom - gMapPrefs^.locs[whichList].top, FALSE);		ResizeWorld(gMaps.windows[gMaps.count]);		SetWTitle(gMaps.windows[gMaps.count], n);		ShowWindow(gMaps.windows[gMaps.count]);		gMaps.filth[gMaps.count] := FALSE;	end;	procedure CreateNewMap;		var			pr: rect;			whichWind: integer;			n: Str255;			d: DialogPtr;			itemHit: integer;			a: rect;			b: integer;			item: handle;			op: GrafPtr;	begin		ParamText('Name your new level:', '', '', '');		d := GetNewDialog(134, nil, WindowPtr(-1));		ShowWindow(d);		repeat			ModalDialog(nil, itemHit);		until itemHit = 1;		GetDialogItem(d, 2, b, item, a);		GetDialogItemText(item, n);		DisposeDialog(d);{add to list}		gList^.count := gList^.count + 1;		gList^.names[gList^.count] := n;		gMapPrefs^.count := gMapPrefs^.count + 1;		with gMapPrefs^.locs[gMapPrefs^.count] do			begin				top := 74;				bottom := 384;				left := 30;				right := 438;			end;		gSetDirty := TRUE;	{?}		GetPort(op);		SetPort(gListWind);		Update_ListScroll;		Update_ListWind;		SetPort(op);		gMaps.count := gMaps.count + 1;		DontShowWorld;		gMaps.windows[gMaps.count] := MakeWorldWindow(n, gList^.count + 300);		PeckNewWindow(gMaps.windows[gMaps.count]);		SetWTitle(gMaps.windows[gMaps.count], n);		ShowWindow(gMaps.windows[gMaps.count]);		gMaps.filth[gMaps.count] := FALSE;		SaveWorldID(gMaps.windows[gMaps.count], gList^.count + 300);	end;	procedure Mouse_Palette (p: point);		var			cWind: WindowPtr;			cRect: rect;			p2: point;			fnum: integer;			count: integer;			lastCell, curCell, tempCell: integer;			m: point;			lastChange: longint;			handleRelease: boolean;			funkPort: GrafPtr;		procedure AdjustRect (var r: rect);		begin			if not PtInRect(r.botRight, qd.screenBits.bounds) then				begin					if r.bottom > qd.screenBits.bounds.bottom then						OffsetRect(r, 0, qd.screenBits.bounds.bottom - r.bottom);					if r.right > qd.screenBits.bounds.right then						OffsetRect(r, qd.screenBits.bounds.right - r.right, 0);				end;		end;		function CellRect (c: integer): rect;			var				r: rect;		begin			r.left := 0;			r.right := StringWidth('Hardware') + 4;			r.top := ((c - 1) * 16) + 1;			r.bottom := r.top + 13;			CellRect := r;		end;		procedure InnerMenu (p2: point;										c: integer;										brrect: rect);			const				kIconSpace = 36;			var				fRect: rect;				fWind: windowPtr;				countX, countY: integer;				ignore: OSErr;				dr: rect;				m: point;				oldPort: GrafPtr;				lastPt, curPt: point;				lastWasInvalid: boolean;		begin			GetPort(oldPort);			LocalToGlobal(p2);			fRect.left := p2.h - 5;			fRect.right := fRect.left + (gPalMenu.classContents[c].countAcross) * kIconSpace + 4;			fRect.top := p2.v - 5;			fRect.bottom := fRect.top + (gPalMenu.classContents[c].countDown) * kIconSpace + 4;			AdjustRect(fRect);			fWind := NewCWindow(nil, fRect, '', TRUE, altDBoxProc, WindowPtr(-1), FALSE, 0);			SetPort(fWind);			dr.top := 4;			dr.left := 4;			dr.right := dr.left + 32;			dr.bottom := dr.top + 32;			for countY := 1 to gPalMenu.classContents[c].countDown do				begin					for countX := 1 to gPalMenu.classContents[c].countAcross do						begin							if gPalMenu.classContents[c].data[countX, countY] <> kNoIcon then								;{    ignore := PlotIconID(dr, 0, 0, gPalMenu.classContents[c].data[countX, countY]);}							OffsetRect(dr, kIconSpace, 0);						end;					dr.left := 4;					dr.Right := dr.left + 32;					OffsetRect(dr, 0, kIconSpace);				end;			ForeColor(blueColor);			PenPat(qd.black);			PenSize(2, 2);			GetMouse(m);			LocalToGlobal(m);			lastPt.h := 0;			lastPt.v := 0;			curPt.h := 0;			curPt.v := 0;			lastWasInvalid := TRUE;			while button and ((PtInRect(m, fRect)) or not (PtInRect(m, brRect))) do				begin					GetMouse(m);{local processing}					curPt.h := (m.h - 4) div kIconSpace + 1;					curPt.v := (m.v - 4) div kIconSpace + 1;					if (curPt.h <> lastPt.h) or (curPt.v <> lastPt.v) then						begin							if (curPt.h > 0) and (curPt.h <= gPalMenu.classContents[c].countAcross) 							and (curPt.v > 0) and 							(curPt.v <= gPalMenu.classContents[c].countDown) and {was &}							(gPalMenu.classContents[c].data[curPt.h, curPt.v] <> kNoIcon) then								begin									dr.left := 1 + ((lastPt.h - 1) * kIconSpace);									dr.right := dr.left + 32 + 6;									dr.top := 1 + ((lastPt.v - 1) * kIconSpace);									dr.bottom := dr.top + 32 + 6;									ForeColor(whiteColor);									FrameRect(dr);									dr.left := 1 + ((curPt.h - 1) * kIconSpace);									dr.right := dr.left + 32 + 6;									dr.top := 1 + ((curPt.v - 1) * kIconSpace);									dr.bottom := dr.top + 32 + 6;									ForeColor(blueColor);									FrameRect(dr);									lastPt := curPt;									lastWasInvalid := FALSE;								end							else								begin									if not (lastWasInvalid) then										begin											dr.left := 1 + ((lastPt.h - 1) * kIconSpace);											dr.right := dr.left + 32 + 6;											dr.top := 1 + ((lastPt.v - 1) * kIconSpace);											dr.bottom := dr.top + 32 + 6;											ForeColor(whiteColor);											FrameRect(dr);										end;									lastWasInvalid := TRUE;									lastPt := curPt;								end;						end;					LocalToGlobal(m);				end;			ForeColor(blackColor);			PenSize(1, 1);			if (not button) and (not lastWasInvalid) then				begin		{theychosesomething}					gCurIcon := gPalMenu.classContents[c].data[curPt.h, curPt.v];					gCurClass := c;{SetPort(gPalette);}					Update_Palette;{    SetPort(fWind);}				end;			DisposeWindow(fWind);			SetPort(oldPort);		end;	begin		GetPort(funkPort);		SetPort(gPalette);		if PtInRect(p, gToolSpace) then			begin				if (p.h < gToolSpace.right div 2) and (p.v < gToolSpace.bottom div 2) then					gCurTool := kPencil;				if (p.h > gToolSpace.right div 2) and (p.v < gToolSpace.bottom div 2) then					gCurTool := kFill;				if (p.h < gToolSpace.right div 2) and (p.v > gToolSpace.bottom div 2) then					gCurTool := kSelect;				if (p.h > gToolSpace.right div 2) and (p.v > gToolSpace.bottom div 2) then					gCurTool := kEyedrop;				if (gWorldWind <> nil) then					ZeroWorldSelection(gWorldWind);				Update_Palette;			end		else if (p.v > gToolSpace.bottom) and (p.v < gToolSpace.bottom + 10 + 32 + 6) then			begin				if (gWindKind = map) then					SelectWorldIcon(gActiveMap)				else if (gWindKind = world) then					SelectWorldIcon(gWorldWind);			end;		if (p.v > gToolSpace.bottom + 10 + 32 + 6) and button and (gWindKind <> world) and (false) then {clicked elsewhere in palette window}			begin				p2 := p;				LocalToGlobal(p2);				cRect.left := p2.h - 5;				cRect.right := cRect.left + StringWidth('Hardware') + 4;				cRect.top := p2.v - 5;				cRect.bottom := cRect.top + (gPalMenu.numClass * 16);				AdjustRect(cRect);				cWind := NewCWindow(nil, cRect, '', TRUE, altDBoxProc, WindowPtr(-1), FALSE, 0);				SetPort(cWind);				GetFNum('geneva', fNum);				TextFont(fNum);				TextSize(9);				TextFace([]);				for count := 1 to gPalMenu.numClass do					begin						MoveTo(2, ((count - 1) * 16) + 11);						DrawString(gPalMenu.classNames[count]);					end;				lastCell := 0;				curCell := 0;				lastChange := tickcount;				handleRelease := TRUE;				while button do					begin						GetMouse(m);						curCell := (m.v div 16) + 1;						if (m.h < 0) or (m.h > StringWidth('Hardware') + 4) or (m.v < 0) or (m.v > cRect.bottom - cRect.top) then							curCell := 0;						if (curCell <> lastCell) then							begin								if lastCell <> 0 then									InvertRect(cellRect(lastCell));								if curCell <> 0 then									InvertRect(cellRect(curCell));								lastCell := curCell;								lastChange := tickCount;							end;						if (tickCount - lastChange > 25) and (curCell > 0) and (curCell <= 8) then							begin								InnerMenu(m, curCell, cRect);								handleRelease := button;								EraseRect(cWind^.portRect);								for count := 1 to gPalMenu.numClass do									begin										MoveTo(2, ((count - 1) * 16) + 11);										DrawString(gPalMenu.classNames[count]);									end;								InvertRect(cellRect(curCell));							end;					end;				if (curCell > 0) and (curCell <= kMaxClass) then					begin						InvertRect(cellRect(curCell));						if handleRelease then							begin								gCurIcon := gPalMenu.classContents[curCell].data[1, 1];								gCurClass := curCell;{SetPort(gPalette);}								Update_Palette;								SetPort(cWind);							end;					end;				DisposeWindow(cWind);			end;		SetPort(funkPort);	end;	procedure Mouse_ListWind (p: point);		const			kFigNewton = 4;		var			fistCurs: CursHandle;			selRect: rect;			c: longint;			mframe: rect;			lastpt, pt: point;			okRect: rect;			lastWasOff: boolean;			selCell, newCell: integer;			tmpName: str255;			count: integer;			tmpRes, tmpRes2, tmpRes3: Handle;			oldRes: integer;			watchFrame: integer;			whichWind: integer;			tempStr: Str255;			name: str255;			resName: Str255;			resName2: Str255;	begin		selRect := gListWind^.portRect;		selRect.right := selRect.right - 19;		selRect.left := selRect.left + 3;		if (p.v <= kStartLoc) then			selRect.top := -1		else			selRect.top := (((p.v - kStartLoc - kFigNewton) div kSkip) * kSkip) + kStartLoc;		selRect.bottom := selRect.top + kSkip - 3;		selCell := FigureCell(p, kFigNewton);		if selCell > gList^.count then			exit(Mouse_ListWind);		OffsetRect(selRect, 0, 6);		if (TickCount - gLastClick < GetDblTime) then			begin				gLastClick := 0;				whichWind := -1;				for count := 1 to gMaps.count do					begin						GetWTitle(gMaps.windows[count], name);						if name = gList^.names[selCell] then							whichWind := count;					end;				if (whichWind <> -1) then					begin						SelectWindow(gMaps.windows[whichWind]);					end				else					begin						MakeNewMap(gList^.names[selCell]);					end;			end		else			begin				InvertRect(selRect);				if button then					begin						c := TickCount;						while (TickCount - c) < 15 do							;					end;				gLastClick := tickCount;				if button then					begin	{click and drag}						gLastClick := 0;						fistCurs := GetCursor(cClosedHand);						SetCursor(fistCurs^^);						mframe := selRect;						PenPat(qd.gray);						PenMode(srcXor);						lastPt := p;						okRect := gListWind^.portRect;						okRect.bottom := okRect.bottom - kScrollbarAdjust;						okRect.right := okRect.right - kScrollbarAdjust;						lastWasOff := false;						while button do							begin								GetMouse(pt);								if (pt.v <> lastPt.v) then									begin										if pt.v < 0 then	{scroll up}											begin												if (GetControlValue(gListScroll) <> GetControlMinimum(gListScroll)) then													begin														FrameRect(mFrame);														lastWasOff := not ((PtInRect(selRect.topLeft, okRect)) and (PtInRect(selRect.botRight, okRect)));														Action_ListScroll(gListScroll, 20);														OffsetRect(selRect, 0, kSkip);														if lastWasOff and PtInRect(selRect.topLeft, okRect) and PtInRect(selRect.botRight, okRect) then															begin																InvertRect(selRect);																FrameRect(selRect);															end;														FrameRect(mFrame);													end;											end										else if pt.v + (mframe.bottom - mframe.top) > (gListWind^.portRect.bottom - gListWind^.portRect.top - 15) then											begin												if (GetControlValue(gListScroll) <> GetControlMaximum(gListScroll)) then													begin														FrameRect(mFrame);														lastWasOff := not ((PtInRect(selRect.topLeft, okRect)) and (PtInRect(selRect.botRight, okRect)));														Action_ListScroll(gListScroll, 21);														OffsetRect(selRect, 0, -kSkip);														if lastWasOff and PtInRect(selRect.topLeft, okRect) and PtInRect(selRect.botRight, okRect) then															begin																InvertRect(selRect);																FrameRect(selRect);															end;														FrameRect(mFrame);													end;											end										else											begin												FrameRect(mframe);												OffsetRect(mFrame, 0, pt.v - lastPt.v);												FrameRect(mframe);												lastPt := pt;											end;									end;							end;						FrameRect(mframe);						FrameRect(selRect);						PenMode(srcCopy);						PenPat(qd.black);						gCurrentCurs := GetCursor(cOpenHand);						SetCursor(gCurrentCurs^^);						InvertRect(selRect);						newCell := FigureCell(pt, kFigNewton);						if newCell > gList^.count then							newCell := gList^.count;						if (selCell <> newCell) then							begin{remove from old position}								tmpName := gList^.names[selCell];								for count := selCell to gList^.count - 1 do									gList^.names[count] := gList^.names[count + 1];{insert in new position}								for count := gList^.count downto newCell + 1 do									gList^.names[count] := gList^.names[count - 1];								gList^.names[newCell] := tmpName;								oldRes := curResFile;								UseResFile(gListRes);{here's the equivalent of the above code, only it works with resources}								resName2 := ResourceName(selCell + 300, levelResType);								tmpRes := Get1Resource(levelResType, selCell + 300);								MoveHHi(tmpRes);								HLock(tmpRes);								RemoveResource(tmpRes);								UpdateResFile(gListRes);								for count := selCell to gList^.count - 1 do									begin		{replace resource count+300 w/ resource count+301}										resName := ResourceName(count + 301, levelResType);										tmpRes2 := Get1Resource(levelResType, count + 301);										MoveHHi(tmpRes2);										HLock(tmpRes2);										RemoveResource(tmpRes2);										AddResource(tmpRes2, levelResType, count + 300, resName);										UpdateResFile(gListRes);										ReleaseResource(tmpRes2);									end;								for count := gList^.count downto newCell + 1 do									begin		{replace count+300 with count+299}										resName := ResourceName(count + 299, levelResType);										tmpRes2 := Get1Resource(levelResType, count + 299);										MoveHHi(tmpRes2);										HLock(tmpRes2);										RemoveResource(tmpRes2);										AddResource(tmpRes2, levelResType, count + 300, resName);										UpdateResFile(gListRes);										ReleaseResource(tmpRes2);									end;								AddResource(tmpRes, levelResType, newCell + 300, resName2);								UpdateResFile(gListRes);								ReleaseResource(tmpRes);								UseResFile(oldRes);							end;						Update_ListWind;					end				else	{single clicked... could be first part of dubl-click}					begin						InvertRect(selRect);					end;			end;	end;	procedure InitNewSet;		var			r: rect;			winTitle: Str255;	begin		Init_Palette;		if (not gDoingOpenUp) then			begin				gWorldWind := MakeWorldWindow('Untitled', kMapKind);				PeckNewWindow(gWorldWind);			end;		gListWind := GetNewCWindow(wList, nil, WindowPtr(-1));		PeckNewWindow(gListWind);		MoveWindow(gListWind, gPrefs.listRec.left, gPrefs.listRec.top, FALSE);		SizeWindow(gListWind, gPrefs.listRec.right - gPrefs.listRec.left, gPrefs.listRec.bottom - gPrefs.listRec.top, FALSE);		ShowWindow(gListWind);		SetPort(gListWind);		gList^.count := 0;		gSetDirty := FALSE;		gSetName := 'Untitled';		winTitle := concat(gSetName, ' Level List');		SetWTitle(gListWind, winTitle);		gWindKind := list;		gListScroll := GetNewControl(cScroll, gListWind);		gListHScroll := GetNewControl(cScroll, gListWind);		SetControlMinimum(gListScroll, 1);		SetControlMaximum(gListScroll, 1);		SetControlValue(gListScroll, 1);		ShowControl(gListScroll);		ShowControl(gListHScroll);		gLastCursor := cArrow;		Update_ListScroll;	end;	procedure MakeNewSet;		var			myReply: StandardFileReply;			winTitle: Str255;	begin		StandardPutFile('Name your new world file:', 'Untitled', myReply);		if myReply.sfGood then			begin				InitNewSet;				SetControlValue(gListScroll, 1);				SetControlMaximum(gListScroll, 1);				SetControlMinimum(gListScroll, 1);				FSpCreateResFile(myReply.sfFile, kFilecreator, kFileType, 1);				gListRes := FspOpenResFile(myReply.sfFile, fsRdWrPerm);				gSetName := myReply.sfFile.name;				winTitle := concat(gSetName, ' Level List');				SetWTitle(gListWind, winTitle);				winTitle := concat(gSetName, ' Worldview');				SetWTitle(gWorldWind, winTitle);				gList^.count := 0;				Update_ListWind;				Get_MapPrefs;			end;	end;	function ResourceName (id: integer;									daKind: ResType): str255;		var			h: handle;			myId: integer;			myType: ResType;			myName: str255;	begin		ResourceName := '';		h := GetResource(daKind, id);		if h <> nil then			begin				GetResInfo(h, myId, myType, myName);				ReleaseResource(h);				ResourceName := myName;			end;	end; {ResourceName}	procedure OpenSet;		var			myReply: StandardFileReply;			myTypes: SFTypeList;			myErr: OSErr;			count: integer;			myMax: integer;			winTitle: Str255;	begin		myTypes[0] := kFileType;		StandardGetFile(nil, 1, ConstSFTypeListPtr(@myTypes), myReply);		if (myReply.sfGood) then			begin				gDoingOpenUp := true;				InitNewSet;				gDoingOpenUp := false;				gListRes := FspOpenResFile(myReply.sfFile, fsRdWrPerm);				gSetName := myReply.sfFile.name;				winTitle := concat(gSetName, ' Level List');				SetWTitle(gListWind, winTitle);				winTitle := concat(gSetName, ' Worldview');{DKP load in the world here}				gWorldWind := LoadWorldWindow(winTitle, 0);				PeckNewWindow(gWorldWind);				gList^.count := Count1Resources(kLevelResType);				for count := 301 to gList^.count + 300 do					gList^.names[count - 300] := ResourceName(count, kLevelResType);				HideControl(gListScroll);				myMax := gList^.count;				if myMax < 1 then					myMax := 1;				SetControlMaximum(gListScroll, myMax);				SetControlMinimum(gListScroll, 1);				SetControlValue(gListScroll, 1);				Update_ListScroll;				ShowControl(gListScroll);				Update_ListWind;				Get_MapPrefs;			end;	end;	procedure Undo_LastAction;		var			count: integer;			oldPort: GrafPtr;			w: integer;	begin		SysBeep(5);	end;	procedure DoMapInfo;		var			w: integer;			listLoc: integer;			oldName: str255;			newName: str255;	begin		w := FindMapWind(gActiveMap);		listLoc := FindMapInList(w);		GetWTitle(gActiveMap, oldName);		WorldMapInfo(gActiveMap);		GetWTitle(gActiveMap, newName);		if (oldName <> newName) then			gList^.names[listLoc] := newName;	end;	procedure DoFileMenu (item: integer);		var			w: windowptr;	begin		if (item = iQuit) then			PeckQuit;		if (item = iNewSet) then			MakeNewSet;		if (item = iOpenSet) then			OpenSet;		if (item = iClose) then			if (gWindKind = list) then				PeckKillWindow(gListWind)			else if (gWindKind = map) then				begin					w := gActiveMap;					PeckKillWindow(w);				end			else if (gWindKind = world) then				begin					PeckKillWindow(gWorldWind);				end;		if (item = iSave) then			begin				if (gWindKind = map) then					SaveMap(FindMapWind(gActiveMap))				else if (gWindKind = world) then					begin						SaveWorld(gWorldWind);					end;			end;		if (item = iSaveAs) then			if (gWindKind = map) then				DoMapInfo;	end;	procedure DoEditMenu (item: integer);	begin		if (item = iUndo) then			Undo_LastAction;		if (item = iPaste) then			WorldPaste(gWorldWind);	end;	procedure DoMapMenu (item: integer);	begin		if (item = iNewMap) then			CreateNewMap		else if (item = iMapInfo) then			DoMapInfo		else if (item = iImport) then			ImportBoard(gActiveMap)		else if ( item = iWorldID ) then begin			SysBeep(5);			map_glob_save := false;			CloseWorldWindow(gWorldWind);			map_glob_save := true;			kWorldResID := kWorldResID + 1;			gWorldWind := LoadWorldWindow('New Window',0);		end;	end;	procedure ______________;	begin	end;{-------------------MAIN EVENT DOING CODE GOES HERE-------------------------}	procedure doUpdate (theWindow: windowPtr;									resized: boolean);	begin		if (theWindow = gListWind) and (gListWind <> nil) then			begin				if resized then					Update_ListScroll;				Update_ListWind;			end		else if (theWindow = gPalette) then {check for palette here!}			Update_Palette		else if (theWindow = gWorldWind) then			DrawWorld(theWindow)		else if (theWindow <> nil) then			DrawWorld(theWindow);	end;	procedure doMenu (theMenu: menuHandle;									theItem: integer);	begin		if (theMenu = gFileMenu) then			DoFileMenu(theItem)		else if (theMenu = gEditMenu) then			DoEditMenu(theItem)		else if (theMenu = gMapMenu) then			DoMapMenu(theItem);	end;	procedure doMouseDown (theWindow: windowPtr;									where: point;									when: longint;									mods: integer);		var			mouse: point;			part: integer;			control: ControlHandle;			which: integer;			op: GrafPtr;			shouldHide: boolean;			startTick: longInt;			whichLevel: integer;			whichWind: integer;			count: integer;			name: Str255;	begin		mouse := where;{    GlobalToLocal(mouse);}		shouldHide := (gPalette <> nil) & (theWindow <> gPalette) & WindowsIntersect(gPalette, theWindow);		if shouldHide then			begin				HideWindow(gPalette);				DoUpdate(theWindow, FALSE);			end;		if ((theWindow = gWorldWind) and (gWorldWind <> nil)) or (FindMapWind(theWindow) <> -1) then			begin				WorldWindowClick(theWindow, where, mods);{if the current tool is the eyedrop tool, better draw the palette!}				if WorldPaletteUpdate(theWindow) then					Update_Palette;				if (theWindow = gWorldWind) then					begin						whichLevel := GetOpenLevel(theWindow);						if (whichLevel <> 0) then							begin								whichWind := -1;								for count := 1 to gMaps.count do									begin										GetWTitle(gMaps.windows[count], name);										if name = gList^.names[whichLevel] then											whichWind := count;									end;								if (whichWind <> -1) then									SelectWindow(gMaps.windows[whichWind])								else if (whichLevel <= gList^.count) then									MakeNewMap(gList^.names[whichLevel])								else									SysBeep(5);							end;					end;			end		else {this ELSE ends almost at the bottom of the proc}			begin				part := FindControl(mouse, theWindow, control);				if control <> nil then					begin						if control = gListScroll then							begin								case part of									129: 										begin											part := TrackControl(control, mouse, nil);											if part = 129 then												Update_ListWind;										end;									20, 21, 22, 23: 										while button do											begin												part := TrackControl(control, mouse, @Action_ListScroll);												if shouldHide then													ShowWindow(gPalette);											end;									otherwise										sysbeep(10);								end;							end;					end				else					begin						if (theWindow = gPalette) and (gPalette <> nil) then							begin								LocalToGlobal(where);								GetPort(op);								SetPort(gPalette);								GlobalToLocal(where);								Mouse_Palette(where);								SetPort(op);							end						else if (theWindow = gListWind) and (gListWind <> nil) then							Mouse_ListWind(where)						else if (theWindow = gWorldWind) and (gWorldWind <> nil) then							WorldWindowClick(gWorldWind, where, mods);					end;			end;{big thing involving the mainwind}		if shouldHide then			ShowWindow(gPalette);	end;	procedure doKeyDown (theWindow: windowPtr;									theKey: char;									mods: integer);	begin		if (theKey = char(9)) and (gPalette <> nil) then			begin{user hit tab key, so cycle between curTool and pencil}				if (gCurTool = kPencil) then					begin						gCurTool := gToolSave;					end				else					begin						gToolSave := gCurTool;						gCurTool := kPencil;					end;				Update_Palette;			end		else if (gWorldWind <> nil) and (gWindKind = world) then			WorldKey(gWorldWind, theKey)		else if (gWindKind = map) and (FindMapWind(gActiveMap) <> -1) then			WorldKey(gActiveMap, theKey);	end;	procedure doCloseWindow (theWindow: windowPtr);	begin		if (theWindow = gListWind) and (gListWind <> nil) then			Close_ListWind		else if (theWindow = gWorldWind) and (gWorldWind <> nil) then			begin				;{ack! if they haven't already closed the list wind, close it.}			end		else if (FindMapWind(theWindow) <> -1) then			begin				Close_MapWind(FindMapWind(theWindow));				if gMaps.count > 0 then					SelectWindow(gMaps.windows[gMaps.count])				else if gListWind <> nil then					begin						SelectWindow(gListWind);						gWindKind := list;					end;			end;	end;	procedure doAbout;	begin		Q_OKDialog(dAbout);	end;	procedure doIdle (theWindow: windowPtr);	begin	end;	procedure doKillMenu (theMenu: menuHandle);	begin	end;	procedure doActivate (theWindow: windowPtr;									active: boolean);		var			fmw: integer;			count: integer;			w: integer;	begin{i wrote this code about five years ago.}{now i'm paying the price.}{WHAT DOES IT DO & HOW DOES IT DO IT?}{-dave p. '97}		if (theWindow = gWorldWind) and (gWorldWind <> nil) then			begin				WorldActivate(gWorldWind, active);				if (active) then					begin{make it look backgroundish}						if (gWindKind = map) or (gWindKind = palette) then							begin								WorldActivate(gActiveMap, false);							end						else if (gWindKind = list) then							begin								HiliteControl(gListScroll, 255);								HiliteControl(gListHScroll, 255);								HiliteWindow(gListWind, FALSE);							end;					end;{put palette always in front}				if (gPalette <> nil) then					begin						BringToFront(gPalette);					end;{the front wind is now a world wind.}				gWindKind := world;			end		else if (theWindow = gListWind) and (gListWind <> nil) then			begin			{activate the list window}				if active then					begin						if (gWindKind = map) or (gWindKind = palette) then							begin								w := FindMapWind(gActiveMap);								if (w <> -1) then									WorldActivate(gActiveMap, false);							end;						HiliteControl(gListScroll, 0);						HiliteControl(gListHScroll, 0);						HiliteWindow(gListWind, TRUE);						WorldActivate(gWorldWind, false);						if (gPalette <> nil) then							begin								BringToFront(gPalette);							end;						gWindKind := list;					end {active}				else					begin						sysbeep(10);					end;			end		else if (theWindow <> nil) & (findMapWind(theWindow) <> -1) then			begin		{activate a map}				if active then					begin						if ((gWindKind = list) or (gWindKind = palette)) and (gListWind <> nil) then							begin								HiliteControl(gListScroll, 255);								HiliteControl(gListHScroll, 255);								HiliteWindow(gListWind, FALSE);							end						else if (gWindKind = map) and (gActiveMap <> nil) then							begin								w := FindMapWind(gActiveMap);								if (w <> -1) then									WorldActivate(gActiveMap, false);							end						else if (gWindKind = world) then							begin								WorldActivate(gWorldWind, false);							end;						w := FindMapWind(gActiveMap);						if (w <> -1) then							WorldActivate(gActiveMap, active);						if (gPalette <> nil) then							begin								BringToFront(gPalette);							end;						gWindKind := map;						gActiveMap := theWindow;					end				else					begin						sysbeep(10);					end;			end		else if (theWindow = gPalette) and (gPalette <> nil) then			begin		{activate ??? palette}				if active then					begin		{I DON'T THINK SO!}						if (gWindKind = map) and (gActiveMap <> nil) then							begin								if findMapWind(gActiveMap) <> -1 then									SelectWindow(gActiveMap);							end						else if (gWindKind = world) then							begin								SelectWindow(gWorldWind);								gWindKind := world;							end						else							begin								SelectWindow(gListWind);								gWindKind := palette;							end;					end				else if (gWindKind = map) then					begin						w := FindMapWind(gActiveMap);						if (w <> -1) then							WorldActivate(gActiveMap, false);					end;			end;		if (gPalette <> nil) then			Update_Palette;	end;	procedure DoOnceThroughLoop;		var			m: point;			r: rect;			w: integer;			funk: boolean;			op: GrafPtr;	begin{    if (FrontWindow = gListWind) and (gListWind <> nil) then}{    gWindKind := list}{    else if (FrontWindow = gPalette) and (gPalette <> nil) then}{    gWindKind := palette}{    else if (FrontWindow <> nil) & (FindMapWind(FrontWindow) <> -1) then}{    gWindKind := map}{    else}		if FrontWindow = nil then			gWindKind := none;		UpdateMenus;		funk := FALSE;		if (gPalette <> nil) then			begin				GetPort(op);				SetPort(gPalette);				GetMouse(m);				r := gPalette^.portRect;				r.top := r.top - 10;				if PtInRecT(m, r) then					begin						Funk := TRUE;						gLastCursor := cArrow;						InitCursor;					end;				SetPort(op);			end;		if not funk then			if (gWindKind = list) and (gListWind <> nil) then				begin					GetMouse(m);					r := gListWind^.portRect;					r.right := r.right - 15;					r.bottom := r.bottom - 15;					if PtInRect(m, r) then						if (gLastCursor <> cOpenHand) then							begin								gCurrentCurs := GetCursor(cOpenHand);								gLastCursor := cOpenHand;								SetCursor(gCurrentCurs^^);							end;					if not PtInRect(m, r) then						if (gLastCursor <> cArrow) then							begin								gLastCursor := cArrow;								InitCursor;							end;				end			else if (gWindKind = map) and (gActiveMap <> nil) then				begin	{in map wind; must change cursor appropriately}				end			else if (gWindKind <> list) and (gWindKind <> world) and (FrontWindow <> nil) and (gLastCursor <> cArrow) then				begin					gLastCursor := cArrow;					InitCursor;				end;	end;{------------------------- Peck Event Main Routines -------------------------------}{$S peckstuff}	procedure peckInit (howMany: integer);		var			counter: integer;	begin		for counter := 1 to howMany do						{Get enough pointer/heap memory}			moreMasters;		getPort(fstPtr);		curNumWindows := 0;									{Initalize These Variables}		curNumMenus := 0;		wantsToQuit := false;		currentWindow := 0;		for counter := 0 to MaxWind do								{Clear window array}			windows[counter] := nil;		for counter := 0 to MaxMenu do								{Clear menu array}			menus[counter] := nil;		initCursor;												{Arrow Cursor}	end;	procedure peckQuit;	begin		wantsToQuit := true;				{Will halt execution next time main peckEvents gets called}	end;	procedure peckNewWindow (var aWindow: windowPtr);	begin		curNumWindows := curNumWindows + 1;		if curNumWindows > MaxWind then			curNumWindows := MaxWind		else			begin				windows[curNumWindows] := aWindow;				setPort(aWindow);				currentWindow := curNumWindows;			end;	end;	function findAWindow (wFind: windowPtr): integer;		var			winSearchCount: integer;	begin		winSearchCount := 1;		while (windows[winSearchCount] <> wFind) and (winSearchCount < curNumWindows) do			winSearchCount := winSearchCount + 1;		if winSearchCount <= curNumWindows then			findAWindow := winSearchCount		else			findAWindow := 0;	end;	procedure peckKillWindow (var aWindow: windowPtr);		var			recordNum: integer;			wKcounter: integer;	begin		recordNum := findAWindow(aWindow);				{Search array for the window}		doCloseWindow(windows[recordNum]);		if recordNum > 0 then			begin				curNumWindows := curNumWindows - 1;				if curNumWindows > 0 then					begin						for wKcounter := recordNum to curNumWindows do			{Fix List}							windows[wKcounter] := windows[wKcounter + 1];						windows[curNumWindows + 1] := nil;						setPort(windows[1]);					end				else					setPort(fstPtr);													{Whatever it was before}			end;	end;	procedure peckNewMenu (var aMenu: menuHandle;									disp: boolean);	begin		curNumMenus := curNumMenus + 1;		if curNumMenus > MaxMenu then			curNumMenus := MaxMenu		else			begin				menus[curNumMenus] := aMenu;				insertMenu(menus[curNumMenus], 0);			end;		if disp then			drawMenuBar;	end;	function findMenu (mFind: menuHandle): integer;		var			menSearchCount: integer;	begin		menSearchCount := 1;		while (menus[menSearchCount] <> mFind) and (menSearchCount <= curNumMenus) do			menSearchCount := menSearchCount + 1;		if menSearchCount <= curNumMenus then			findMenu := menSearchCount		else			findMenu := 0;	end;	function findMenuByID (mFind: integer): integer;		var			msc: integer;	begin		msc := 1;		while (menus[msc]^^.menuID <> mFind) and (msc <= curNumMenus) do			msc := msc + 1;		if msc <= curNumMenus then			findMenuByID := msc		else			findMenuByID := 0;	end;	procedure peckKillMenu (var aMenu: menuHandle);		var			recordNum: integer;			wKcounter: integer;	begin		recordNum := findMenu(aMenu);					{Search array for the menu}		if recordNum > 0 then			begin				doKillMenu(menus[recordNum]);				curNumMenus := curNumMenus - 1;				if curNumMenus > 0 then					begin						for wKcounter := recordNum to curNumMenus do			{Fix List}							menus[wKcounter] := menus[wKcounter + 1];						menus[curNumMenus + 1] := nil;					end;			end;	end;	procedure appleSelect (theItem: integer);	begin		doAbout;	end;	procedure peckApple (aboutName: str255);		var			appleTitle: Str255;			appleID: integer;			dummy: boolean;	begin		appleTitle := ' ';		appleTitle[1] := char($14);		appleID := 1;		hisApple := NewMenu(appleID, appleTitle);		appendMenu(hisApple, aboutName);		appendMenu(hisApple, '(-');		AppendResMenu(hisApple, 'DRVR');		peckNewMenu(hisApple, false);	end;	procedure doEvent (theEvent: eventRecord);		var			evnWhat: integer;			wCIn: windowPtr;			winNum: integer;			resultCode: integer;			aBrect: rect;			theSize: longint;			menuID, item: integer;			menNum: integer;			wCntr: integer;			evnChar: char;			evnMods: integer;			itemName: str255;			oldPort: grafPtr;			aDummy: integer;			isActive: boolean;			mouseLoc: Point;	begin		evnWhat := theEvent.what;		if evnWhat = nullEvent then			begin				if currentWindow > 0 then					for wCntr := 1 to curNumWindows do						doIdle(windows[wCntr]);				UpdateMenus;				if (gWorldWind <> nil) and (gWindKind = world) then					begin						GetMouse(mouseLoc);						MouseOverWorldWindow(gWorldWind, mouseLoc, theEvent.modifiers);					end				else if (gWindKind = map) then					begin						GetMouse(mouseLoc);						MouseOverWorldWindow(gActiveMap, mouseLoc, theEvent.modifiers);					end;			end;		if evnWhat = mouseDown then			begin				resultCode := findWindow(theEvent.where, wCIn);				if resultCode = inContent then					begin						winNum := findAWindow(wCIn);						if (wCin = gPalette) then							begin								globalToLocal(theEvent.where);								doMouseDown(gPalette, theEvent.where, theEvent.when, theEvent.modifiers);							end						else if (currentWindow <> winNum) then							begin											{Make sure it was current wind}								setPort(wCIn);	{Set it to the wind it was clicked}								currentWindow := winNum;					{In!}								selectWindow(wCIn);							end						else							begin								globalToLocal(theEvent.where);								if winNum > 0 then									doMouseDown(wCin, theEvent.where, theEvent.when, theEvent.modifiers);							end;					end;				if resultCode = inDrag then					begin						aBrect := qd.screenBits.bounds;						dragWindow(wCIn, theEvent.where, aBrect);						if (wCin <> gPalette) then							begin								setPort(wCIn);								selectWindow(wCIn);							end;					end;				if resultCode = inSysWindow then					systemClick(theEvent, wCIn);				if resultCode = inGoAway then					if trackGoAway(wCIn, theEvent.where) then						peckKillWindow(wCIn);				if resultCode = inGrow then					begin						aBrect := qd.screenBits.bounds;						setPort(wCIn);						theSize := growWindow(wCIn, theEvent.where, aBrect);						sizeWindow(wCIn, loWord(theSize), hiWord(theSize), true);						eraseRect(wCIn^.portRect);						drawGrowIcon(wCIn);						winNum := findAWindow(wCIn);						if ((wCIn = gWorldWind) and (gWorldWind <> nil)) or (FindMapWind(wCin) <> -1) then							ResizeWorld(wCin)						else							doUpdate(windows[winNum], true)					end;				if (resultCode = inZoomIn) or (resultCode = inZoomOut) then					begin						winNum := findAWindow(wCIn);						setPort(wCIn);						zoomWindow(wCIn, resultCode, true);						eraseRect(wCIn^.portRect);						doUpdate(windows[winNum], true)					end;				if resultCode = inMenuBar then					begin						theSize := menuSelect(theEvent.where);						hiliteMenu(0);						menuID := hiWord(theSize);						if menuID <> 0 then							begin								item := loWord(theSize);								menNum := findMenuByID(menuID);								if (menNum <> 1) then									doMenu(menus[menNum], item)								else if item = 1 then									doAbout								else									begin										GetMenuItemText(menus[menNum], item, itemName);										aDummy := openDeskAcc(itemName);										setPort(windows[currentWindow]);									end;							end;					end;			end;		if evnWhat = updateEvt then			begin				getPort(oldPort);				setPort(windowPtr(theEvent.message));				beginUpdate(windowPtr(theEvent.message));				winNum := findAWindow(windowPtr(theEvent.message));				if winNum > 0 then					doUpdate(windowPtr(theEvent.message), false);				endUpdate(windowPtr(theEvent.message));				setPort(oldPort);			end;		if evnWhat = activateEvt then			begin				isActive := (BitAnd(theEvent.modifiers, activeFlag) <> 0);				wCIn := windowPtr(theEvent.message);				winNum := findAWindow(wCIn);				if isActive then					begin						setPort(wCIn);						selectWindow(wCIn);					end;				doActivate(wCIn, isActive);				currentWindow := winNum;			end;		if evnWhat = keyDown then			begin				evnChar := char(BitAnd(theEvent.message, charCodeMask));				evnMods := theEvent.modifiers;				if BitAnd(evnMods, cmdKey) > 0 then					begin						theSize := menuKey(evnChar);						hiliteMenu(0);						menuID := hiWord(theSize);						if menuID = 0 then							doKeyDown(windows[currentWindow], evnChar, evnMods)						else							begin								item := loWord(theSize);								menNum := findMenuByID(menuID);								doMenu(menus[menNum], item);							end;					end				else					doKeyDown(windows[currentWindow], evnChar, evnMods);			end;	end;	procedure peckMain;		var			isMine: boolean;			allMask: integer;			anEvent: eventRecord;			evnCode: integer;	begin		gWNEImplemented := (NGetTrapAddress(WNE_TRAP_NUM, ToolTrap) <> NGetTrapAddress(UNIMPLEMENTED_TRAP_NUM, ToolTrap));		while not wantsToQuit do										{Make sure user doesn't wanna leave}			begin				if gWNEImplemented then					isMine := waitNextEvent(everyEvent, anEvent, 10, nil)				else					begin						systemTask;						isMine := getNextEvent(everyEvent, anEvent);					end;				if (isMine) or (anEvent.what = nullEvent) then				{Null event returns false}					doEvent(anEvent);				DoOnceThroughLoop;			end;	end;	procedure peckHalt;		var			winCountr, menCountr: integer;	begin		for winCountr := 1 to curNumWindows do			if windows[winCountr] <> nil then				disposeWindow(windows[winCountr]);		for menCountr := 1 to curNumMenus do			if menus[menCountr] <> nil then				disposeMenu(menus[menCountr]);	end;{$S main}{---------- End of Peck Event Routines -----------}begin{init}MaxApplZone;MoreMasters;MoreMasters;MoreMasters;InitGraf(@qd.thePort);InitFonts;InitWindows;InitMenus;TEInit;InitDialogs(nil);InitCursor;FlushEvents(everyEvent,0);{hack}	gDoingOpenUp := false;	gToolSave := kSelect;	gDontShow := false;kWorldResID := 128;map_glob_save := true;	Init_Design;	PeckMain;	if (gListWind <> nil) then		Save_MapPrefs;	if (gListWind <> nil) then		PeckKillWindow(gListWind);	Save_Prefs;	Kill_MapPrefs;	Close_Design;	PeckHalt;end.
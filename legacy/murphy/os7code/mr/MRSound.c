// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRSound.c// Auth: Dave Peck// Date: 7/2/97// Desc: sound routines for MR//       this version uses a multibuffering approach to music. //       but it still doesn't work right. DERN.// ----------------------------------------------------------------// Includes// ----------------------------------------------------------------#include "MRSound.h"#include "MRResources.h"#include <string.h>#include <math.h>#include "MRPrefs.h"// ----------------------------------------------------------------// Constants// ----------------------------------------------------------------#define MAX_SND_CHANS				3#define SOUND_RES_TYPE				'snd '#define MAX_MUSIC_STRING_LENGTH		128#define FADE_OUT_STEPS				15#define FADE_DELAY_TICKS			2#define FADE_IN_STEPS				255#define FADE_IN_DELAY_TICKS			2#define MAX_MUSIC_VOL				255#define MAX_RELEASE_IDS				128// ----------------------------------------------------------------// Data Structures// ----------------------------------------------------------------typedef struct MRMusicInfoStruct {	char			musicStr[ MAX_MUSIC_STRING_LENGTH ];	int				mStrLen;	int				currentLoc;	int				loopLoc;	int				baseResID;	SndChannelPtr	musicChan;	Handle			currentSnd, nextSnd;	int				currentID, nextID;	long			hOffset;		// used by the keep-music-going routines:	Boolean			loadNextSound;	Handle			releaseSnd;		// for fading music in.	// note that fade-in is an asynch operation,	// which means it can be gradual;	// fade-out for music is rapid and synch.	unsigned short  lv, rv;	unsigned short	dl, dr;	long			lastFadeTick;	Boolean			doFade;		// true only if there was a fatal error (i.e. not enough memory)	// and the music must stop playing	Boolean			fatalMusicError;	Boolean			fatalErrorNoted;		// For careful memory deallocation	Boolean			canReleaseSound;	Boolean 		goodToRelease;	Handle			toRelease;};typedef struct MRMusicInfoStruct MRMusicInfoStruct;typedef MRMusicInfoStruct *MRMusicInfo;// ----------------------------------------------------------------// Global Data// ----------------------------------------------------------------// for soundsBoolean 			sound_playSounds, sound_playMusic;SndChannelPtr		sound_chans[ MAX_SND_CHANS ];Boolean				sound_chanUsage[ MAX_SND_CHANS ];char				sound_handleState[ MAX_SND_CHANS ];// for keeping track of sounds to releaseshort				sound_releaseIDs[ MAX_RELEASE_IDS ];short				sound_IDCount;// for musicBoolean				sound_playingMusic;MRMusicInfo			sound_musicInfo;// ----------------------------------------------------------------// Function Prototypes// ----------------------------------------------------------------void Sound_PlayMoreMusic( MRMusicInfo mInfo );// ----------------------------------------------------------------// Functions// ----------------------------------------------------------------// standard sound callback proc.pascal void Sound_StdCallback( SndChannelPtr theChan,							   SndCommand* theCmd ) {}// music callbackpascal void Sound_MusicCallback( SndChannelPtr theChan,							     SndCommand* theCmd ) {	Sound_PlayMoreMusic( (MRMusicInfo) theCmd->param2 );}int ResIDFromInfo( int baseID, char someChar ) {	return ((int)					baseID +					(((int)someChar) - (int)'A')			);}void MoveLocations( MRMusicInfo mInfo ) {	mInfo->currentLoc += 1;		if ( mInfo->currentLoc == mInfo->mStrLen )		mInfo->currentLoc = mInfo->loopLoc;}void SetLoopLoc( MRMusicInfo mInfo ) {	int i;		mInfo->loopLoc = 1;		for (i=0; i<mInfo->mStrLen; i++)		if (mInfo->musicStr[i]=='x')			mInfo->loopLoc = i;				for (i=mInfo->loopLoc; i<mInfo->mStrLen; i++)		mInfo->musicStr[i] = mInfo->musicStr[i+1];			mInfo->mStrLen -= 1;}void Sound_PlayMoreMusic( MRMusicInfo mInfo ) {	// do the following.	SndCommand cmd;		if ( mInfo->fatalMusicError ) {		mInfo->fatalErrorNoted = true;		return;	}		// immediately play the current music handle.		cmd.cmd = bufferCmd;		cmd.param1 = 0;		cmd.param2 = mInfo->hOffset + (long)(*(mInfo->currentSnd));					//(long)(*(mInfo->currentSnd));		(void) SndDoImmediate( mInfo->musicChan, &cmd );		//	(void) SndPlay( mInfo->musicChan, (SndListResource**)mInfo->currentSnd, true );			cmd.cmd = callBackCmd;		cmd.param1 = 0;		cmd.param2 = (long) mInfo;				(void) SndDoCommand( mInfo->musicChan, &cmd, true );		// now we're safe to calculate more info.	//MoveLocations( mInfo );	mInfo->currentLoc += 1;		if ( mInfo->currentLoc == mInfo->mStrLen )		mInfo->currentLoc = mInfo->loopLoc;	mInfo->loadNextSound = true;		if ( mInfo->releaseSnd ) {		mInfo->toRelease = mInfo->releaseSnd;		mInfo->canReleaseSound = true;		mInfo->releaseSnd = NULL;	}}// init and close soundsBoolean MRSoundInit() {	int i;		// regardless of where we are, set it all to nil:	sound_musicInfo = NULL;	for ( i = 0; i < MAX_SND_CHANS; i++ )		sound_chans[i] = NULL;	sound_IDCount = 0;	if ( MURPHY_DEBUG == DEBUG_OFF ) {		sound_playSounds = true;		sound_playMusic = true;		// allocate sound channels.		{			int 				chanCount;			SndCallBackUPP	 	theCallbackProc;			OSErr				errVal;						for ( chanCount = 0; chanCount < MAX_SND_CHANS; chanCount++ ) {				theCallbackProc =  NewSndCallBackProc( Sound_StdCallback );				errVal = SndNewChannel( &(sound_chans[chanCount]), 										sampledSynth, initStereo, 										theCallbackProc );				if ( errVal != noErr ) {					MRSoundClose();					return false;				}								sound_chanUsage[chanCount] = false;			}						// init music chan elsewhere						sound_playingMusic = false;		}				} else {		sound_playSounds = false;		sound_playMusic = false; 	}		return true;}Boolean GetSoundState() {	return sound_playSounds;}Boolean GetMusicState() {	return sound_playMusic;}void MRSoundClose() {	int i;		// dealloc stuff.	StopMusic();		for ( i = 0; i < MAX_SND_CHANS; i++ )		if (sound_chans[i])			SndDisposeChannel( sound_chans[i], true );	} void Sound_UpdateUsage() {	int i;	SCStatus theStatus;	OSErr theErr;	Boolean oldUsage;		for ( i = 0; i < MAX_SND_CHANS; i++ ) {		theErr = SndChannelStatus( sound_chans[i],								   sizeof( SCStatus ),								   &theStatus );		oldUsage = sound_chanUsage[i];		sound_chanUsage[ i ] = theStatus.scChannelBusy;	}	}// figure out which channels are free!Boolean Sound_FindFreeChan( int* chanNum ) {	// important to update usage info	Sound_UpdateUsage();		int i;	for ( i = 0; i < MAX_SND_CHANS; i++ ) 		if ( sound_chanUsage[ i ] == false ) {			*chanNum = i;			return true;		}		// as another attempt, try to kill the usage of one of the sound chans.	// If there are lots of sounds going off, the least important is the final.	/*	{		SndCommand theCmd;				theCmd.cmd = quietCmd;		theCmd.param1 = 0;		theCmd.param2 = 0;		(void) SndDoImmediate( sound_chans[MAX_SND_CHANS-1], &theCmd );		sound_chanUsage[MAX_SND_CHANS-1] = false;		*chanNum = MAX_SND_CHANS - 1;		return true;	}		// should never get here.	*/		// the above didn't work. Apparently SM3.0 doesn't like being bombarded	// with gazillions of immediate quietCmds.	return false;}void NextSoundPriority() {	if ( sound_playSounds ) {		int chanNum;				if ( !Sound_FindFreeChan( &chanNum ) ) {			// all channels are being used, so free one of them up.			SndCommand theCmd;						theCmd.cmd = quietCmd;			theCmd.param1 = 0;			theCmd.param2 = 0;			(void) SndDoImmediate( sound_chans[MAX_SND_CHANS-1], &theCmd );			sound_chanUsage[MAX_SND_CHANS-1] = false;		}			}}// play a soundvoid PlaySoundIDStereo( int soundID, short proximity, short signedPan ) {	// signedPan is from -10 to 10, with 0 centered.		// -10 -> 0 --> 1, 0  --> normalize	// 0 -> 10 --> .5, .5   --> normalize	// 10 -> 20 --> 0, 1  --> normalize		// set to general resfile:	if ( sound_playSounds ) {		int chanNum;				MRSndAlias();			if ( Sound_FindFreeChan( &chanNum ) ) {			// get and play the sound			Handle theSound;			SndCommand theCmd;			OSErr theErr;			MRPrefs mp = GetCurrentPrefs();						theSound = Get1Resource( SOUND_RES_TYPE, soundID );			if ( theSound == NULL ) {				MRRestoreResFile();				return;			}						// lock the sound for usage			sound_handleState[ chanNum ] = HGetState( theSound );			sound_chanUsage[ chanNum ] = true;						MoveHHi( theSound );			HLock( theSound );			AddSoundID( soundID );						// create the volume command:			theCmd.cmd = volumeCmd;						unsigned short leftVolume = (short)( (double)mp.soundVolume * (double)(((double)kMaxProximity-(double)proximity)/(double)kMaxProximity));			unsigned short rightVolume = leftVolume;			signedPan += 10;						double rightPerc = (((double)(signedPan))/((double)20));			double leftPerc = (double)1 - rightPerc;			double magnitude = rightPerc * rightPerc + leftPerc * leftPerc;			//magnitude = sqrt(magnitude);			//rightPerc /= magnitude;			//leftPerc /= magnitude;						leftVolume = (unsigned short) ((double)leftVolume * (double) leftPerc);			rightVolume = (unsigned short) ((double)rightVolume * (double) rightPerc);							theCmd.param1 = 0;			theCmd.param2 = (rightVolume << 16) | leftVolume;						// immediately set the amplitude of that sound:			(void)SndDoImmediate( sound_chans[chanNum], &theCmd );			//theErr = SndPlay( NULL, (SndListHandle) theSound, false );			theErr = SndPlay(sound_chans[ chanNum ], (SndListHandle) theSound, true);			if ( theErr != noErr ) {				MRRestoreResFile();				return;			}									// theErr := SndDoCommand(sound_chans[ chanNum ], &theCmd, false);		}				MRRestoreResFile();	}}// play a sound with given proximityvoid PlaySoundIDProx( int soundID, short proximity ) {	// set to general resfile:	if ( proximity > kMaxProximity )		return;			if ( sound_playSounds ) {		int chanNum;				MRSndAlias();			if ( Sound_FindFreeChan( &chanNum ) ) {			// get and play the sound			Handle theSound;			SndCommand theCmd;			OSErr theErr;			MRPrefs mp = GetCurrentPrefs();						theSound = Get1Resource( SOUND_RES_TYPE, soundID );			if ( theSound == NULL ) {				MRRestoreResFile();				return;			}						// lock the sound for usage			sound_handleState[ chanNum ] = HGetState( theSound );			sound_chanUsage[ chanNum ] = true;						MoveHHi( theSound );			HLock( theSound );			AddSoundID( soundID );				// create the volume command:			unsigned short funVol = 				(unsigned short)( (double)mp.soundVolume * (double)(((double)kMaxProximity-(double)proximity)/(double)kMaxProximity));			theCmd.cmd = volumeCmd;			theCmd.param1 = 0;			theCmd.param2 = ((unsigned short)funVol << 16) |							(unsigned short)funVol;					//theErr = SndPlay( NULL, (SndListHandle) theSound, false );			theErr = SndPlay(sound_chans[ chanNum ], (SndListHandle) theSound, true);			if ( theErr != noErr ) {				MRRestoreResFile();				return;			}						// immediately set the amplitude of that sound:			(void)SndDoImmediate( sound_chans[chanNum], &theCmd );						// theErr := SndDoCommand(sound_chans[ chanNum ], &theCmd, false);		}				MRRestoreResFile();	}}OSErr SetVolume(SndChannelPtr chan, unsigned short leftVolume, unsigned short rightVolume){	SndCommand		sndCmd;	OSErr			err;/*	sndCmd.cmd = volumeCmd;	sndCmd.param1 = 0;	sndCmd.param2 = (rightVolume << 16) | leftVolume;*/	sndCmd.cmd = ampCmd;	sndCmd.param1 = leftVolume;	sndCmd.param2 = 0;			err = SndDoImmediate(chan, &sndCmd);	return (err);}/*	GetVolume	This routine returns the left and right volumes for a channel.*/OSErr GetVolume(SndChannelPtr chan, unsigned short *leftVolume, unsigned short *rightVolume){	SndCommand		sndCmd;	unsigned long	volume;	OSErr			err;	unsigned short	vol;	/*	sndCmd.cmd = getVolumeCmd;	sndCmd.param1 = 0;	sndCmd.param2 = (long) &volume;*/	sndCmd.cmd = getAmpCmd;	sndCmd.param1 = 0;	sndCmd.param2 = (long) &vol;	err = SndDoImmediate(chan, &sndCmd);/*			if (err == noErr)	{		*leftVolume = volume & 0x0000FFFF;		*rightVolume = volume >> 16;	}*/	*leftVolume = vol;	*rightVolume = vol;		return (err);}// play a soundvoid PlaySoundID( int soundID ) {	// set to general resfile:	if ( sound_playSounds ) {		int chanNum;				MRSndAlias();			if ( Sound_FindFreeChan( &chanNum ) ) {			// get and play the sound			Handle theSound;			SndCommand theCmd;			OSErr theErr;			MRPrefs mp = GetCurrentPrefs();						theSound = Get1Resource( SOUND_RES_TYPE, soundID );			if ( theSound == NULL ) {				MRRestoreResFile();				return;			}						// lock the sound for usage			sound_handleState[ chanNum ] = HGetState( theSound );			sound_chanUsage[ chanNum ] = true;						MoveHHi( theSound );			HLock( theSound );			AddSoundID( soundID );						// create the volume command:			theCmd.cmd = volumeCmd;			theCmd.param1 = 0;			theCmd.param2 = ((unsigned short)mp.soundVolume << 16) |							(unsigned short)mp.soundVolume;						// immediately set the amplitude of that sound:			(void)SndDoImmediate( sound_chans[chanNum], &theCmd );						//theErr = SndPlay( NULL, (SndListHandle) theSound, false );			theErr = SndPlay(sound_chans[ chanNum ], (SndListHandle) theSound, true);			if ( theErr != noErr ) {				MRRestoreResFile();				return;			}						// theErr := SndDoCommand(sound_chans[ chanNum ], &theCmd, false);		}				MRRestoreResFile();	}}// fade the current music out!void FadeMusicIn() {	if ( sound_playingMusic ) {		MRPrefs mp = GetCurrentPrefs();		(void) SetVolume( sound_musicInfo->musicChan, 0, 0 );		sound_musicInfo->dl = sound_musicInfo->dr = 			(mp.musicVolume / FADE_IN_STEPS);					if ( sound_musicInfo->dl <= 0 )			sound_musicInfo->dl = sound_musicInfo->dr = 1;				sound_musicInfo->lv = sound_musicInfo->rv = 0;				sound_musicInfo->doFade = true;	}}// start musicvoid PlayMusic( int musicInfoResID, Boolean fadeIn ) {	// does the user have music on?	if ( sound_playMusic ) {		StringHandle theMusicInfo;			// kill currently playing music.		if ( sound_playingMusic )			StopMusic();					// grab the information.		MRSndAlias();				theMusicInfo = GetString( musicInfoResID );		if ( theMusicInfo != NULL ) {			char* tempStr;									MoveHHi( (Handle) theMusicInfo );			HLock( (Handle) theMusicInfo );						// okay, we've got a valid(?) music string.			// now make the music info data struct.			sound_musicInfo = (MRMusicInfo) DBG_NewPtrClear( sizeof( struct MRMusicInfoStruct ) );			sound_musicInfo->currentLoc = 0;			sound_musicInfo->loopLoc = 1;			sound_musicInfo->baseResID = musicInfoResID;						// init the music chan			{				SndCallBackUPP	 	theCallbackProc;				OSErr				errVal;				// allocate the music channel, which is mono sound.				theCallbackProc = NewSndCallBackProc( Sound_MusicCallback );				errVal = SndNewChannel( &(sound_musicInfo->musicChan), 										sampledSynth, initStereo,										theCallbackProc );				if ( errVal != noErr ) {					MRRestoreResFile();					return;				}				if ( fadeIn ) {					MRPrefs mp = GetCurrentPrefs();										(void) SetVolume( sound_musicInfo->musicChan, 0, 0 );					sound_musicInfo->dl = sound_musicInfo->dr = 						(mp.musicVolume / FADE_IN_STEPS);											if ( sound_musicInfo->dl <= 0 )						sound_musicInfo->dl = sound_musicInfo->dr = 1;											sound_musicInfo->doFade = true;				}			}						// set the music string correctly and release the strHandle			((Ptr)tempStr) = P2CStr( (*theMusicInfo) );			strcpy( (sound_musicInfo->musicStr), tempStr );			//DebugStr("\phithere");			//DebugStr(C2PStr( tempStr ) );			HUnlock( (Handle) theMusicInfo );			ReleaseResource( (Handle) theMusicInfo );						// we're in action!			sound_playingMusic = true;						sound_musicInfo->mStrLen = strlen( sound_musicInfo->musicStr );						SetLoopLoc( sound_musicInfo );						// move the current location			MoveLocations( sound_musicInfo );						// set currentID			sound_musicInfo->currentID = ResIDFromInfo( sound_musicInfo->baseResID,														sound_musicInfo->musicStr[																			 sound_musicInfo->currentLoc ] );																				// load up the currentSnd.			sound_musicInfo->currentSnd = Get1Resource( SOUND_RES_TYPE, 													    sound_musicInfo->currentID );			if ( sound_musicInfo->currentSnd == NULL ) {				MRRestoreResFile();				DBG_DisposePtr( (Ptr) sound_musicInfo );				sound_musicInfo = NULL;				sound_playingMusic = false;				return;			}						MoveHHi( sound_musicInfo->currentSnd );			HLock( sound_musicInfo->currentSnd );			HNoPurge( sound_musicInfo->currentSnd );			(void) GetSoundHeaderOffset( (SndListResource**) sound_musicInfo->currentSnd, 										 &(sound_musicInfo->hOffset) );													    			   			Sound_PlayMoreMusic( sound_musicInfo );		}				MRRestoreResFile();	}}// keep music goingvoid KeepMusicGoing() {	if ( sound_playingMusic ) {		if (( sound_musicInfo->canReleaseSound ) && (sound_musicInfo->goodToRelease)) {			HUnlock( sound_musicInfo->toRelease );			HPurge( sound_musicInfo->toRelease );			//ReleaseResource( sound_musicInfo->toRelease );			sound_musicInfo->canReleaseSound = false;		}			if ( sound_musicInfo->fatalErrorNoted ) {			// this routine reported a fatal error, and the callback routine			// now knows about it.			sound_playingMusic = false;			DBG_DisposePtr( (Ptr) sound_musicInfo );			sound_musicInfo = NULL;			return;		}				if ( sound_musicInfo->doFade ) {			if ( TickCount() - sound_musicInfo->lastFadeTick >= FADE_IN_DELAY_TICKS ) {				MRPrefs	mp = GetCurrentPrefs();							sound_musicInfo->lv += sound_musicInfo->dl;				sound_musicInfo->rv += sound_musicInfo->dr;								(void) SetVolume( sound_musicInfo->musicChan, sound_musicInfo->lv, sound_musicInfo->rv );								if ( sound_musicInfo->lv >= mp.musicVolume ) {					sound_musicInfo->doFade = false;					(void)SetVolume( sound_musicInfo->musicChan, mp.musicVolume, mp.musicVolume );					sound_musicInfo->lv = sound_musicInfo->rv = mp.musicVolume;				}								sound_musicInfo->lastFadeTick = TickCount();			}				}				if ( sound_musicInfo->loadNextSound ) {			int newID;						// calculate the ID of the sound.			newID = ResIDFromInfo( sound_musicInfo->baseResID,														sound_musicInfo->musicStr[																sound_musicInfo->currentLoc ] );			sound_musicInfo->goodToRelease = false;														if ( newID != sound_musicInfo->currentID ) {				//HUnlock( sound_musicInfo->currentSnd );				//HPurge( sound_musicInfo->currentSnd );								sound_musicInfo->releaseSnd = sound_musicInfo->currentSnd;				//ReleaseResource( sound_musicInfo->currentSnd );				sound_musicInfo->goodToRelease = true;								sound_musicInfo->currentID = newID;								MRSndAlias();				sound_musicInfo->currentSnd = Get1Resource( SOUND_RES_TYPE,															sound_musicInfo->currentID );				MRRestoreResFile();								// bad error...				if ( sound_musicInfo->currentSnd == NULL ) {					sound_musicInfo->fatalMusicError = true;					return;				}								MoveHHi( sound_musicInfo->currentSnd );				HLock( sound_musicInfo->currentSnd );				HNoPurge( sound_musicInfo->currentSnd );			}						sound_musicInfo->loadNextSound = false;		}	}}// fade the current music out!void FadeMusicOut() {	if ( sound_playingMusic ) {		unsigned short lv, rv;		unsigned short dl, dr;		int i;		long startTick;				// no longer fade in, just in case...		sound_musicInfo->doFade = false;				(void) GetVolume( sound_musicInfo->musicChan, &lv, &rv );		dl = (lv/FADE_OUT_STEPS);		dr = (rv/FADE_OUT_STEPS);		if ( dl <= 0 )			dl = 1;		if ( dr <= 0 )			dr = 1;					for ( i = 0; i < FADE_OUT_STEPS; i++ ) {			startTick = TickCount();			lv -= dl;			rv -= dr;			if ( lv < 0 )				lv = 0;			if ( rv < 0 )				rv = 0;			(void) SetVolume( sound_musicInfo->musicChan, lv, rv );			while ( TickCount() - startTick < FADE_DELAY_TICKS )				KeepMusicGoing();		}				sound_musicInfo->lv = sound_musicInfo->rv = 0;		(void)SetVolume( sound_musicInfo->musicChan, 0, 0 );	}}// stop current music.void StopMusic() {	if ( sound_playingMusic ) {		SndDisposeChannel( sound_musicInfo->musicChan, true );		if ( sound_musicInfo->currentSnd ) {			ReleaseResource( sound_musicInfo->currentSnd );		}		sound_playingMusic = false;		DBG_DisposePtr( (Ptr) sound_musicInfo );		sound_musicInfo = NULL;	}}// keep track of sounds to releasevoid AddSoundID( short id ) {	short count;		for ( count = 0; count < sound_IDCount; count++ )		if (sound_releaseIDs[count] == id)			return;		if ( sound_IDCount == MAX_RELEASE_IDS )		return;		sound_releaseIDs[ sound_IDCount++ ] = id;}// release all sounds from memory & reset the sound count.void FlushAllSounds() {	short count;	Handle res;		MRSndAlias();		for ( count = 0; count < sound_IDCount; count++ ) {		res = Get1Resource( 'snd ', sound_releaseIDs[count] );		if ( res ) {			HUnlock( res );			ReleaseResource( res );		}	}	sound_IDCount = 0;		MRRestoreResFile();}void SetSoundState( Boolean newState ) {	sound_playSounds = newState;}void SetMusicState ( Boolean newState ) {	sound_playMusic = newState;}
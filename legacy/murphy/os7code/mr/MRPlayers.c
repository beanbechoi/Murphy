// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRPlayers.c// Auth: Dave Peck// Date: 7/21/97// Desc: Utilities for handling players.// ----------------------------------------------------------------// Includes// ----------------------------------------------------------------#include "MRPlayers.h"#include "MRResources.h"#include <string.h>#include <stdio.h>#include "SWGameUtils.h"#include "MacColorOff.h"#include "MRSound.h"// ----------------------------------------------------------------// Constants// ----------------------------------------------------------------#define kPlayerListResType	'MRpl'#define kPlayerListResID	128#define kPSPict			157#define kPSHilitePict	158#define kPSConfirmPict	155#define kPSConfirmHilitePict	156#define kPSRevealStep	16#define kPSRevealDelay	3#define kPSPlayersSeen	4#define kPSPlayerHeight	16#define kPSCursorHeight	2#define kPSCursorWidth	7#define kPSSlideStep 	2//#define kPSNumSteps		4#define kPSSlideDelay	2// sounds#define kPSSoundID		200#define kPSKeyPressSnd	201#define kPSKeyDeleteSnd	202#define kPSBigNameSnd	203// ----------------------------------------------------------------// Data Structures// ----------------------------------------------------------------// ----------------------------------------------------------------// Global Data// ----------------------------------------------------------------MRPlayerList  players_list;// ----------------------------------------------------------------// Function Prototypes// ----------------------------------------------------------------// ----------------------------------------------------------------// Functions// ----------------------------------------------------------------void InitPlayers() {	// attempt to get the player list from the players resource file.	MRPlayersResFile();		players_list = (MRPlayerList) DBG_NewPtrClear( sizeof( struct MRPlayerListStruct ) );		if ( MRResourceExists( kPlayerListResType, kPlayerListResID ) ) {		Handle plist = Get1Resource( kPlayerListResType, kPlayerListResID );				HLockHi( plist );				if ( GetHandleSize( plist ) == sizeof( struct MRPlayerListStruct ) )			(*players_list) = (** ((MRPlayerListHand)plist) );		else if ( GetHandleSize( plist ) == sizeof( struct _mr_pls_one_t ) ) {			// got a version one player list. fix it up to most recent.			_mr_pls_one_p oldPList = (_mr_pls_one_p) 							DBG_NewPtrClear( sizeof (struct _mr_pls_one_t) );						(*oldPList) = (** ((_mr_pls_one_h)plist));						players_list->playerCount = oldPList->playerCount;			players_list->currentPlayer = oldPList->currentPlayer;			for ( short player = 0; player < MAX_PLAYERS; player++ ) {				_mr_pds_one_p c_from;				_mr_pds_one_p c_to;				c_from = &(oldPList->players[player]);				c_to = (_mr_pds_one_p) &(players_list->players[player]);				(*c_to) = (*c_from);				// rest of to fields are zeroed by NewPtrClear.			}						DBG_DisposePtr( (Ptr) oldPList );		}				HUnlock( plist );		ReleaseResource( plist );			} else {		// make one player		players_list->playerCount = 1;		players_list->currentPlayer = 0;		strcpy( players_list->players[0].myName, "Oliver Layton III" );	}		MRRestoreResFile();}void ClosePlayers() {	// save the player list to a resource.		Handle plist = DBG_NewHandleClear( sizeof( struct MRPlayerListStruct ) );		MRPlayersResFile();		HLockHi( plist );	(**((MRPlayerListHand)plist)) = (*players_list);	(void) MROverwriteResource( kPlayerListResType, kPlayerListResID, 							    plist, "Players List" );	HUnlock( plist );	ReleaseResource( plist );		MRRestoreResFile();	 	DBG_DisposePtr( (Ptr) players_list );	players_list = NULL;}MRPlayerData GetCurrentPlayer() {	// return current player data ptr.	return (MRPlayerData) (&(players_list->players[players_list->currentPlayer]));}char* GetPlayerName( MRPlayerData thePlayer ) {	char* retChar = (char*)DBG_NewPtrClear( sizeof(char)*MAX_PLAYER_NAME_LENGTH );		strcpy( retChar, thePlayer->myName );		return retChar;}void AddTicksToPlayer( MRPlayerData thePlayer, long theTicks ) {	long hourAdd, minAdd, secAdd, dayAdd;	long timeRemain = theTicks;		// this is ugly, but it works.	// (216000 = num secs in an hour.)	hourAdd = timeRemain/216000;	minAdd = (timeRemain%216000)/3600;	secAdd = ((timeRemain%216000)%3600)/60;	dayAdd = 0;		// now add seconds	thePlayer->secs += secAdd;	if ( thePlayer->secs >= 60 ) {		thePlayer->secs -= 60;		minAdd += 1;	}		// and minutes	thePlayer->mins += minAdd;	if ( thePlayer->mins >= 60 ) {		thePlayer->mins -= 60;		hourAdd += 1;	}		// and hours	thePlayer->hours += hourAdd;	if ( thePlayer->hours >= 24 ) {		thePlayer->hours -= 24;		dayAdd += 1;	}		// and days (!)	thePlayer->days += dayAdd;		// check for bad player info... and correct by zeroing	if ( thePlayer->secs < 0 )		thePlayer->secs = 0;	if ( thePlayer->mins < 0 )		thePlayer->mins = 0;	if ( thePlayer->hours < 0 )		thePlayer->hours = 0;	if ( thePlayer->days < 0 )		thePlayer->days = 0;}char* MakePlayerTimeString( MRPlayerData thePlayer ) {	char* retString = (char*)DBG_NewPtrClear( sizeof(char)*TIME_STRING_LENGTH );	if ( thePlayer->days == 0 ) {		if ( thePlayer->hours <= 9 )			sprintf( retString, "%.1d:%.2d.%.2d", (int)thePlayer->hours, (int)thePlayer->mins, (int)thePlayer->secs );		else			sprintf( retString, "%.2d:%.2d", (int) thePlayer->hours, (int) thePlayer->mins );	} else {		if ( thePlayer->days <= 9 )			sprintf( retString, "%.1dd %.2d:%.2d", (int)thePlayer->days, (int)thePlayer->hours, (int)thePlayer->mins );		else			// user has been playing entirely too much MR, and should			// leave their computer immediately to do more important things,			// such as watch television.			sprintf( retString, "%.2dd %.2dh", (int)thePlayer->days, (int)thePlayer->hours );	}		return retString;}#pragma mark === PS Dialog ==// the following section of code is specifically for the player// selection dialog// reveal me!void PSReveal( PSDialog psd ) {	// this routine is PPC-only. that's cuz it uses copybits	// alot.	int		numSteps = (psd->offRect.bottom / kPSRevealStep)/2;	int 	step;	Rect	topRect, botRect;	Rect 	topRectFrom, botRectFrom;	int		midFitRect = (psd->fitRect.top + psd->fitRect.bottom)/2;	long 	theTick;		SetRect( &topRect, psd->fitRect.left, midFitRect - kPSRevealStep,					   psd->fitRect.right, midFitRect );	SetRect( &botRect, psd->fitRect.left, midFitRect, 					   psd->fitRect.right, midFitRect + kPSRevealStep );	SetRect( &topRectFrom, 0, 0, psd->offRect.right, kPSRevealStep );	SetRect( &botRectFrom, 0, psd->offRect.bottom - kPSRevealStep,						   psd->offRect.right, 						   psd->offRect.bottom );		PlaySoundID( kPSSoundID );	for ( step = 0; step < numSteps; step++ ) {		theTick = TickCount();				CopyOffToOffRect( psd->off, true, 						  (GWorldPtr)psd->mainWind, false,						  topRectFrom, topRect );		CopyOffToOffRect( psd->off, true, 						  (GWorldPtr)psd->mainWind, false,						  botRectFrom, botRect );		topRect.top -= kPSRevealStep;		topRectFrom.bottom += kPSRevealStep;		botRect.bottom += kPSRevealStep;		botRectFrom.top -= kPSRevealStep;				while (TickCount()-theTick<kPSRevealDelay);	}		DrawPictureID( kPSPict, psd->fitRect );}void PSDrawSinglePlayerName( PSDialog psd, int drawIndex, Boolean eraseName ) {	short 		helveticaNum;	short		vPosition, hMidPoint;	char*		theName;	short		nameWidth;	Rect 		r;	RgnHandle	oldRgn;		GetClip( oldRgn = NewRgn() );		// prepare the font and other gfx settings	GetFNum( "\pHelvetica", &helveticaNum );	TextFont( helveticaNum );	TextSize( 11 );	if ( drawIndex < psd->topPlayer )		return;	if ( drawIndex >= psd->topPlayer + kPSPlayersSeen )		return;	if ( drawIndex >= players_list->playerCount )		return;			// prepare to draw the name.	vPosition = psd->trackRects[kPSText].top + (kPSPlayerHeight*((drawIndex-psd->topPlayer)+1));	hMidPoint = (psd->trackRects[kPSText].right+psd->trackRects[kPSText].left) / 2;	// erase, if necessary.	SetRect( &r, psd->trackRects[kPSText].left, vPosition - kPSPlayerHeight + 3,				 psd->trackRects[kPSText].right, vPosition + 3 );	InsetRect( &r, 2, 0 );	ClipRect( &r );	if (eraseName) {		InsetRect( &r, 1, 1 );		FillRect( &r, &qd.black );		InsetRect( &r, -1, -1 );	}		// colorize.	ForeColor( whiteColor );	BackColor( blackColor );		theName = GetPlayerName( (MRPlayerData) (&players_list->players[drawIndex]) );		if ( drawIndex == players_list->currentPlayer )		TextFace( bold );	else		TextFace( 0 );			nameWidth = StringWidth( C2PStr( theName ) );	MoveTo( hMidPoint - (nameWidth/2), vPosition );	DrawString( (StringPtr) theName );	if (( psd->state == kPSEditState ) && ( drawIndex == players_list->currentPlayer )){		// in edit state, a white rectangle is framed around the name.		Point p;				psd->cursorLocation.v = vPosition;		GetPen( &p );		if ( p.h >= r.right - kPSCursorWidth )			p.h = r.right - kPSCursorWidth - 1;		psd->cursorLocation.h = p.h;				FrameRect( &r );	}	// reset gfx info	SetClip( oldRgn );	DisposeRgn( oldRgn );	ForeColor( blackColor );	BackColor( whiteColor );	TextFace( 0 );}void PSDrawPlayerNames( PSDialog psd, Boolean eraseOldNames ) {	// Player names are in helvetica 13, white.	GrafPtr		oldPort;	int			startName, endName;	int			drawIndex;		GetPort( &oldPort );	SetPort( psd->mainWind );		// erase old names, if necessary	if ( eraseOldNames )		FillRect( &psd->trackRects[kPSText], &qd.black );	// figure out which names to draw	startName = psd->topPlayer;	endName = startName + kPSPlayersSeen-1; 	if (endName>=players_list->playerCount)		endName = (players_list->playerCount)-1;		for ( drawIndex = startName; drawIndex<=endName; drawIndex++ ) 		PSDrawSinglePlayerName( psd, drawIndex, false );		SetPort( oldPort );}PSDialog PSCreate( WindowPtr mainWind ) {	PSDialog	psd;	Rect		picRect = RectFromPictureID( kPSPict );	Rect		bubRect;	int			i;		// make it	psd = (PSDialog) DBG_NewPtrClear( sizeof( struct PSDialogStruct ) );	if ( psd == NULL )		return NULL;		// init the fields	psd->mainWind = mainWind;	psd->fitRect = picRect;	CenterRect( &psd->fitRect, &mainWind->portRect );	psd->offRect = picRect;	psd->fitAdjust.h = psd->fitRect.left;	psd->fitAdjust.v = psd->fitRect.top;		// make the offscreens	(void)MacMakeGWorldDepth( psd->offRect, CURRENT_DEPTH, &psd->off );	(void)MacMakeGWorldDepth( psd->offRect, CURRENT_DEPTH, &psd->hiliteOff );	(void)MacMakeGWorldDepth( psd->offRect, CURRENT_DEPTH, &psd->restoreOff );		// draw the images to the offscreens	DrawPictToWorld( psd->off, kPSPict );	DrawPictToWorld( psd->hiliteOff, kPSHilitePict );	CopyOffToOffRect( (GWorldPtr)psd->mainWind, false,					  psd->restoreOff, true,					  psd->fitRect, psd->offRect );					  	// set up the tracking rectangles	SetRect( &psd->trackRects[kPSPrev], 23, 134, 23+52, 134+55 );	SetRect( &psd->trackRects[kPSNext], 125, 134, 125+52, 134+55 );	SetRect( &psd->trackRects[kPSText], 21, 208, 21+158, 208+69 );	SetRect( &psd->trackRects[kPSRename], 26, 310, 26+148, 310+20 );	SetRect( &psd->trackRects[kPSNew], 26, 336, 26+66, 336+20 );	SetRect( &psd->trackRects[kPSDelete], 108, 336, 108+66, 336+20 );	SetRect( &psd->trackRects[kPSSelect], 26, 421, 26+148, 421+47 );		// now offset all of them.	for ( i = 0; i < kPSDlogTrackRects; i++ ) {		psd->trackOffRects[i] = psd->trackRects[i];		OffsetRect( &psd->trackRects[i], psd->fitAdjust.h, psd->fitAdjust.v );	}		// make the bubbly info	SetRect( &bubRect, 84, 145, 84+32, 145+32 );	OffsetRect( &bubRect, psd->fitAdjust.h, psd->fitAdjust.v );	psd->bubbleData = MakeNewBubble( bubRect );		// Draw the main picture, but do it in a neat way	// if we have a speedy PPC machine.//	if ( COMPILE_IS_68K )//		DrawPictureID( kPSPict, psd->fitRect );//	else		PSReveal( psd );		// Draw the names of available players	psd->topPlayer = players_list->currentPlayer;	psd->topPlayer -= 1;	if ( psd->topPlayer<0 )		psd->topPlayer = 0;	PSDrawPlayerNames( psd, false );		// return it	return psd;}void PSSlideNames( PSDialog psd, Boolean slideDown ) {	Rect from, to;	Rect trackRect = psd->trackRects[kPSText];	int	step;	int numSteps = (kPSPlayerHeight/kPSSlideStep);	long startTick;	Rect blackenRect;	RgnHandle oldClip;		GetClip( oldClip = NewRgn() );	ClipRect( &trackRect );		if ( slideDown ) {		from = trackRect;		to = from;		OffsetRect( &to, 0, kPSSlideStep );	} else {		from = trackRect;		to = from;		OffsetRect( &to, 0, -kPSSlideStep );	}		for ( step = 0; step<numSteps; step++ ) {		startTick = TickCount();		CopyOffToOffRect( (GWorldPtr) psd->mainWind, false,						  (GWorldPtr) psd->mainWind, false,						  from, to );		if ( slideDown ) {			SetRect( &blackenRect, trackRect.left, trackRect.top, trackRect.right, from.top );			FillRect( &blackenRect, &qd.black );			OffsetRect( &from, 0, kPSSlideStep );			OffsetRect( &to, 0, kPSSlideStep );		} else {			SetRect( &blackenRect, trackRect.left, from.bottom, trackRect.right, trackRect.bottom );			FillRect( &blackenRect, &qd.black );			OffsetRect( &from, 0, -kPSSlideStep );			OffsetRect( &to, 0, -kPSSlideStep );		}		while (TickCount()-startTick<kPSSlideDelay);	}		if ( !slideDown ) {		SetRect( &blackenRect, trackRect.left, trackRect.top, trackRect.right, trackRect.top + 4 );		FillRect( &blackenRect, &qd.black );	}		SetClip( oldClip );	DisposeRgn( oldClip );}Boolean PSAction( PSDialog psd, int selButton ) {	PlaySoundID( kClickSnd );		switch (selButton) {		case kPSSelect:			return true;		case kPSPrev: 			psd->topPlayer -= 1;			if ( psd->topPlayer < 0 )				psd->topPlayer = 0;			else {				if ( psd->state != kPSNormalState ) {					psd->topPlayer += 1;					psd->state = kPSNormalState;					PSDrawPlayerNames( psd, true );					psd->topPlayer -= 1;				}				PSSlideNames( psd, true );				PSDrawSinglePlayerName( psd, psd->topPlayer, true );			}			return false;				case kPSNext:			psd->topPlayer += 1;			if ( psd->topPlayer >= players_list->playerCount)				psd->topPlayer = players_list->playerCount-1;			else {				if ( psd->state != kPSNormalState ) {					psd->topPlayer -= 1;					psd->state = kPSNormalState;					PSDrawPlayerNames( psd, true );					psd->topPlayer += 1;				}				PSSlideNames( psd, false );				PSDrawSinglePlayerName( psd, psd->topPlayer+kPSPlayersSeen-1, true );			}			return false;				case kPSRename:			psd->state = kPSEditState;			if (( players_list->currentPlayer < psd->topPlayer ) ||				( players_list->currentPlayer >= psd->topPlayer + kPSPlayersSeen )) {				psd->topPlayer = players_list->currentPlayer;				psd->topPlayer -= 1;				if ( psd->topPlayer<0 )					psd->topPlayer = 0;				PSDrawPlayerNames( psd, true );			} else				PSDrawSinglePlayerName( psd, players_list->currentPlayer, true );			return false;					case kPSNew:			{				int possTopPlayer;								players_list->playerCount += 1;				players_list->currentPlayer = (players_list->playerCount-1);				strcpy( players_list->players[ players_list->currentPlayer ].myName, "\0" );				// set the psd state info to reflect that we're editing a name,				// and that the player we're editing needs to appear				// somewhere on screen.				psd->state = kPSEditState;				possTopPlayer = players_list->currentPlayer - kPSPlayersSeen + 1;				if ( possTopPlayer < 0 )					possTopPlayer = 0;								if ( players_list->currentPlayer - psd->topPlayer >= kPSPlayersSeen )					psd->topPlayer = possTopPlayer;								// draw the player names				PSDrawPlayerNames( psd, true );									// set the cursor information				psd->lastCursorTick = 0;				psd->cursorOn = false;			}			break;				case kPSDelete:			{				Boolean finished = false;				int		sel = 0;				int 	chosen;				Rect	offsetTrack;				Point	mouseLoc;								// we go modeless here, and wait for a response.				while (Button());								// demonstrate that the new dialog is modal.				DimRectangle( psd->fitRect, true, true );				PSDrawSinglePlayerName( psd, players_list->currentPlayer, true );								// setup the new dialog:				psd->confOffRect = RectFromPictureID( kPSConfirmPict );				(void)MacMakeGWorldDepth( psd->confOffRect, CURRENT_DEPTH, &psd->confOff );				(void)MacMakeGWorldDepth( psd->confOffRect, CURRENT_DEPTH, &psd->confHiliteOff );				(void)MacMakeGWorldDepth( psd->confOffRect, CURRENT_DEPTH, &psd->confRestoreOff );				psd->confFitRect = psd->confOffRect;				CenterRect( &psd->confFitRect, &psd->mainWind->portRect );				OffsetRect( &psd->confFitRect, -40, -120 );				psd->confFitAdjust.h = psd->confFitRect.left;				psd->confFitAdjust.v = psd->confFitRect.top;								// draw to the offscreens				DrawPictToWorld( psd->confOff, kPSConfirmPict );				DrawPictToWorld( psd->confHiliteOff, kPSConfirmHilitePict );				CopyOffToOffRect( (GWorldPtr)psd->mainWind, false,								  psd->confRestoreOff, true,								  psd->confFitRect,								  psd->confOffRect );								  				// set the tracking rectangles				SetRect( &psd->confTrackRects[kPSConfNo],							26, 111, 26+66, 111+20 );				SetRect( &psd->confTrackRects[kPSConfYes],							108, 111, 108+66, 111+20 );				OffsetRect( &psd->confTrackRects[kPSConfNo],								psd->confFitAdjust.h,								psd->confFitAdjust.v );				OffsetRect( &psd->confTrackRects[kPSConfYes],								psd->confFitAdjust.h,								psd->confFitAdjust.v );								// draw the dialog				DrawPictureID( kPSConfirmPict, psd->confFitRect );								// run the dialog				while (!finished) {					GetMouse( &mouseLoc );										KeepMusicGoing();										if ( Button() )					for ( sel = 0; sel < kPSConfDlogTrackRects; sel++ )						if (PtInRect( mouseLoc, &psd->confTrackRects[sel] )) {							offsetTrack = psd->confTrackRects[sel];							OffsetRect( &offsetTrack, -psd->confFitAdjust.h,													  -psd->confFitAdjust.v );							PlaySoundID( kTickSnd );							if (TrackGraphicalButton( psd->mainWind,													  offsetTrack,													  psd->confTrackRects[sel],													  psd->confOff,													  psd->confHiliteOff,													  NULL )) {								PlaySoundID( kClickSnd );								chosen = sel;								finished = true;							}						}				}								// if chosen is "yes", then actually delete the player.				if ( chosen == kPSConfYes ) {					// remove the currentPlayer by filling in all					// previous players.					int i;										(players_list->playerCount) -= 1;										for ( i = players_list->currentPlayer;						  i < (players_list->playerCount);						  i++ ) {						 players_list->players[i] = players_list->players[i+1]; 						} 										// blank old data					players_list->players[players_list->playerCount].hours = 0;					players_list->players[players_list->playerCount].mins = 0;					players_list->players[players_list->playerCount].secs = 0;					players_list->players[players_list->playerCount].days = 0;					players_list->players[players_list->playerCount].numThrows = 0;					players_list->players[players_list->playerCount].mapLocation.h = 0;					players_list->players[players_list->playerCount].mapLocation.v = 0;					strcpy( players_list->players[players_list->playerCount].myName, "\0" );					for ( i = 0; i < MAX_LEVELS; i++ )						players_list->players[players_list->playerCount].passedLevel[i] = false;															if ( players_list->playerCount == 0 ) {						// can't allow user to have zero players;						// create a new player instead.						players_list->playerCount = 1;						players_list->currentPlayer = 0;						strcpy( players_list->players[0].myName, "Oliver Layton III" );					} else if ( players_list->currentPlayer >= players_list->playerCount )						players_list->currentPlayer -= 1;											psd->topPlayer = players_list->currentPlayer;					psd->topPlayer -= 1;					if ( psd->topPlayer<0 )						psd->topPlayer = 0;				}								// dispose the dialog				DestroyGWorld( &psd->confOff );				DestroyGWorld( &psd->confHiliteOff );								CopyOffToOffRect( psd->confRestoreOff, true,								  (GWorldPtr) psd->mainWind, false,								  psd->confOffRect,								  psd->confFitRect );				DestroyGWorld( &psd->confRestoreOff );								// redraw the pselect dialog				DrawPictureID( kPSPict, psd->fitRect );				PSDrawPlayerNames( psd, true );												// flush out the clicks				FlushEvents( everyEvent, 0 );			}			break;					default:			break;	}			return false;}Boolean PSTextAction( PSDialog psd, Point where ) {	Rect trackRect = psd->trackRects[kPSText];	int clickedOn;	int oldCP;	Boolean doFullRedraw = false;		// change the current player	clickedOn = (where.v - trackRect.top)/kPSPlayerHeight;		if ( psd->state != kPSNormalState )		doFullRedraw = true;	psd->state = kPSNormalState;	oldCP = players_list->currentPlayer;	players_list->currentPlayer = (psd->topPlayer+clickedOn);	if (players_list->currentPlayer >= players_list->playerCount ) {		players_list->currentPlayer = oldCP;		psd->lastClickTick = 0;	}		if ( oldCP != players_list->currentPlayer ) {		if ( !doFullRedraw ) {			PSDrawSinglePlayerName( psd, oldCP, true );			PSDrawSinglePlayerName( psd, players_list->currentPlayer, true );		} else			PSDrawPlayerNames( psd, true );	} else if ( TickCount() - psd->lastClickTick <=  GetDblTime() ) {		// double click! time to select and leave the dialog!		return PSAction( psd, kPSSelect );	}		psd->lastClickTick = TickCount();		return false;}Boolean PSClick( PSDialog psd, Point where ) {	int i;		for ( i = 0; i < kPSDlogTrackRects; i++ )		if (PtInRect(where, &psd->trackRects[i])) {			PlaySoundID( kTickSnd );						if ( i == kPSText )				return PSTextAction( psd, where );			else if (TrackGraphicalButton( psd->mainWind,									  psd->trackOffRects[i],									  psd->trackRects[i],									  psd->off,									  psd->hiliteOff,									  psd->bubbleData ))				return PSAction( psd, i );		}			return false;}Boolean PSKey( PSDialog psd, char key, int mods, Boolean keyUp ) {	if ( psd->state == kPSEditState ) {		// have to change the name of the current player.		if ( !keyUp ) {			MRPlayerData thePlayer = (MRPlayerData) (&(players_list->players[players_list->currentPlayer]));			int nameLen = strlen( thePlayer->myName );						if (( nameLen >= MAX_PLAYER_NAME_LENGTH ) && ( key != '\b' ) && (key != (char)13)) {				PlaySoundID( kPSBigNameSnd );				return false;			}						if ( key == '\b' ) {				if ( nameLen > 0 ) {					thePlayer->myName[--nameLen] = '\0';					PlaySoundID( kPSKeyDeleteSnd );				} else					PlaySoundID( kPSBigNameSnd );			} else if (key == (char)13 || key == (char)3) {				psd->state = kPSNormalState;				psd->ignoreReturn = true;				PSDrawPlayerNames( psd, true );				PlaySoundID( kTickSnd );				return false;			} else {				PlaySoundID( kPSKeyPressSnd );				thePlayer->myName[nameLen++] = key;				thePlayer->myName[nameLen] = '\0';			}						PSDrawSinglePlayerName( psd, players_list->currentPlayer, true );		}				return false;		}		if ((key==(char)13) && (!keyUp)) {		PlaySoundID( kTickSnd );		CopyOffToOffRect( psd->hiliteOff, true,						  (GWorldPtr) psd->mainWind, false,						  psd->trackOffRects[ kPSSelect ],						  psd->trackRects[ kPSSelect ] );	} else if ((key==(char)13) && (keyUp) && (!psd->ignoreReturn)) {		PlaySoundID( kClickSnd );		CopyOffToOffRect( psd->off, true,						  (GWorldPtr) psd->mainWind, false,						  psd->trackOffRects[ kPSSelect ],						  psd->trackRects[ kPSSelect ] );				return true;	}		psd->ignoreReturn = false;		return false;}Boolean PSIdle( PSDialog psd ) {	BubbleOliver( psd->bubbleData );		// check to see if we should do cursor-related stuff.	if ( psd->state == kPSEditState ) {		if ( TickCount() - psd->lastCursorTick > GetCaretTime() ) {			Rect cursRect;						SetRect( &cursRect, psd->cursorLocation.h, psd->cursorLocation.v - kPSCursorHeight,								psd->cursorLocation.h + kPSCursorWidth,								psd->cursorLocation.v );											if ( psd->cursorOn ) {				psd->cursorOn = false;				FillRect( &cursRect, &qd.black );			} else {				psd->cursorOn = true;				ForeColor( whiteColor );				FillRect( &cursRect, &qd.black );				ForeColor( blackColor );			}					psd->lastCursorTick = TickCount();		}	}		return false;}void PSDestroy( PSDialog* psd ) {	// no more b-data	KillBubble( &((*psd)->bubbleData) );	// copy one of the offscreens back	CopyOffToOffRect( (*psd)->restoreOff, true,					  (GWorldPtr)((*psd)->mainWind), false,					  (*psd)->offRect, (*psd)->fitRect );					  	// kill the offscreens	DestroyGWorld( &((*psd)->off) );	DestroyGWorld(&((*psd)->hiliteOff) );	DestroyGWorld(&((*psd)->restoreOff));		// kill the actual dialog.	DBG_DisposePtr( (Ptr) (*psd) );	*psd = NULL;}
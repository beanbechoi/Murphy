// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRGfxUtils.c// Auth: Dave Peck// Date: 7/2/97// Desc: gfx utils, duh. with a particularly ugly routine called MRPal.//			why can I never get PictInfo to work for me???// ----------------------------------------------------------------// Includes// ----------------------------------------------------------------#include <string.h>#include "SWGameUtils.h"#include "MacColorOff.h"#include "MRGfxUtils.h"#include "MRResources.h"#include "MRSound.h"// ----------------------------------------------------------------// Constants// ----------------------------------------------------------------#define kGreenLettersPict			151#define kWhiteLettersPict			152#define kLetterBoxSize				17#define kLetterBoxPadding			1#define kFXWipeStep					32#define kFXWipeHeight				32#define kFXWipeDelay  				3// ----------------------------------------------------------------// Data Structures// ----------------------------------------------------------------// ----------------------------------------------------------------// Global Data// ----------------------------------------------------------------// ----------------------------------------------------------------// Function Prototypes// ----------------------------------------------------------------// ----------------------------------------------------------------// Functions// ----------------------------------------------------------------// Grab a picture from the current graphics// resource file.PicHandle Gfx_GrabPicture( int id ) {	PicHandle thePicture;		MRGfxAlias();	thePicture = GetPicture( id );	MRRestoreResFile();		return thePicture;}Rect MakeEmptyRect() {	Rect r;	SetRect( &r, -1, -1, -1, -1 );	return r;}void ZeroRect( Rect *theRect ) {	OffsetRect( theRect, -(theRect->left), -(theRect->top) );}Rect RectFromPictureID( int pictID ) {	PicHandle thePicture = Gfx_GrabPicture( pictID );		return RectFromPicture( thePicture );}Rect RectFromPicture( PicHandle thePict ) {	Rect r = MakeEmptyRect();		if (thePict) {		r = (*thePict)->picFrame;		ZeroRect( &r );	}		return r;}void DrawPictureIDCentered( int pictID, Rect centerInside ) {	PicHandle thePic = Gfx_GrabPicture( pictID );	DrawPictureCentered( thePic, centerInside );}void DrawPictureCentered( PicHandle thePict, Rect centerInside ) {	Rect picRect = RectFromPicture( thePict );		if (!EmptyRect( &picRect )) {		CenterRect( &picRect, &centerInside );		DrawPictureHand( thePict, picRect );	}}void DrawPictureID( int pictID, Rect drawRect ) {	PicHandle thePicture = Gfx_GrabPicture( pictID );	DrawPictureHand( thePicture, drawRect );}void DrawPictureIDAtPoint( int pictID, short h, short v ) {	PicHandle thePicture = Gfx_GrabPicture( pictID );	Rect r = RectFromPicture( thePicture ); 		OffsetRect( &r, h, v );		DrawPictureHand( thePicture, r );}void DrawPictureHand( PicHandle thePict, Rect drawRect ) {	if ( thePict ) {		MoveHHi( (Handle) thePict );		HLock( (Handle) thePict );		DrawPicture( thePict, &drawRect );		HUnlock( (Handle) thePict );		ReleaseResource( (Handle) thePict );	}}void DelayMouseTime( int numSecs ) {	long finishTick = TickCount() + ( numSecs * 60 );		while ( Button() );		while ( (TickCount() < finishTick) && (!Button()) );}void DelayMouseTimeMusic( int numSecs ) {	long finishTick = TickCount() + ( numSecs * 60 );		while ( Button() ) 		KeepMusicGoing();		while ( (TickCount() < finishTick) && (!Button()) ) 		KeepMusicGoing();}void DrawPictToWorld( GWorldPtr world, int picID ) {	Boolean			lockWorked;				// TRUE if locking the pixel map worked	GWorldPtr		oldWorld;				// Older world to remembr	GDHandle		oldGD;					// older GD, whatever that is.	PicHandle		picToDraw;	Rect			rectOfPic;		// Lock the world's pixmap	lockWorked = LockPixels( world->portPixMap );	if ( !lockWorked )		return;			// Remember our current port	GetGWorld( &oldWorld, &oldGD );		// And Set The port for drawing.	SetGWorld( world, NULL );		// Now draw the picture...	picToDraw = Gfx_GrabPicture( picID );	rectOfPic = RectFromPicture( picToDraw );	DrawPictureHand( picToDraw, rectOfPic );			  	// Set the port back.	SetGWorld( oldWorld, oldGD );		// And unlock the pixels.	UnlockPixels( world->portPixMap );}// Given a pict resource containing letters within// rectangles, determine which rectangle we need// for a specific character we'd like to draw.void CalculateLetterRect( char c, Rect* r, int* offsetAmount, GWorldPtr letterOff ) {	Point p;		// default is a black square.	p.h = 0;	p.v = 25;	(*offsetAmount) = kLetterBoxSize - 5;		if ( c==' ' ) {		offsetAmount += 5;	} else if ( (c>='A') && (c<='Z') ) {		p.h = 2;		p.v = (short)c - (short)'A';	} else if ( (c>='a') && (c<='z') ) {		p.h = 1;		p.v = (short)c - (short)'a';	} else if ( (c>='1') && (c<='9') ) {		p.h = 0;		p.v = (short)c - (short)'1';	} else {				switch (c) {			case '0':				p.v = 9;				break;			case '!':				p.v = 10;				break;			case '@':				p.v = 11;				break;			case '#':				p.v = 12;				break;			case '$':				p.v = 13;				break;			case '%':				p.v = 14;				break;			case '^':				p.v = 15;				break;			case '&':				p.v = 16;				break;			case '*':				p.v = 17;				break;			case '(':				p.v = 18;				break;			case ')':				p.v = 19;				break;			case '\'':				p.v = 20;				break;			case '\"':				p.v = 21;				break;			case '.':				p.v = 22;				break;			case ',':				p.v = 23;				break;			case '-':				p.v = 24;				break;			default:				p.v = 25;		}		}		// okay, now calc the rect from the point.	SetRect( r, (p.h*(kLetterBoxSize+kLetterBoxPadding)) + kLetterBoxPadding,				(p.v*(kLetterBoxSize+kLetterBoxPadding)) + kLetterBoxPadding,				0, 0 );	r->right = r->left + kLetterBoxSize;	r->bottom = r->top + kLetterBoxSize;	}// Given a letter and a letter rectangle (see above)// calculate the width of the letter. This allows us// to quasi-kern a font we like without including it.void MRCalcOffset( char c, Rect* t, int* offset ) {	// if we have a blank square to draw, keep the offset amt whatever.	if (c==' ')		return;		// we can actually test for font-spacing using GetCPixel and looking	// for non-black pixels!	{		short scanH, scanV;		RGBColor scanColor;		Boolean fullBlack = false;				scanV = t->top;		scanH = t->left + 1;				while (!fullBlack) {			GetCPixel( scanH, scanV, &scanColor );			if ((scanColor.red != 0) ||			    (scanColor.green != 0) ||			    (scanColor.blue != 0)) {			    scanV++;			    scanH = t->left + 1;			} else {				scanH++;				if ( scanH > t->right )					fullBlack = true;			}		}				(*offset) = (scanV - t->top) + 2;		if ( (*offset) > kLetterBoxSize )			(*offset) = kLetterBoxSize;	}}// Draw the specified string in the specified box,// using a pict resource containing bitmaps// of the actual letter graphics.void MRLettering( char* toLetter, Rect letterIn, short letterColor ) {	GWorldPtr		lettersOff = NULL;	GrafPtr			drawPort;	Rect			lettersRect;	int				pictID;	RgnHandle		oldClip;	int				theStrlen = strlen( toLetter );		// letter in current port.	GetPort( &drawPort );	GetClip( oldClip = NewRgn() );		// prepare	if ( letterColor == kGreenLettering )		pictID = kGreenLettersPict;	else 		pictID = kWhiteLettersPict;	lettersRect = RectFromPictureID( pictID );		// make letters offscreen	(void) MacMakeGWorldDepth( lettersRect, 0, &lettersOff );		// memory check.	if ( lettersOff == NULL )		return;			DrawPictToWorld( lettersOff, pictID );		// get ready to draw	ClipRect( &letterIn );	OffsetRect( &letterIn, -1, 0 );		// the drawing routine. fast and furious.	{		Rect toRect, fromRect;		int strIndex;		int offsetAmount;				SetRect( &toRect, letterIn.left, letterIn.top, letterIn.left + kLetterBoxSize,									     letterIn.top + kLetterBoxSize );		for ( strIndex = 0; strIndex < theStrlen; strIndex++ ) {			CalculateLetterRect( toLetter[strIndex], &fromRect, &offsetAmount, lettersOff );			CopyOffToOffRect( lettersOff, true, (GWorldPtr) drawPort, false,							  fromRect, toRect );			MRCalcOffset( toLetter[strIndex], &toRect, &offsetAmount );			OffsetRect( &toRect, 0, offsetAmount );		}	}		// kill the derned offscreen	DestroyGWorld( &lettersOff );			// fix up and exit.	SetPort( drawPort );	SetClip( oldClip );	DisposeRgn( oldClip );}// given a picture resource, determine the// optimal pallete and set the window to it.void SetPicturePalette( WindowPtr w, int pictID ) {	PicHandle pic = Gfx_GrabPicture( pictID );		if ( pic ) {		OSErr theErr;		PictInfo theInfo;		PaletteHandle pal;				HNoPurge( (Handle) pic );				theErr = GetPictInfo( pic, &theInfo,							  256, returnColorTable,							  medianMethod, 0 );		if ( theErr != noErr ) {			SysBeep(5);		}				pal = theInfo.thePalette;				SetPalette( w, pal, false );			  	}}// return the window back to system-standard colorsvoid RestoreWindowColors( WindowPtr w ) {	GDHandle oldGDH, windGDH;	CGrafPtr oldP, windP;		GetGWorld( &oldP, &oldGDH );	SetPort( w );	GetGWorld( &windP, &windGDH );		RestoreDeviceClut( windGDH );		SetGWorld( oldP, oldGDH );}// Track the back arrow in the map world.Boolean TrackBackArrow( Rect* r, MRBubbleData bubbleData ) {	// simple button tracking	Boolean hilite = false;	Point mouseLoc;		while (Button()) {		GetMouse( &mouseLoc );		BubbleOliver( bubbleData );		KeepMusicGoing();		if ((PtInRect( mouseLoc, r )) && (!hilite)) {			hilite=true;			DrawPictureID( kBackArrowHilitePict, (*r) );		} else if ((!PtInRect(mouseLoc,r)) && (hilite)) {			hilite=false;			DrawPictureID( kBackArrowPict, (*r) );		}	}		if (hilite)		DrawPictureID( kBackArrowPict, (*r) );			return hilite;}// DimRectangle is an effect for demonstrating modalness// by "interlacing" unavailable interface items.void DimRectangle( Rect r, Boolean dimHoriz, Boolean dimVert ) {	short i;		i = r.top;		if ( dimHoriz )	while ( i < r.bottom ) {		MoveTo( r.left, i );		LineTo( r.right, i );		i += 2;	}		i = r.left;		if ( dimVert )	while ( i < r.right ) {		MoveTo( i, r.top );		LineTo( i, r.bottom );		i += 2;	}}// bubble 'm reall goodvoid BubbleOliver( MRBubbleData theData ) {	Rect fromRect = {0, 0, 32, 32};		if ( theData == NULL )			return;		if ( (TickCount() - theData->lastOliverDraw) < kOliverTickDelay )		return;		switch ( theData->currentOliverState ) {		case kNormalState:			// pick new bub axis and start:			theData->currentAxis = GetRandom( 0, 3 );			theData->currentOliverState = kBub1State;			break;				case kBub3State:			theData->currentOliverState = kNormalState;			break;				default:			theData->currentOliverState += 1;			break;	}		if ( (theData->currentOliverState == kBub1State) ||		 (theData->currentOliverState == kBub3State) ) {		OffsetRect( &fromRect, 32, 0 );		OffsetRect( &fromRect, 64 * theData->currentAxis, 0 );	} else if ( theData->currentOliverState == kBub2State ) {		OffsetRect( &fromRect, 64, 0 );		OffsetRect( &fromRect, 64 * theData->currentAxis, 0 );	}		ForeColor( blackColor );	BackColor( whiteColor );	CopyOffToOffRect( theData->oliverOff, true, (GWorldPtr) theData->onPort, false,					fromRect, theData->oliverRect );						theData->lastOliverDraw = TickCount();}MRBubbleData MakeNewBubble( Rect r ) {	MRBubbleData retData = (MRBubbleData) DBG_NewPtrClear( sizeof (struct MRBubbleDataStruct ));	GetPort( &retData->onPort );		// make the offscreen	if ( MacMakeGWorldDepth( RectFromPictureID( kIntfBubblesPictID ),								CURRENT_DEPTH, &(retData->oliverOff) ) != noErr ) {		DBG_DisposePtr( (Ptr) retData );		return NULL;	}		// set it's contents	DrawPictToWorld( retData->oliverOff, kIntfBubblesPictID );		// woohoo!	retData->currentOliverState = kNormalState;	retData->oliverRect = r;		return retData;}void KillBubble( MRBubbleData* theData ) {	if (*theData) {		DestroyGWorld(&((*theData)->oliverOff));		DBG_DisposePtr((Ptr)(*theData));		(*theData)=NULL;	}}// blacken that window!void WipeWindowFX( WindowPtr wind ) {	// this is a visual wipe.	// it wipes the 640x480 center of your screen.	// actually, it wipes the full width of your screen	// this is eye candy at its finest, folks.		// if you specify to wipe the banners, it does that last.	// the spec only makes a difference in big windows.	Rect wipedArea;	Rect wipeRect, newRect;	int stripeCount;	int stepCount;	int numStripes, numSteps;	Boolean whichWay;	Rect blackenRect;	long startTick = 0;	GrafPtr	oldPort;		GetPort( &oldPort );	SetPort( wind );		// figure the area to by wiped.	SetRect( &wipedArea, 0, 0, 640, 480 );	CenterRect( &wipedArea, &wind->portRect );	//wipedArea.left = wind->portRect.left;	//wipedArea.right = wind->portRect.right;		// if we're in no-fades mode, quit quickly	if ( MR_DISABLE_ALL_FADES ) {		FillRect( &wipedArea, &qd.black );		return;	}		// how many stripes will there be?	numStripes = (wipedArea.bottom - wipedArea.top) / kFXWipeHeight;		// and how many steps will be taken?	numSteps = (wipedArea.right - wipedArea.left) / kFXWipeStep;		ForeColor( blackColor );	BackColor( whiteColor );		// do the wipe!	for ( stepCount = 0; stepCount<numSteps; stepCount++ ) {				wipeRect = wipedArea;		wipeRect.bottom = wipeRect.top + kFXWipeHeight;		whichWay = false;				for ( stripeCount = 0; stripeCount<numStripes; stripeCount++ ) {			newRect = wipeRect;						if ( whichWay ) {				OffsetRect( &newRect, -kFXWipeStep, 0 );				if ( COMPILE_IS_68K )					SetRect( &blackenRect, wipeRect.right - (kFXWipeStep * (stepCount+1)),										   newRect.top,										   wipeRect.right,										   newRect.bottom );   								else					SetRect( &blackenRect, newRect.right,										   newRect.top,										   wipeRect.right,										   newRect.bottom );													} else {				OffsetRect( &newRect, kFXWipeStep, 0 );				if ( COMPILE_IS_68K )					SetRect( &blackenRect, wipeRect.left,										   newRect.top,										   wipeRect.left + (kFXWipeStep* (stepCount+1)),										   newRect.bottom );   				else					SetRect( &blackenRect, wipeRect.left,										   newRect.top,										   newRect.left,										   newRect.bottom );			}						whichWay = (!whichWay);						// don't do the visual slide if we're on a 68k machine:			// it will be too slow. (think of it as eye-candy bonus for			// those of us with PPCs).			if ( COMPILE_IS_68K == 0 ) 				CopyBits( &wind->portBits, &wind->portBits, 					 	  &wipeRect, &newRect,					 	  srcCopy, NULL );						FillRect( &blackenRect, &qd.black );				OffsetRect( &wipeRect, 0, kFXWipeHeight );				}		while ( TickCount() - startTick < 2 )			KeepMusicGoing();		startTick = TickCount();				}		SetPort( oldPort );}// a great utility routine to animate any button.Boolean TrackGraphicalButton( WindowPtr onScreen,							  Rect gfxLocation,							  Rect trackLocation,							  GWorldPtr offScreen,							  GWorldPtr offScreenHilite,							  MRBubbleData bubbleData ) {	Boolean hilite = false;	Point mouseLoc;	GrafPtr oldPort;		GetPort( &oldPort );	SetPort( onScreen );		while (Button()) {		GetMouse( &mouseLoc );		if ( bubbleData )			BubbleOliver( bubbleData );		KeepMusicGoing();		if ( (PtInRect(mouseLoc, &trackLocation)) && (!hilite) ) {			hilite = true;			CopyOffToOffRect( offScreenHilite, true, (GWorldPtr)onScreen, false, gfxLocation, trackLocation );		} else if ((!PtInRect(mouseLoc, &trackLocation)) && (hilite)) {			hilite = false;			CopyOffToOffRect( offScreen, true, (GWorldPtr)onScreen, false, gfxLocation, trackLocation );		}	}		if ( hilite )		CopyOffToOffRect( offScreen, true, (GWorldPtr)onScreen, false, gfxLocation, trackLocation );					SetPort( oldPort );		return hilite;}#pragma mark  . #pragma mark  . #pragma mark  . #pragma mark === ignore this stuff ===#pragma mark === it is hacked-up!! ===#pragma mark  . #pragma mark  . #pragma mark  . // this dumb routine fixes a mistake that find&replace can't.unsigned short smallfract( unsigned short d ) {	return d;}// HACKED UP NONSENSE FOLLOWS.void MRPal( WindowPtr w, PaletteHandle* p ) {	RGBColor myColor;    PaletteHandle pale;        pale = GetNewPalette( 128 );    HLockHi( (Handle) pale );  	SetPalette(w, pale, TRUE);	ActivatePalette(w);			*p = pale;}
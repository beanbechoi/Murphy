// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRInit.c// Auth: Dave Peck// Date: 6/10/97// Desc: Code for the initialization and deinitalization of MR goes here!// ----------------------------------------------------------------// Includes// ----------------------------------------------------------------#include "MRInit.h"#include <string.h>#include "MRResources.h"#include "MacIncludes.h"#include <SWGameUtils.h>#include "MRFade.h"#include "MRSound.h"#include "RequestVideo.h"#include "MRGfxUtils.h"#include "MRPrefs.h"#include "MRPlayers.h"#include <ControlStrip.h>#include "Desktop.h"#include "MRLoop.h"// ----------------------------------------------------------------// Constants// ----------------------------------------------------------------#define kDepthChangeID		7000#define kResChangeID		8000#define kMonitorPrefsID		1250#define	kMonitorPrefsType	'mPrf'// ----------------------------------------------------------------// Data Structures// ----------------------------------------------------------------typedef struct MonitorPrefsStruct {	short	hasShownDepth, hasShownResolution;	short	changeResolution, alwaysShowResolution;	short	alwaysShowDepth;};typedef struct MonitorPrefsStruct MonitorPrefsStruct;typedef MonitorPrefsStruct *MonitorPrefsPtr;typedef MonitorPrefsPtr *MonitorPrefsHand;// ----------------------------------------------------------------// Function Prototypes// ----------------------------------------------------------------// ----------------------------------------------------------------// Global Data// ----------------------------------------------------------------char*				init_failureReason;Boolean				init_wasInitialized;VideoRequestRec		init_oldVideoSettings;VideoRequestRec 	init_newVideoSettings;Boolean				init_changedVideoSettings;GDHandle 			init_chosenMonitor;Rect				init_monitorRect;Boolean				init_hasControlStrip;Boolean				init_controlStripState;// ----------------------------------------------------------------// Functions// ----------------------------------------------------------------void Init_DefaultDraw( Rect r ) {	PenSize(3,3);	InsetRect( &r, -4, -4 );	FrameRoundRect( &r, 15, 15 );	PenSize(1,1);}// internal function: this is a dev copy. be warned.void DevelopmentNotice() {	DialogPtr 	queryDlog = NULL;			// The dialog to ask about.	short		itemHit = -1;	Boolean		finished = false;		if ( DEV_NOTICE != 1 || MR_QUICK_START_GAME )		return;			queryDlog = GetNewDialog( 10101, NULL, kBringToFront );	ShowWindow( (WindowPtr) queryDlog );	SetPort( (WindowPtr) queryDlog );		{		short itemType;		Handle item;		Rect box;				GetDialogItem( queryDlog, 1, &itemType, &item, &box );		Init_DefaultDraw( box );	}	SysBeep(5);	while ( !finished ) {		// Run the dialog:		ModalDialog( NULL, &itemHit );				finished = (itemHit == 1) || (itemHit == 2);	}	// Close the dialog:	DisposeDialog( queryDlog );	if (itemHit!=1) ExitToShell();}// returns true if user wishes to switch depth to 256 colorsBoolean Init_DepthQuery( Boolean *showAgain ) {	DialogPtr	queryDlog;	short		itemHit;	Boolean		finished = false;	short		itemType;	Handle		item;	int			checkBox = 0;	Rect		box;		queryDlog = GetNewDialog( kDepthChangeID, NULL, kBringToFront );	ShowWindow( (WindowPtr) queryDlog );	SetPort( (WindowPtr) queryDlog );		GetDialogItem( queryDlog, 1, &itemType, &item, &box );	Init_DefaultDraw( box );		SysBeep( 5 );		while ( !finished ) {		ModalDialog( NULL, &itemHit );				if ( itemHit == kDepthChangeCheckBox ) {			checkBox = 1-checkBox;						GetDialogItem( queryDlog, 3, &itemType, &item, &box );			SetControlValue( (ControlHandle)item, checkBox );		}		finished = ( itemHit == kDepthChangeYes || 					 itemHit == kDepthChangeNo );	}		(*showAgain) = (checkBox == 1);		DisposeDialog( queryDlog );		return ( itemHit == kDepthChangeYes );}// returns true if user wishes to change res to 640x480Boolean Init_ResQuery( Boolean *showAgain ) {	DialogPtr	queryDlog;	short		itemHit;	Boolean		finished = false;	int			checkBox = 0;	short		itemType;	Handle		item;	Rect		box;		queryDlog = GetNewDialog( kResChangeDlogID, NULL, kBringToFront );	ShowWindow( (WindowPtr) queryDlog );	SetPort( (WindowPtr) queryDlog );		GetDialogItem( queryDlog, 1, &itemType, &item, &box );	Init_DefaultDraw( box );		SysBeep( 5 );		while ( !finished ) {		ModalDialog( NULL, &itemHit );				if ( itemHit == kDepthChangeCheckBox ) {			checkBox = 1-checkBox;						GetDialogItem( queryDlog, 3, &itemType, &item, &box );			SetControlValue( (ControlHandle)item, checkBox );		}				finished = ( itemHit == kDepthChangeYes || 					 itemHit == kDepthChangeNo );	}		DisposeDialog( queryDlog );		*showAgain = ( checkBox == 1 );		return ( itemHit == kDepthChangeYes );}Point Init_SizeFromGDHandle( GDHandle theMonitor ) {	Point pt;		Rect r = (*(*(theMonitor))->gdPMap)->bounds;	ZeroRect( &r );		pt.h = r.right;	pt.v = r.bottom;		return pt;}// locate first screen that satisfies our need for 640x480, 256 colors.GDHandle Init_LocateUsableScreen( Rect *foundRect ) {		GDHandle	searchDevice;	Rect		deviceRect;	Rect		commonRect;		// search through the device list	searchDevice = GetDeviceList();		while ( searchDevice != NULL ) {			deviceRect = (*searchDevice)->gdRect;		if ( SectRect( &deviceRect, &qd.screenBits.bounds, &commonRect ) ) {			OffsetRect( &commonRect, -commonRect.left, -commonRect.top );						if ( commonRect.right >= kMinimumWidth &&				 commonRect.bottom >= kMinimumHeight &&				 GetScreenDepth( searchDevice ) >= kMinimumDepth ) {								*foundRect = commonRect;				return searchDevice;			}				 		}				searchDevice = GetNextDevice( searchDevice );	}		return NULL;} // change screen resolution and depth as desired// return FALSE on failureBoolean Init_ChangeVideoSettings( GDHandle device, 							   	  Rect *finalSize,  // in & out param							      Boolean changeRes ) {	init_oldVideoSettings.screenDevice = device;	RVGetCurrentVideoSetting( &init_oldVideoSettings );		init_newVideoSettings.screenDevice = device;	init_newVideoSettings.displayMode = nil;	init_newVideoSettings.depthMode = nil;	init_newVideoSettings.requestFlags = 1 << kAllValidModesBit;	init_newVideoSettings.reqBitDepth = 8;		if ( changeRes ) {		init_newVideoSettings.reqHorizontal = kMinimumWidth;		init_newVideoSettings.reqVertical = kMinimumHeight;	} else {		init_newVideoSettings.reqHorizontal = finalSize->right;		init_newVideoSettings.reqVertical = finalSize->bottom;	}		RVRequestVideoSetting( &init_newVideoSettings );	if ( init_newVideoSettings.screenDevice != device ||		 init_newVideoSettings.availBitDepth != 8 ) 		 return false;		finalSize->right = init_newVideoSettings.availHorizontal;	finalSize->bottom = init_newVideoSettings.availVertical;		if ( RVSetVideoRequest( &init_newVideoSettings ) != noErr )		return false;			#ifndef I_HATE_CFM68K	Desktop_RecordIcons();	#endif I_HATE_CFM68K		if ( RVConfirmVideoRequest( &init_newVideoSettings ) != noErr )  {		RVSetVideoRequest( &init_oldVideoSettings );		return false;	}		// a simple hack to fix a bug in the RV unit 	(void) SetDepth( device, 8, gdDevType, 1 );		return true;}void Init_RevertScreenSettings() {	if ( !init_changedVideoSettings )		return;			(void) RVSetVideoRequest( &init_oldVideoSettings );			#ifndef I_HATE_CFM68K	Desktop_RestoreIcons();	#endif I_HATE_CFM68K	init_changedVideoSettings = false;}// Internal function: returns true if ColorQD is found:Boolean Init_HasColorQuickDraw() {	SysEnvRec		theSERec;	SysEnvirons( 2, &theSERec );	if ( !theSERec.hasColorQD )		return false;		return true;}// Get a C string indicating the reason for failure.char* FailureReason() {	return init_failureReason;}// Check for the presence of all necessary files by way of initing the// Murphy's Revenge resources manager.Boolean CheckForDataFiles() {	return MRResourcesInit();}// Can we use this mac? If not, return false.Boolean CheckMachineAbilities() {	init_failureReason = NULL;	init_failureReason = (char*) DBG_NewPtrClear( sizeof( char ) * kFailureReasonLength );		if ( !HasSystem7() ) {		strcpy( init_failureReason, "MR requires system 7 or better to run." );		return false;	}	if ( !Init_HasColorQuickDraw() ) {		strcpy( init_failureReason, "MR needs color QuickDraw in order to run." );		return false;	}			init_chosenMonitor = Init_LocateUsableScreen( &init_monitorRect );	if ( init_chosenMonitor == NULL ) {		strcpy( init_failureReason, "MR couldn't find a suitable screen to use." );		return false;	}		// Success!	return true;}// yo! change that resolution - but only if the user wants.Boolean VideoSettingsQuery() {	MonitorPrefsHand mPrefs;	Handle mHand = NULL;	KeyMap kMap;	Boolean showAgain = false;	Boolean changeRes = false;	Rect someRect;		// figure out if we need to warn.	mPrefs = (MonitorPrefsHand) DBG_NewHandleClear( sizeof( MonitorPrefsStruct ) );	HLockHi( (Handle) mPrefs );		MRMainResFile();	mHand = Get1Resource( kMonitorPrefsType, kMonitorPrefsID );	MRRestoreResFile();	if ( mHand )		**mPrefs = **((MonitorPrefsHand) mHand );	ReleaseResource( mHand );		// depth query necessary?	if ( (*mPrefs)->alwaysShowDepth == 1 || 		 ( (*mPrefs)->hasShownDepth == 0 &&		   GetScreenDepth( init_chosenMonitor ) != kMinimumDepth ) ) {		 		 if ( !Init_DepthQuery( &showAgain ) )		 	return false;		 			 (*mPrefs)->hasShownDepth = 1;		 		 if ( showAgain )		 	(*mPrefs)->alwaysShowDepth = 1;		 else		 	(*mPrefs)->alwaysShowDepth = 0;	}		// res query necessary?	GetKeys( kMap );	if ( kMap[1] == 4 ||		// option key		 (*mPrefs)->alwaysShowResolution == 1 ||		 ( (*mPrefs)->hasShownResolution == 0 &&		   init_monitorRect.right - init_monitorRect.left > kMinimumWidth &&		   init_monitorRect.bottom - init_monitorRect.top > kMinimumHeight ) ) {			changeRes = Init_ResQuery( &showAgain );				if ( showAgain )			(*mPrefs)->alwaysShowResolution = 1;		else			(*mPrefs)->alwaysShowResolution = 0;					if ( changeRes )			(*mPrefs)->changeResolution = 1;		else			(*mPrefs)->changeResolution = 0;					(*mPrefs)->hasShownResolution = 1;	}		   	// save monitor preferences	MRMainResFile();	MROverwriteResource( kMonitorPrefsType,						 kMonitorPrefsID,						 (Handle) mPrefs,						 "Monitor Settings Prefs" );	MRRestoreResFile();		// actually do the changes	FadeOut();	someRect = init_monitorRect;	init_changedVideoSettings = 		   Init_ChangeVideoSettings( init_chosenMonitor,									 &someRect,									 (*mPrefs)->changeResolution == 1 );		//if ( (*mPrefs)->changeResolution == 1 )									 	init_monitorRect = 		(*(*(init_newVideoSettings.screenDevice))->gdPMap)->bounds;		PlaySoundID( kLogoSnd );	FadeOutToWhite();		return init_changedVideoSettings;}// when the user quits, put the screen's resolution back to whatever it wasvoid VideoSettingsRevert() {	Init_RevertScreenSettings();}// Close all necessary drivers & release all allocated memory.void CleanUpForExit() {	// Fades & such:	if ( init_wasInitialized ) {		MRSoundClose();		MRClosePreferences();		ClosePlayers();	}	// in MRLoop.c/h because I need handles to the menus...	MRDestroyMenus();		Init_RevertScreenSettings();		CleanUpFades();		// Dealloc char*	if ( init_failureReason != NULL ) {		DBG_DisposePtr( (Ptr) init_failureReason );		init_failureReason = NULL;	}		// That's it for the resources!	MRResourcesClose();}Rect GetMonitorRect() {	return init_monitorRect;}void FillRemainingMonitors() {	WindowPtr blankWindow;	GDHandle			currentDevice = NULL;	Rect				deviceRect;	Rect				commonRect;		// Search through the list of devices.	currentDevice = GetDeviceList();		while ( currentDevice != NULL ) {		// don't bother with the actual device we're going to use:		if ( currentDevice != init_chosenMonitor ) {						// Intersect the screenbits rect with the device's rect.			deviceRect = (*currentDevice)->gdRect;			if ( SectRect( &deviceRect, &qd.screenBits.bounds, &commonRect ) ) {				blankWindow = GetNewCWindow( kMainWindID, NULL, kBringToFront );				MoveWindow( blankWindow, commonRect.left, commonRect.top, true );				SizeWindow( blankWindow, commonRect.right - commonRect.left,										 commonRect.bottom - commonRect.top, false );				SetPort( blankWindow );				ShowWindow( blankWindow );								ForeColor( blackColor );				FillRect( &blankWindow->portRect, &qd.black );			}		}				// Go on to the next monitor.		currentDevice = GetNextDevice( currentDevice );	}	}WindowPtr MakeMonitorWind() {	WindowPtr newWindow = NULL;	// fill all the other monitors with blank windows:	FillRemainingMonitors();		// no create the main window	newWindow = GetNewCWindow( kMainWindID, NULL, kBringToFront );		MoveWindow( newWindow, init_monitorRect.left, init_monitorRect.top, true );	SizeWindow( newWindow, init_monitorRect.right - init_monitorRect.left,						   init_monitorRect.bottom - init_monitorRect.top, false );						   	SetPort( newWindow );	ShowWindow( newWindow );		ForeColor( blackColor );	FillRect( &newWindow->portRect, &qd.black );			// before return, let loop know how big it is	MRSetMonRect( init_monitorRect );		return newWindow;}Boolean HasControlStrip(){	short err;	long response;	Boolean gHasControlStrip = false;	SysEnvRec		theSERec;	SysEnvirons( 2, &theSERec );	if (theSERec.systemVersion >= 0x0700) {		err  = Gestalt(gestaltControlStripAttr,&response);		if (err == noErr)			gHasControlStrip 		= (response & (1 << gestaltControlStripExists));	}		return gHasControlStrip;}void HideControlStrip() {	init_hasControlStrip = HasControlStrip();		if (init_hasControlStrip) {		;//init_controlStripState = SBIsControlStripVisible();				if (init_controlStripState) {			;//SBShowHideControlStrip(false);		}	}}void ShowControlStrip() {	if (init_hasControlStrip)		if (init_controlStripState)			;//SBShowHideControlStrip(true);}// Get ready to use MR on this mac.Boolean InitMurphysRevenge() {	// Set this up:	init_wasInitialized = false;	// Get the fading routines ready to rumble!	// (if they don't work, don't use 'em.)	if (!InitFades() || NO_GAMMA_FADES == 1 )		DisableAllFades();	if (!MRSoundInit())		return false;	// So we know.	init_wasInitialized = true;	// from sw game utils	Randomize();		// prefs	MRLoadPreferences();		{ 		MRPrefs mp = GetCurrentPrefs();				if ( mp.soundVolume == 0 )			SetSoundState( false );		if ( mp.musicVolume == 0 )			SetMusicState( false );	}		// players	InitPlayers();		// prepare main loop	MRLoopPrepare();	MRCreateMenus();		// Success!	return true;}
unit stacks;interface{that's some stack! 4.0}	type		stack = ^node;		node = record				value: integer;				next: stack;			end;	function NewStack: stack;	function StackEmpty (theStack: stack): boolean;	procedure Push (var theStack: stack; xVal, yVal: integer);	procedure Pop (var theStack: stack; var xVal, yVal: integer);	procedure KillStack (var theStack: stack);implementation	function NewStack: stack;	begin		NewStack := nil;	end;	function StackEmpty (theStack: stack): boolean;	begin		StackEmpty := (theStack = nil);	end;	procedure Push (var theStack: stack; xVal, yVal: integer);		var			newNode: stack;	begin		new(newNode);		newNode^.value := (xVal * 256) + yVal;		newNode^.next := theStack;		theStack := newNode;	end;	procedure Pop (var theStack: stack; var xVal, yVal: integer);		var			oldNode: stack;	begin		if not StackEmpty(theStack) then			begin				xVal := theStack^.value div 256;				yVal := theStack^.value mod 256;				oldNode := theStack;				theStack := theStack^.next;				dispose(oldNode);			end;	end;	procedure KillStack (var theStack: stack);		var			oldNode: stack;	begin		while not StackEmpty(theStack) do			begin				oldNode := theStack;				theStack := theStack^.next;				dispose(oldNode);			end;	end;end.
program MRDesign;{LevelDesigner 5.0}{For MR, ©1997 Dave Peck, all rights reserved}{a highly less-hacked version of the level designer}{---Begin PeckEvents Declarations---}	const		WNE_TRAP_NUM = $60;		UNIMPLEMENTED_TRAP_NUM = $9F;		MaxWind = 15;		MaxMenu = 10;	var		dummy: boolean;		aRecta: rect;		windows: array[0..MaxWind] of WindowPtr;		menus: array[0..MaxMenu] of MenuHandle;		curNumWindows: integer;		curNumMenus: integer;		wantsToQuit: boolean;		gWNEImplemented: boolean;		hisApple: MenuHandle;		currentWindow: integer;		fstPtr: grafPtr;{-----------COPY THE FOLLOWING ROUTINES AT THE FRONT OF YOUR PROGRAM---------}	procedure peckInit (howMany: integer);	forward;	procedure peckQuit;	forward;	procedure peckNewWindow (var aWindow: windowPtr);	forward;	procedure peckKillWindow (var aWindow: windowPtr);	forward;	procedure peckNewMenu (var aMenu: menuHandle;									disp: boolean);	forward;	procedure peckKillMenu (var aMenu: menuHandle);	forward;	procedure peckApple (aboutName: str255);	forward;	procedure peckMain;	forward;	procedure peckHalt;	forward;{-------------------MAIN EVENT DOING CODE GOES HERE-------------------------}	procedure doMenu (theMenu: menuHandle;									theItem: integer);	begin	end;	procedure doMouseDown (theWindow: windowPtr;									where: point;									when: longint;									mods: integer);	begin	end;	procedure doKeyDown (theWindow: windowPtr;									theKey: char;									mods: integer);	begin	end;	procedure doCloseWindow (theWindow: windowPtr);	begin	end;	procedure doAbout;	begin	end;	procedure doUpdate (theWindow: windowPtr;									resized: boolean);	begin	end;	procedure doIdle (theWindow: windowPtr);	begin	end;	procedure doKillMenu (theMenu: menuHandle);	begin	end;	procedure doActivate (theWindow: windowPtr);	begin	end;{------------------------- Peck Event Main Routines -------------------------------}	procedure peckInit (howMany: integer);		var			counter: integer;	begin		for counter := 1 to howMany do						{Get enough pointer/heap memory}			moreMasters;		getPort(fstPtr);		curNumWindows := 0;									{Initalize These Variables}		curNumMenus := 0;		wantsToQuit := false;		currentWindow := 0;		for counter := 0 to MaxWind do								{Clear window array}			windows[counter] := nil;		for counter := 0 to MaxMenu do								{Clear menu array}			menus[counter] := nil;		initCursor;												{Arrow Cursor}	end;	procedure peckQuit;	begin		wantsToQuit := true;				{Will halt execution next time main peckEvents gets called}	end;	procedure peckNewWindow (var aWindow: windowPtr);	begin		curNumWindows := curNumWindows + 1;		if curNumWindows > MaxWind then			curNumWindows := MaxWind		else			begin				windows[curNumWindows] := aWindow;				setPort(aWindow);				currentWindow := curNumWindows;			end;	end;	function findAWindow (wFind: windowPtr): integer;		var			winSearchCount: integer;	begin		winSearchCount := 1;		while (windows[winSearchCount] <> wFind) and (winSearchCount < curNumWindows) do			winSearchCount := winSearchCount + 1;		if winSearchCount <= curNumWindows then			findAWindow := winSearchCount		else			findAWindow := 0;	end;	procedure peckKillWindow (var aWindow: windowPtr);		var			recordNum: integer;			wKcounter: integer;	begin		recordNum := findAWindow(aWindow);				{Search array for the window}		doCloseWindow(windows[recordNum]);		if recordNum > 0 then			begin				curNumWindows := curNumWindows - 1;				if curNumWindows > 0 then					begin						for wKcounter := recordNum to curNumWindows do			{Fix List}							windows[wKcounter] := windows[wKcounter + 1];						windows[curNumWindows + 1] := nil;						setPort(windows[1]);					end				else					setPort(fstPtr);													{Whatever it was before}			end;	end;	procedure peckNewMenu (var aMenu: menuHandle;									disp: boolean);	begin		curNumMenus := curNumMenus + 1;		if curNumMenus > MaxMenu then			curNumMenus := MaxMenu		else			begin				menus[curNumMenus] := aMenu;				insertMenu(menus[curNumMenus], 0);			end;		if disp then			drawMenuBar;	end;	function findMenu (mFind: menuHandle): integer;		var			menSearchCount: integer;	begin		menSearchCount := 1;		while (menus[menSearchCount] <> mFind) and (menSearchCount <= curNumMenus) do			menSearchCount := menSearchCount + 1;		if menSearchCount <= curNumMenus then			findMenu := menSearchCount		else			findMenu := 0;	end;	function findMenuByID (mFind: integer): integer;		var			msc: integer;	begin		msc := 1;		while (menus[msc]^^.menuID <> mFind) and (msc <= curNumMenus) do			msc := msc + 1;		if msc <= curNumMenus then			findMenuByID := msc		else			findMenuByID := 0;	end;	procedure peckKillMenu (var aMenu: menuHandle);		var			recordNum: integer;			wKcounter: integer;	begin		recordNum := findMenu(aMenu);					{Search array for the menu}		if recordNum > 0 then			begin				doKillMenu(menus[recordNum]);				curNumMenus := curNumMenus - 1;				if curNumMenus > 0 then					begin						for wKcounter := recordNum to curNumMenus do			{Fix List}							menus[wKcounter] := menus[wKcounter + 1];						menus[curNumMenus + 1] := nil;					end;			end;	end;	procedure appleSelect (theItem: integer);	begin		doAbout;	end;	procedure peckApple (aboutName: str255);		var			appleTitle: Str255;			appleID: integer;			dummy: boolean;	begin		appleTitle := ' ';		appleTitle[1] := char($14);		appleID := 1;		hisApple := NewMenu(appleID, appleTitle);		appendMenu(hisApple, aboutName);		appendMenu(hisApple, '(-');		addResMenu(hisApple, 'DRVR');		peckNewMenu(hisApple, false);	end;	procedure doEvent (theEvent: eventRecord);		var			evnWhat: integer;			wCIn: windowPtr;			winNum: integer;			resultCode: integer;			aBrect: rect;			theSize: longint;			menuID, item: integer;			menNum: integer;			wCntr: integer;			evnChar: char;			evnMods: integer;			itemName: str255;			oldPort: grafPtr;			aDummy: integer;			isActive: boolean;	begin		evnWhat := theEvent.what;		if evnWhat = nullEvent then			if currentWindow > 0 then				for wCntr := 1 to curNumWindows do					doIdle(windows[wCntr]);		if evnWhat = mouseDown then			begin				resultCode := findWindow(theEvent.where, wCIn);				if resultCode = inContent then					begin						winNum := findAWindow(wCIn);						if currentWindow <> winNum then							begin											{Make sure it was current wind}								setPort(wCIn);	{Set it to the wind it was clicked}								currentWindow := winNum;					{In!}								selectWindow(wCIn);							end						else							begin								globalToLocal(theEvent.where);								if winNum > 0 then									doMouseDown(windows[winNum], theEvent.where, theEvent.when, theEvent.modifiers);							end;					end;				if resultCode = inDrag then					begin						aBrect := screenBits.bounds;						dragWindow(wCIn, theEvent.where, aBrect);						setPort(wCIn);						selectWindow(wCIn);					end;				if resultCode = inSysWindow then					systemClick(theEvent, wCIn);				if resultCode = inGoAway then					if trackGoAway(wCIn, theEvent.where) then						peckKillWindow(wCIn);				if resultCode = inGrow then					begin						aBrect := screenBits.bounds;						setPort(wCIn);						theSize := growWindow(wCIn, theEvent.where, aBrect);						sizeWindow(wCIn, loWord(theSize), hiWord(theSize), true);						eraseRect(wCIn^.portRect);						drawGrowIcon(wCIn);						winNum := findAWindow(wCIn);						doUpdate(windows[winNum], true)					end;				if (resultCode = inZoomIn) or (resultCode = inZoomOut) then					begin						winNum := findAWindow(wCIn);						setPort(wCIn);						zoomWindow(wCIn, resultCode, true);						eraseRect(wCIn^.portRect);						doUpdate(windows[winNum], true)					end;				if resultCode = inMenuBar then					begin						theSize := menuSelect(theEvent.where);						hiliteMenu(0);						menuID := hiWord(theSize);						if menuID <> 0 then							begin								item := loWord(theSize);								menNum := findMenuByID(menuID);								if (menNum <> 1) then									doMenu(menus[menNum], item)								else if item = 1 then									doAbout								else									begin										getItem(menus[menNum], item, itemName);										aDummy := openDeskAcc(itemName);										setPort(windows[currentWindow]);									end;							end;					end;			end;		if evnWhat = updateEvt then			begin				getPort(oldPort);				setPort(windowPtr(theEvent.message));				beginUpdate(windowPtr(theEvent.message));				winNum := findAWindow(windowPtr(theEvent.message));				if winNum > 0 then					doUpdate(windowPtr(theEvent.message), false);				endUpdate(windowPtr(theEvent.message));				setPort(oldPort);			end;		if evnWhat = activateEvt then			begin				isActive := (BitAnd(theEvent.modifiers, activeFlag) <> 0);				if isActive then					begin						wCIn := windowPtr(theEvent.message);						winNum := findAWindow(wCIn);						setPort(wCIn);						selectWindow(wCIn);						doActivate(wCIn);					end;				currentWindow := winNum;			end;		if evnWhat = keyDown then			begin				evnChar := char(BitAnd(theEvent.message, charCodeMask));				evnMods := theEvent.modifiers;				if BitAnd(evnMods, cmdKey) > 0 then					begin						theSize := menuKey(evnChar);						hiliteMenu(0);						menuID := hiWord(theSize);						if menuID = 0 then							doKeyDown(windows[currentWindow], evnChar, evnMods)						else							begin								item := loWord(theSize);								menNum := findMenuByID(menuID);								doMenu(menus[menNum], item);							end;					end				else					doKeyDown(windows[currentWindow], evnChar, evnMods);			end;	end;	procedure peckMain;		var			isMine: boolean;			allMask: integer;			anEvent: eventRecord;			evnCode: integer;	begin		gWNEImplemented := (NGetTrapAddress(WNE_TRAP_NUM, ToolTrap) <> NGetTrapAddress(UNIMPLEMENTED_TRAP_NUM, ToolTrap));		while not wantsToQuit do										{Make sure user doesn't wanna leave}			begin				if gWNEImplemented then					isMine := waitNextEvent(everyEvent, anEvent, 10, nil)				else					begin						systemTask;						isMine := getNextEvent(everyEvent, anEvent);					end;				if (isMine) or (anEvent.what = nullEvent) then				{Null event returns false}					doEvent(anEvent);			end;	end;	procedure peckHalt;		var			winCountr, menCountr: integer;	begin		for winCountr := 1 to curNumWindows do			disposeWindow(windows[winCountr]);		for menCountr := 1 to curNumMenus do			disposeMenu(menus[menCountr]);	end;{---------- End of Peck Event Routines -----------}begin{hack}	gDoingOpenUp := false;	gToolSave := kSelect;	Init_Design;	PeckMain;	Save_Prefs;	Kill_MapPrefs;	Close_Design;	PeckHalt;end.
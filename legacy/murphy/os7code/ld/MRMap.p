unit MRMap;{Murphy's Revenge Map Unit}{©1997 Dave Peck, All Rights Reserved.}{Hacked-up junk.}{Don't confuse the four worlds (info-aqua-savana-death) with the overhead "world"}{this terminology is used instead of map, since deslev used "Map" instead of "level"}{for Infotron, for some unknown reason.}interface	uses		PascalSucks, Controls, stacks, QStringInts, QDOffscreen, QOffscreen, QuickDrawProcs;    var         kWorldResID:integer;		map_glob_save:boolean;			const{fudge factor for window sizes}		kFudge = 15;{pict ID for world gfx}		pWorld = 131; {=pWorldPath}{window ID for world }		wWorld = 131;{restype & default id for a world}		kWorldResType = 'MRwd';		levelResType = 'MRlv';		kLevelResType = 'MRlv';		{kWorldResID = 128;}{120 * 16 = 1920}{1920/480 = 4 screens in any direction. cool.}		kMaxWorldSize = 120;		kMaxWorldSizeSquared = 14400;		kMaxLevelsInWorld = 150;		kMaxSpecialsInWorld = 50;{involving the actual grid of 16x16 images}		kWorldItemSize = 24;{if the grid is visible, probably = 1}		kWorldItemStart = 0;		kWorldItemSeparation = 0;{for levels}		kLevelItemSize = 32;{level status infos}		kNewLevel = 1;		kAttemptedLevel = 2;		kWonLevel = 3;{worlds}		kInfotronWorld = 0;		kAquatronWorld = 1;		kSavanatronWorld = 2;		kDeathtronWorld = 3;{Cursor IDs}		cPencil = 128;		cSelect = 129;		cFill = 130;		cWatch = 131;	{-138}		cWatchMax = 138;		cEyeDrop = 139;		cOpenHand = 999;		cClosedHand = 1000;		cArrow = -1;		cInspect = 141;		cToggle = 142;{tools}		kPencil = cPencil;		kFill = cFill;		kSelect = cSelect;		kEyedrop = cEyedrop;{winkinds}		kMapKind = 0;		kLevelKind = 1;{compress flags}		kRLEFlag = 128;		kRLEEnd = 129;	type{the WorldPoint is a perplexing datastructure that is used in many different ways.}{For an overhead world, the comments inside the datatype declaration apply.}{For an actual game level:}{  p:   the icon }{ kind: normal=0, keycoded=1, gravitySwitch=2, hardwarePhase = 3}{also for levels, the point at (0,0) has special info:}{kind: number of infotrons required}		WorldPoint = record				p: Point;	{represents the actual icon location on the icons grid}				trig: integer; {for normal piece, is assoc. trigger; for trigger, is ID; for lev, is index}				trigP: Point; {for norm piece, what to trig to; for trigger, what kind it is}				state: integer; {for trigger, =0,1 (off, on); for lev, =0 nopass, = 1 passed}				kind: integer; {=0 for normal, =1 for trigger, =2 for level}				levelID: integer;{only for level}			end;		WorldArray = array[1..kMaxWorldSize, 1..kMaxWorldSize] of WorldPoint;		WorldArrayPtr = ^WorldArray;		IntArray = array[1..kMaxWorldSizeSquared] of integer;		IntArrayPtr = ^IntArray;		FlatLevel = record{stuff that's in each and every location}				ph: IntArrayPtr;				pv: IntArrayPtr;				kind: IntArrayPtr;			end;		OldExtraLevelInfo = record				reqInfo: integer;				levelWorld: integer;				levelTitle: Str255;				levelInfo: Str255;				phCount: integer;				pvCount: integer;				kindCount: integer;			end;		ExtraLevelInfo = record				reqInfo: integer;				levelWorld: integer;				levelTitle: Str255;				levelInfo: Str255;				phCount: integer;				pvCount: integer;				kindCount: integer;				actualInfo: integer;				hours, mins, secs: integer;				dataOne: integer;				dataTwo: integer;				dataThree: integer;			end;{the following structure exists because I suddenly}{realized how I _should_ be doing things, but unfortunately}{I'd already done lots of coding with the old struct idea.}		MRWorldInfoStruct = record				theWorld: WorldArrayPtr;			end;		MRWorldInfo = ^MRWorldInfoStruct;{tag to attach to the window}		MRWinTagStruct = record				winTitle: str255;				winDirty: boolean;				winKind: integer;				winWorld: MRWorldInfo;	{can now represent level OR world}				drawOffscreen: boolean;				pathOff: GWorldPtr;				backOff: GWorldPtr;				worldOff: GWorldPtr;				vScroll, hScroll: ControlHandle;				iconsAcross, iconsDown: integer;				drawIcon: Point;				palUpdate: boolean;				itemSize: integer;				resID: integer;{the following stuff is for selections}				haveSelection: Boolean;				selectionRect: Rect;				origSelRect: Rect;				copyWorld: WorldArrayPtr;{for loading a level}				openLevel: integer;{extra tag data that keeps track of level-specific info}				levelInfo: Str255;				levelWorld: integer;				reqInfo: integer;				hours, mins, secs: integer;				usesExtendedData: Boolean;			end;		MRWinTag = ^MRWinTagStruct;{junk! from old MR level type}	const		kMaxThings = 40;		kBaseNum = 128;		oldLevelResType = 'lŸVl';	type		copyArray = array[1..20, 1..20] of integer;		boardArray = array[1..150, 1..150] of integer;		ThingArray = array[1..kMaxThings] of integer;		twoZeroArray = array[1..120, 1..120] of integer;		oneZeroArray = array[0..0] of integer;{User interface description}		bcp = ^bcpp;		bcpp = ^CompressedBoard;		CompressedBoard = record				name: str255;				sizeX, sizeY: integer;									{How far right and down does the level extend?}				murphy, term: integer;											{where does murphy start}				numScissors: integer;				numQuarks: integer;				numInfotrons: integer;				numBugs: integer;				numComp: integer;			{how many run-length compression thingys did we use up?}				theBoard: oneZeroArray;			end;		oldboardds = ^bapp;		bapp = ^LevelRecord;		LevelRecord = record				name: str255;				sizeX, sizeY: integer;									{How far right and down does the level extend?}				murphy, term: integer;											{where does murphy start}				numScissors: integer;				numQuarks: integer;				numInfotrons: integer;				numBugs: integer;				scissors, quarks, bugs: ThingArray;				theBoard: twoZeroArray;			end;	var{messed up:}		gWorldItemSize: integer;		gDontShow: Boolean;{this i moved from the mainline to this unit, only because}{I really really need it and besides everything but this one}{unit is hacked up anyways.}		gCurTool: integer;		gToolSave: integer;{cursor state}		gLastCursor: integer;		gCurrentCurs: CursHandle;{resource file to save data to}		gListRes: integer;	function NewBoardDataStructure: oldboardds;	function DecompressBoard (c: bcp;									var b: oldboardds): boolean;				{FALSE if it failed}	function LoadCompBoard (name: str255;									var compData: bcp): boolean;	function loadBoard (name: str255;									var theBoard: oldboardds): boolean;	procedure ImportBoard (wind: WindowPtr);	function MakeWorldWindow (worldTitle: str255;									resID: integer): WindowPtr;	function LoadWorldWindow (worldTitle: str255;									resID: integer): WindowPtr;	procedure CloseWorldWindow (var worldWind: WindowPtr);	procedure MouseOverWorldWindow (worldWind: WindowPtr;									where: point;									mods: integer);	procedure WorldWindowClick (worldWind: WindowPtr;									where: point;									mods: integer);	procedure SaveWorld (worldWind: WindowPtr);	procedure DrawWorld (worldWind: WindowPtr);	procedure ResizeWorld (worldWind: WindowPtr);	procedure WorldActivate (worldWind: WindowPtr;									active: Boolean);	procedure SetDrawIcon (worldWind: WindowPtr;									drawIcon: Point);	procedure DrawCurrentMapIcon (worldWind: WindowPtr;									drawRect: Rect);	procedure SelectWorldIcon (worldWind: WindowPtr);	function WorldPaletteUpdate (worldWind: WindowPtr): Boolean;	procedure ZeroWorldSelection (worldWind: WindowPtr);	procedure WorldKey (worldWind: WindowPtr;									theKey: char);	procedure WorldPaste (worldWind: WindowPtr);	function WorldEditHilites (worldWind: WindowPtr): Boolean;	procedure SaveWorldID (worldWind: WindowPtr;									resID: integer);	procedure DontShowWorld;	procedure WorldMapInfo (worldWind: WindowPtr);	function GetOpenLevel (worldWind: WindowPtr): integer;implementation{$S MRMapSeg}	procedure DontShowWorld;	begin		gDontShow := true;	end;	procedure World_DrawPicInOff (picID: integer;									world: GWorldPtr);		var			locked: Boolean;			oldGW: GWorldPtr;			oldGD: GDHandle;	begin		GetGWorld(oldGW, oldGD);		SetGWorld(world, nil);		locked := LockPixels(world^.portPixMap);		DrawPicLoc(picID, 0, 0);		UnlockPixels(world^.portPixMap);		SetGWorld(oldGW, oldGD);	end;	procedure World_EraseOff (world: GWorldPtr);		var			locked: Boolean;			oldGW: GWorldPtr;			oldGD: GDHandle;	begin		GetGWorld(oldGW, oldGD);		SetGWorld(world, nil);		locked := LockPixels(world^.portPixMap);		EraseRect(world^.portPixMap^^.bounds);		UnlockPixels(world^.portPixMap);		SetGWorld(oldGW, oldGD);	end;	procedure World_DrawSingleIcon (pathOff: GWorldPtr;									worldOff: GWorldPtr;									rectTo: Rect;									pointFrom: Point);		var			rectFrom: Rect;	begin{    pointFrom.h := pointFrom.h + 3;}{calc from rect}		SetRect(rectFrom, (pointFrom.h * (gWorldItemSize + kWorldItemSeparation)) + kWorldItemStart, (pointFrom.v * (gWorldItemSize + kWorldItemSeparation)) + kWorldItemStart, 0, 0);		rectFrom.bottom := rectFrom.top + gWorldItemSize;		rectFrom.right := rectFrom.left + gWorldItemSize;{copy}		CopyOffToOffRect(pathOff, true, worldOff, false, rectFrom, rectTo);	end;	procedure World_DrawSingleIconAt (pathOff: GWorldPtr;									worldOff: GWorldPtr;									tag: MRWinTag;									atPt: Point;									fromPoint: Point);		var			rectTo: rect;			topH, topV: integer;	begin{atPoint is a point of the grid}{figure out some infos}		topH := GetControlValue(tag^.hScroll);		topV := GetControlValue(tag^.vScroll);		atPt.h := atPt.h - topH;		atPt.v := atPt.v - topV;{figure out the draw-to-rect}		SetRect(rectTo, atPt.h * gWorldItemSize, atPt.v * gWorldItemSize, 0, 0);		rectTo.bottom := rectTo.top + gWorldItemSize;		rectTo.right := rectTo.left + gWorldItemSize;{draw it!}		World_DrawSingleIcon(pathOff, worldOff, rectTo, fromPoint);	end;	procedure World_RevealSingleIcon (worldWind: WindowPtr;									loc: Point);		var			tag: MRWinTag;			rectTo: rect;			topH, topV: integer;	begin{get tag}		tag := MRWinTag(GetWRefCon(worldWind));{figure out some infos}		topH := GetControlValue(tag^.hScroll);		topV := GetControlValue(tag^.vScroll);		loc.h := loc.h - topH;		loc.v := loc.v - topV;{calc rect}		SetRect(rectTo, loc.h * gWorldItemSize, loc.v * gWorldItemSize, 0, 0);		rectTo.bottom := rectTo.top + gWorldItemSize;		rectTo.right := rectTo.left + gWorldItemSize;{draw it!}		CopyOffToOffRect(tag^.worldOff, true, GWorldPtr(worldWind), false, rectTo, rectTo);	end;	procedure World_SetGridIcon (tag: MRWinTag;									loc: Point;									whichIcon: Point);	begin		if (tag^.winKind = kMapKind) then			begin				tag^.winWorld^.theWorld^[loc.h, loc.v].p := whichIcon;								if (whichIcon.v < 3) then				  tag^.winWorld^.theWorld^[loc.h,loc.v].kind := 2				else if (whichIcon.v = 4) then				  tag^.winWorld^.theWorld^[loc.h,loc.v].kind := 1				else				  tag^.winWorld^.theWorld^[loc.h,loc.v].kind := 0;			end		else			tag^.winWorld^.theWorld^[loc.h, loc.v].p := whichIcon;	end;	function World_PointFromMouse (worldWind: WindowPtr;									where: Point): point;		var			tag: MRWinTag;			p: Point;	begin{setup}		tag := MRWinTag(GetWRefCon(worldWind));{calc sizes}		p.h := GetControlValue(tag^.hScroll);		p.v := GetControlValue(tag^.vScroll);{calculate actual point}		p.h := p.h + (where.h div gWorldItemSize);		p.v := p.v + (where.v div gWorldItemSize);{return it}		World_PointFromMouse := p;	end;	function World_MakeWorldInfo: MRWorldInfo;		var			newWorld: MRWorldInfo;	begin		newWorld := MRWorldInfo(NewPtrClear(sizeof(MRWorldInfoStruct)));{and now the actual world itself}		newWorld^.theWorld := WorldArrayPtr(NewPtrClear(sizeof(WorldArray)));{return it}		World_MakeWorldInfo := newWorld;	end;	procedure World_DestroyWorldInfo (var info: MRWorldInfo);	begin		DisposePtr(Ptr(info^.theWorld));		DisposePtr(Ptr(info));	end;	function World_MakeWinTag (newWind: WindowPtr;									worldTitle: Str255;									kind: integer): MRWinTag;		var			newTag: MRWinTag;			picRect: rect;			winRect: rect;	begin{ make the tag }		newTag := MRWinTag(NewPtrClear(sizeof(MRWinTagStruct)));		newTag^.winTitle := worldTitle;		newTag^.winDirty := false;		newTag^.winKind := kind;		if (kind = kMapKind) then			newTag^.itemSize := 24		else			begin				newTag^.itemSize := 32;				newTag^.levelInfo := '';				newTag^.reqInfo := 0;				newTag^.levelWorld := kInfotronWorld;			end;		gWorldItemSize := newTag^.itemSize;{ always draw the offscreen }{ also, always bet on qd.qd.qd.qd.qd.black. }		newTag^.drawOffscreen := true;{make the path icons offscreen}		if (kind = kMapKind) then			picRect := GetPRect(pWorld)		else			picRect := GetPRect(132);		newTag^.pathOff := MakeGWorldDepth(picRect, 8);		if (kind = kMapKind) then			World_DrawPicInOff(pWorld, newTag^.pathOff)		else			World_DrawPicInOff(132, newTag^.pathOff);{make the window offscreen at the size of the window}		winRect := newWind^.portRect;		OffsetRect(winRect, -winRect.left, -winRect.top);		winRect.right := winRect.right - kFudge;		winRect.bottom := winRect.bottom - kFudge;		newTag^.worldOff := MakeGWorldDepth(winRect, 8);		World_EraseOff(newTag^.worldOff);{calculate icons across and down}		newTag^.iconsAcross := ((winRect.right - kFudge) div gWorldItemSize);		newTag^.iconsDown := ((winRect.bottom - kFudge) div gWorldItemSize);{return the tag}		World_MakeWinTag := newTag;	end;	procedure World_DestroyWinTag (var tag: MRWinTag);	begin		DestroyGWorld(tag^.pathOff);		DestroyGWorld(tag^.worldOff);		DisposeControl(tag^.vScroll);		DisposeControl(tag^.hScroll);		DisposePtr(Ptr(tag));	end;	procedure World_MakeScrollInfo (wind: WindowPtr;									tag: MRWinTag);		const			kScrollbarWidth = 16;			kScrollBarAdjust = kScrollBarWidth - 1;			kScrollBarTweek = 2;		var			pr: Rect;	begin{create the vScroll and hScroll and size 'em correctly.}		tag^.vScroll := GetNewControl(128, wind);		tag^.hScroll := GetNewControl(128, wind);{set params for the controls}		SetControlMinimum(tag^.vScroll, 1);		SetControlMaximum(tag^.vScroll, kMaxWorldSize - tag^.iconsDown);		SetControlValue(tag^.vScroll, 1);		SetControlMinimum(tag^.hScroll, 1);		SetControlMaximum(tag^.hScroll, kMaxWorldSize - tag^.iconsAcross);		SetControlValue(tag^.hScroll, 1);{get the window's portRect}		pr := wind^.portRect;		OffsetRect(pr, -pr.left, -pr.top);{position the controls}		MoveControl(tag^.vScroll, pr.right - kScrollbarAdjust, -1);		SizeControl(tag^.vScroll, kScrollBarWidth, (pr.bottom - pr.top) - (kScrollBarAdjust - kScrollBarTweek));		MoveControl(tag^.hScroll, -1, pr.bottom - kScrollBarAdjust);		SizeControl(tag^.hScroll, (pr.right - pr.left) - (kScrollBarAdjust - kScrollBarTweek), kScrollBarWidth);{display the controls}		ShowControl(tag^.vScroll);		ShowControl(tag^.hScroll);	end;	procedure World_DrawFullOffscreen (tag: MRWinTag);		var			drawIcons: Rect;			singleDraw: Rect;			atH, atV: integer;			oldGW: GWorldPtr;			oldGD: GDHandle;			locked: Boolean;	begin		tag^.drawOffscreen := false;{get the virtual rect to draw into.}		drawIcons.top := GetControlValue(tag^.vScroll);		drawIcons.left := GetControlValue(tag^.hScroll);		drawIcons.bottom := drawIcons.top + tag^.iconsDown;		drawIcons.right := drawIcons.left + tag^.iconsAcross;{single draw rect is perty}		SetRect(singleDraw, 0, 0, gWorldItemSize, gWorldItemSize);{ get ready to draw }		atH := drawIcons.left;		atV := drawIcons.top;		GetGWorld(oldGW, oldGD);		SetGWorld(tag^.worldOff, nil);		locked := LockPixels(tag^.worldOff^.portPixMap);{draw the whole derned thing}		while (atH <= drawIcons.right) do			begin				while (atV <= drawIcons.bottom) do					begin						World_DrawSingleIcon(tag^.pathOff, tag^.worldOff, singleDraw, tag^.winWorld^.theWorld^[atH, atV].p);						OffsetRect(singleDraw, 0, gWorldItemSize);						atV := atV + 1;					end;				atV := drawIcons.top;				atH := atH + 1;				singleDraw.top := 0;				singleDraw.bottom := gWorldItemSize;				OffsetRect(singleDraw, gWorldItemSize, 0);			end;{and release}		UnlockPixels(tag^.worldOff^.portPixMap);		SetGWorld(oldGW, oldGD);	end;	procedure World_CtlBounds (control: ControlHandle);		var			cVal: integer;	begin		cVal := GetControlValue(control);		if (cVal < GetControlMinimum(control)) then			SetControlValue(control, GetControlMinimum(control))		else if (cVal > GetControlMaximum(control)) then			SetControlValue(control, GetControlMaximum(control));	end;	procedure World_DrawHStrip (tag: MRWinTag;									vertValue: integer;									topLeftPt: Point);		var			atH, atV: integer;			maxH: integer;			singleRect: Rect;			p: Point;			locked: Boolean;			oldGW: GWorldPtr;			oldGD: GDHandle;	begin{prepare}		atH := GetControlValue(tag^.hScroll);		atV := vertValue;		maxH := atH + tag^.iconsAcross;		SetRect(singleRect, 0, 0, gWorldItemSize, gWorldItemSize);		OffsetRect(singleRect, topLeftPt.h, topLeftPt.v);		GetGWorld(oldGW, oldGD);		SetGWorld(tag^.worldOff, nil);		locked := LockPixels(tag^.worldOff^.portPixMap);{draw}		while (atH <= maxH) do			begin				p := tag^.winWorld^.theWorld^[atH, atV].p;				World_DrawSingleIcon(tag^.pathOff, tag^.worldOff, singleRect, p);				OffsetRect(singleRect, gWorldItemSize, 0);				atH := atH + 1;			end;		UnlockPixels(tag^.worldOff^.portPixMap);		SetGWorld(oldGW, oldGD);	end;	procedure World_DrawVStrip (tag: MRWinTag;									horizValue: integer;									topLeftPt: Point);		var			atH, atV: integer;			maxV: integer;			singleRect: Rect;			p: Point;			locked: Boolean;			oldGW: GWorldPtr;			oldGD: GDHandle;	begin{prepare}		atV := GetControlValue(tag^.vScroll);		atH := horizValue;		maxV := atV + tag^.iconsDown;		SetRect(singleRect, 0, 0, gWorldItemSize, gWorldItemSize);		OffsetRect(singleRect, topLeftPt.h, topLeftPt.v);		GetGWorld(oldGW, oldGD);		SetGWorld(tag^.worldOff, nil);		locked := LockPixels(tag^.worldOff^.portPixMap);{draw}		while (atV <= maxV) do			begin				p := tag^.winWorld^.theWorld^[atH, atV].p;{    ForeColor(redColor);}{    InsetRect(singleRect, -1, -1);}{    FillRect(singleRect, qd.qd.qd.qd.qd.black);}{    InsetRect(singleRect, 1, 1);}{    ForeColor(blackColor);}				World_DrawSingleIcon(tag^.pathOff, tag^.worldOff, singleRect, p);				OffsetRect(singleRect, 0, gWorldItemSize);				atV := atV + 1;			end;		UnlockPixels(tag^.worldOff^.portPixMap);		SetGWorld(oldGW, oldGD);	end;	procedure World_VertAction (control: ControlHandle;									part: Integer);		var			worldWind: WindowPtr;			tag: MRWinTag;			cValue: integer;			fromRect, toRect: rect;			pr: rect;			drawPoint: Point;	begin		if (part <> 0) then			begin				worldWind := control^^.contrlOwner;				tag := MRWinTag(GetWRefCon(worldWind));				cValue := GetControlValue(control);				pr := worldWind^.portRect;				OffsetRect(pr, -pr.left, -pr.top);				if (tag^.winKind = kMapKind) then					begin						pr.right := pr.right - 16; {was gworlditemsize}						pr.bottom := pr.bottom - 16;					end				else					begin						pr.right := pr.right - kFudge - 1;						pr.bottom := pr.bottom - kFudge - 1;					end;				case part of					20: 						begin{move the box}							SetControlValue(control, cValue - 1);							World_CtlBounds(control);{draw the change, but only if necessary.}							if (cValue - 1 > 0) then								begin									SetRect(fromRect, pr.left, pr.top, pr.right + 1, pr.bottom - gWorldItemSize + 1);									SetRect(toRect, pr.left, pr.top + gWorldItemSize, pr.right + 1, pr.bottom + 1);									CopyOffToOffRect(tag^.worldOff, true, tag^.worldOff, false, fromRect, toRect);									drawPoint.h := 0;									drawPoint.v := 0;									World_DrawHStrip(tag, cValue - 1, drawPoint);									DrawWorld(worldWind);								end;						end;					21: 						begin{move the box}							SetControlValue(control, cValue + 1);							World_CtlBounds(control);{draw the change, but only if necessary.}							if (cValue + 1 <= GetControlMaximum(control)) then								begin									SetRect(fromRect, pr.left, pr.top + gWorldItemSize, pr.right + 1, pr.bottom + 1);									SetRect(toRect, pr.left, pr.top, pr.right + 1, pr.bottom - gWorldItemSize + 1);									CopyOffToOffRect(tag^.worldOff, true, tag^.worldOff, false, fromRect, toRect);									drawPoint.h := fromRect.left;									drawPoint.v := toRect.bottom;									World_DrawHStrip(tag, cValue + tag^.iconsDown, drawPoint);									DrawWorld(worldWind);								end;						end;					22, 23: 						begin{move it:}							if (part = 22) then								SetControlValue(control, cValue - tag^.iconsDown + 1)							else								SetControlValue(control, cValue + tag^.iconsDown - 1);							World_CtlBounds(control);{ the window's top has been changed: }							tag^.drawOffscreen := true;							DrawWorld(worldWind);						end;				end;			end;	end;	procedure World_HorizAction (control: ControlHandle;									part: Integer);		var			worldWind: WindowPtr;			tag: MRWinTag;			cValue: integer;			fromRect, toRect: rect;			pr: rect;			drawPoint: Point;	begin		if (part <> 0) then			begin				worldWind := control^^.contrlOwner;				tag := MRWinTag(GetWRefCon(worldWind));				cValue := GetControlValue(control);				pr := worldWind^.portRect;				OffsetRect(pr, -pr.left, -pr.top);				if (tag^.winKind = kMapKind) then					begin						pr.right := pr.right - 16;						pr.bottom := pr.bottom - 16;					end				else					begin						pr.right := pr.right - kFudge - 1;						pr.bottom := pr.bottom - kFudge - 1;					end;				case part of					20: 						begin{move the box}							SetControlValue(control, cValue - 1);							World_CtlBounds(control);{draw the change, but only if necessary.}							if (cValue - 1 > 0) then								begin									SetRect(fromRect, pr.left, pr.top, pr.right - gWorldItemSize + 1, pr.bottom + 1);									SetRect(toRect, pr.left + gWorldItemSize, pr.top, pr.right + 1, pr.bottom + 1);									CopyOffToOffRect(tag^.worldOff, true, tag^.worldOff, false, fromRect, toRect);									drawPoint.h := 0;									drawPoint.v := 0;									World_DrawVStrip(tag, cValue - 1, drawPoint);									DrawWorld(worldWind);								end;						end;					21: 						begin{move the box}							SetControlValue(control, cValue + 1);							World_CtlBounds(control);{draw the change, but only if necessary.}							if (cValue + 1 <= GetControlMaximum(control)) then								begin									SetRect(fromRect, pr.left + gWorldItemSize, pr.top, pr.right + 1, pr.bottom + 1);									SetRect(toRect, pr.left, pr.top, pr.right - gWorldItemSize + 1, pr.bottom + 1);									CopyOffToOffRect(tag^.worldOff, true, tag^.worldOff, false, fromRect, toRect);									drawPoint.h := toRect.right;									drawPoint.v := fromRect.top;									World_DrawVStrip(tag, cValue + tag^.iconsAcross, drawPoint);									DrawWorld(worldWind);								end;						end;					22, 23: 						begin{move it:}							if (part = 22) then								SetControlValue(control, cValue - tag^.iconsAcross + 1)							else								SetControlValue(control, cValue + tag^.iconsAcross - 1);							World_CtlBounds(control);{ the window's top has been changed: }							tag^.drawOffscreen := true;							DrawWorld(worldWind);						end;				end;			end;	end;	procedure World_Warning (warnString: Str255);		var			warnDlog: DialogPtr;			itemHit: integer;	begin		InitCursor;		ParamText(warnString, '', '', '');		warnDlog := GetNewDialog(131, nil, WindowPtr(-1));		ShowWindow(warnDlog);		SysBeep(5);		repeat			ModalDialog(nil, itemHit);		until itemHit = 1;		DisposeDialog(warnDlog);		SetCursor(gCurrentCurs^^);	end;	function World_ChoiceWarning (warnString: Str255): Boolean;		var			warnDlog: DialogPtr;			itemHit: integer;	begin		InitCursor;		ParamText(warnString, '', '', '');		warnDlog := GetNewDialog(2000, nil, WindowPtr(-1));		ShowWindow(warnDlog);		SysBeep(5);		repeat			ModalDialog(nil, itemHit);		until itemHit <= 2;		DisposeDialog(warnDlog);		SetCursor(gCurrentCurs^^);		World_ChoiceWarning := (itemHit = 1);	end;	function World_SelRectInWindow (tag: MRWinTag): Rect;		var			r, r2: rect;	begin		r := tag^.selectionRect;		OffsetRect(r, -GetControlValue(tag^.hScroll), -GetControlValue(tag^.vScroll));		SetRect(r2, r.left * gWorldItemSize, r.top * gWorldItemSize, r.right * gWorldItemSize, r.bottom * gWorldItemSize);		World_SelRectInWindow := r2;	end;	procedure World_PieceInspDlog (worldWind: WindowPtr;									tag: MRWinTag;									loc: Point;									iconToDraw: Point);		var			inspDlog: DialogPtr;			itemHit: integer;			itemType: integer;			itemBounds: Rect;			item: Handle;			typedText: Str255;			typedInt: integer;	begin{set the cursor up for a dialog}		InitCursor;{put the dlog on screen}		inspDlog := GetNewDialog(1002, nil, WindowPtr(-1));		ShowWindow(inspDlog);{set the edit text to the appropriate value}		GetDialogItem(inspDlog, 2, itemType, item, itemBounds);		SetDialogItemText(item, stringof(tag^.winWorld^.theWorld^[loc.h, loc.v].trig : 1));{select the text for easy editing}		SelectDialogItemText(inspDlog, 2, 0, 32767);{draw the icon, only make it big}		SetRect(itemBounds, 20, 10, 20 + 32, 10 + 32);		World_DrawSingleIcon(tag^.pathOff, GWorldPtr(inspDlog), itemBounds, iconToDraw);{handle the actual dialog}		repeat			ModalDialog(nil, itemHit);		until (itemHit = 1);{get the new value they typed in}		GetDialogItem(inspDlog, 2, itemType, item, itemBounds);		GetDialogItemText(item, typedText);		typedInt := Q_StrToInt(typedText);{now set the value appropriately}		tag^.winWorld^.theWorld^[loc.h, loc.v].trig := typedInt;{get rid of the dialog}		DisposeDialog(inspDlog);{reset the cursor}		SetCursor(gCurrentCurs^^);	end;	procedure World_LevelInspDlog (worldWind: WindowPtr;									tag: MRWinTag;									loc: Point;									iconToDraw: Point);		var			inspDlog: DialogPtr;			itemHit: integer;			itemType: integer;			itemBounds: Rect;			item: Handle;			typedText: Str255;			typedInt: integer;	begin{this routine is very similar to the piece insp, only it changes different things.}{set the cursor up for a dialog}		InitCursor;{put the dlog on screen}		inspDlog := GetNewDialog(1001, nil, WindowPtr(-1));		ShowWindow(inspDlog);{set the edit text to the appropriate value}		GetDialogItem(inspDlog, 2, itemType, item, itemBounds);		SetDialogItemText(item, stringof(tag^.winWorld^.theWorld^[loc.h, loc.v].levelID : 1));{select the text for easy editing}		SelectDialogItemText(inspDlog, 2, 0, 32767);{handle the actual dialog}		repeat			ModalDialog(nil, itemHit);		until (itemHit = 1);{get the new value they typed in}		GetDialogItem(inspDlog, 2, itemType, item, itemBounds);		GetDialogItemText(item, typedText);		typedInt := Q_StrToInt(typedText);{now set the value appropriately}		tag^.winWorld^.theWorld^[loc.h, loc.v].levelID := typedInt;{get rid of the dialog}		DisposeDialog(inspDlog);{reset the cursor}		SetCursor(gCurrentCurs^^);	end;	procedure World_MultiInspDlog (worldWind: WindowPtr;									tag: MRWinTag);		var			inspDlog: DialogPtr;			itemHit: integer;			itemType: integer;			itemBounds: Rect;			item: Handle;			typedText: Str255;			typedInt: integer;			h, v: integer;	begin{this routine is very similar to the piece insp, only it changes different things.}{set the cursor up for a dialog}		InitCursor;{put the dlog on screen}		inspDlog := GetNewDialog(1003, nil, WindowPtr(-1));		ShowWindow(inspDlog);{set the edit text to the appropriate value}		GetDialogItem(inspDlog, 2, itemType, item, itemBounds);		SetDialogItemText(item, stringof(0 : 1));{select the text for easy editing}		SelectDialogItemText(inspDlog, 2, 0, 32767);{handle the actual dialog}		repeat			ModalDialog(nil, itemHit);		until (itemHit = 1);{get the new value they typed in}		GetDialogItem(inspDlog, 2, itemType, item, itemBounds);		GetDialogItemText(item, typedText);		typedInt := Q_StrToInt(typedText);{now set the value appropriately}		for h := tag^.selectionRect.left to (tag^.selectionRect.right - 1) do			for v := tag^.selectionRect.top to (tag^.selectionRect.bottom - 1) do				tag^.winWorld^.theWorld^[h, v].trig := typedInt;{get rid of the dialog}		DisposeDialog(inspDlog);{reset the cursor}		SetCursor(gCurrentCurs^^);	end;	procedure World_SwitchInspDlog (worldWind: WindowPtr;									tag: MRWinTag;									loc: Point;									iconToDraw: Point);		var			inspDlog: DialogPtr;			itemHit: integer;			itemType: integer;			itemBounds: Rect;			item: Handle;			typedText: Str255;			typedInt: integer;			mapTrig: boolean;			trigP: Point;			goopy:Point;				begin{this routine is very similar to the piece insp, only it changes different things.}{set the cursor up for a dialog}		InitCursor;{put the dlog on screen}		inspDlog := GetNewDialog(1000, nil, WindowPtr(-1));		ShowWindow(inspDlog);{set the edit text to the appropriate value}		GetDialogItem(inspDlog, 2, itemType, item, itemBounds);		SetDialogItemText(item, stringof(tag^.winWorld^.theWorld^[loc.h, loc.v].trig : 1));{select the text for easy editing}		SelectDialogItemText(inspDlog, 2, 0, 32767);{figure out what kind of trigger it is}		if (tag^.winWorld^.theWorld^[loc.h, loc.v].state = 0) then begin			trigP := tag^.winWorld^.theWorld^[loc.h, loc.v].trigP;			goopy := tag^.winWorld^.theWorld^[loc.h, loc.v].p;		end else begin			trigP := tag^.winWorld^.theWorld^[loc.h, loc.v].p;			goopy := tag^.winWorld^.theWorld^[loc.h, loc.v].trigP;		end;		mapTrig := ((trigP.h = 0) and (trigP.v = 0)) or (trigP.h = 1) or ( trigP.h = 4 ) 					or (trigP.h = 7);		trigP.v := iconToDraw.v;{set the correct control}		if (mapTrig) then			GetDialogItem(inspDlog, 3, itemType, item, itemBounds)		else			GetDialogItem(inspDlog, 4, itemType, item, itemBounds);		SetControlValue(ControlHandle(item), 255);{handle the actual dialog}		repeat			ModalDialog(nil, itemHit);			if (itemHit = 3) or (itemHit = 4) then				begin{the map radio button, the abstract radio button}					GetDialogItem(inspDlog, 3, itemType, item, itemBounds);					SetControlValue(ControlHandle(item), 0);					GetDialogItem(inspDlog, 4, itemType, item, itemBounds);					SetControlValue(ControlHandle(item), 0);					GetDialogItem(inspDlog, itemHit, itemType, item, itemBounds);					SetControlValue(ControlHandle(item), 255);					mapTrig := (itemHit = 3);				end;		until (itemHit = 1);{set the trigP icon, if necessary}		if (mapTrig) then			trigP.h := goopy.h+1 		else			trigP.h := goopy.h+2;{store the trigger data}		if (tag^.winWorld^.theWorld^[loc.h, loc.v].state = 0) then			tag^.winWorld^.theWorld^[loc.h, loc.v].trigP := trigP		else			tag^.winWorld^.theWorld^[loc.h, loc.v].p := trigP;{get the new value they typed in}		GetDialogItem(inspDlog, 2, itemType, item, itemBounds);		GetDialogItemText(item, typedText);		typedInt := Q_StrToInt(typedText);{now set the value appropriately}		tag^.winWorld^.theWorld^[loc.h, loc.v].trig := typedInt;{get rid of the dialog}		DisposeDialog(inspDlog);{redraw the world}		tag^.drawOffscreen := true;		DrawWorld(worldWind);{reset the cursor}		SetCursor(gCurrentCurs^^);	end;	procedure World_ToggleAllTrig (worldWind: WindowPtr;									tag: MRWinTag;									trigVal: integer);		var			x, y: integer;			tempPt: Point;			theWorld: WorldArrayPtr;	begin{for efficiency, grab the actual world}		theWorld := tag^.winWorld^.theWorld;		for x := 1 to kMaxWorldSize do			for y := 1 to kMaxWorldSize do				if (theWorld^[x, y].trig = trigVal) then					begin						tempPt := theWorld^[x, y].p;						theWorld^[x, y].p := theWorld^[x, y].trigP;						theWorld^[x, y].trigP := tempPt;						if (theWorld^[x, y].kind = 1) then							theWorld^[x, y].state := 1 - theWorld^[x, y].state;					end;	end;	procedure World_MultiInspect (worldWind: WindowPtr;									tag: MRWinTag);		function SelectionContainsDiamond (tag: MRWinTag): boolean;			var				h, v: integer;				hasDiamond: Boolean;				iconPt: Point;		begin			hasDiamond := false;			h := tag^.selectionRect.left;			v := tag^.selectionRect.top;			while (not hasDiamond) and (h < tag^.selectionRect.right) do				begin					while (not hasDiamond) and (v < tag^.selectionRect.bottom) do						begin							iconPt := tag^.winWorld^.theWorld^[h, v].p;							hasDiamond := (iconPt.v = 6);							v := v + 1;						end;					v := tag^.selectionRect.top;					h := h + 1;				end;			SelectionContainsDiamond := hasDiamond;		end;		function SelectionContainsSwitchIDs (tag: MRWinTag): Boolean;			var				h, v: integer;				hasID: Boolean;		begin			hasID := false;			h := tag^.selectionRect.left;			v := tag^.selectionRect.top;			while (not hasID) and (h < tag^.selectionRect.right) do				begin					while (not hasID) and (v < tag^.selectionRect.bottom) do						begin							hasID := (tag^.winWorld^.theWorld^[h, v].trig > 0);							v := v + 1;						end;					v := tag^.selectionRect.top;					h := h + 1;				end;			SelectionContainsSwitchIDs := hasID;		end;		var			doIt: Boolean;	begin{multi-inspection works like this:}{first, check for diamonds. you can't switch 'em}		if (SelectionContainsDiamond(tag)) then			begin				World_Warning('You cannot multi-inspect a selection containing a diamond (switch). Sorry.');			end{next, check for previous switch IDs already set}		else			begin				doIt := true;				if (SelectionContainsSwitchIDs(tag)) then					doIt := World_ChoiceWarning('Multi-inspect will erase current switch IDs inside your selection. Proceed?');				if (doIt) then					World_MultiInspDlog(worldWind, tag);			end;	end;	procedure World_CopyArea (f, t: WorldArrayPtr;									rf, rt: Rect);		var			h, v, h2, v2: integer;	begin{this routine is coded for maximum efficency, as if pascal does that kinda stuff.}		h2 := rt.left;		for h := rf.left to rf.right - 1 do			begin				v2 := rt.top;				for v := rf.top to rf.bottom - 1 do					begin						t^[h2, v2] := f^[h, v];						v2 := v2 + 1;					end;				h2 := h2 + 1;			end;	end;	procedure World_ContentClick (worldWind: WindowPtr;									where: point;									mods: integer);		const			kPencilThing = 1;			kFillThing = 2;			kSelectThing = 3;			kEyedropThing = 4;			kInspectThing = 5;			kToggleThing = 6;			kGrabSelectThing = 7;			kMultiInspectThing = 8;			kUnselectThing = 9;			kNoThing = 10;		var			tag: MRWinTag;			loc: Point;			iconToDraw: Point;			oldPort: GrafPtr;			pr: Rect;			thingToDo: integer;{for fills}			fillVal: Point;			x, y: integer;			newX, newY: integer;			myStack: stack;			trigVal: integer;{for shift-constrain}			rememberLoc: Point;			haveConstrain: Boolean;			constrainHoriz: Boolean;{for select}			curLoc: Point;			calcRect: Rect;			lastSelRect: Rect;			offsetPt: Point;	begin{remember where we parked!}		GetPort(oldPort);		SetPort(worldWind);{get the rect}		pr := worldWind^.portRect;		pr.right := pr.right - kFudge;		pr.bottom := pr.bottom - kFudge;{get the tag}		tag := MRWinTag(GetWRefCon(worldWind));{init the "thing"}		thingToDo := kPencilThing;{what "thing" do we want to do?}		if (BAND(mods, cmdKey) = cmdKey) and (not tag^.haveSelection) then			thingToDo := kToggleThing		else if (BAND(mods, optionKey) = optionKey) and (not tag^.haveSelection) then			thingToDo := kEyedropThing		else if (BAND(mods, controlKey) = controlKey) and (not tag^.haveSelection) then			thingToDo := kInspectThing		else			case gCurTool of				kPencil: 					thingToDo := kPencilThing;				kFill: 					thingToDo := kFillThing;				kSelect: 					if (tag^.haveSelection) then						begin							if (BAND(mods, controlKey) = controlKey) then								thingToDo := kMultiInspectThing							else if (gLastCursor = cArrow) then								thingToDo := kGrabSelectThing							else								thingToDo := kSelectThing;						end					else						thingToDo := kSelectThing;				kEyeDrop: 					thingToDo := kEyedropThing;			end;		if (tag^.winKind = kLevelKind) then			begin				if (thingToDo = kInspectThing) or (thingToDo = kMultiInspectThing) or (thingToDo = kToggleThing) then					thingToDo := kNoThing;			end;{do that particular "thing"}		case thingToDo of			kNoThing: 				begin					SysBeep(5);				end;			kPencilThing: 				begin{repeat while mouse button is down}					rememberLoc := World_PointFromMouse(worldWind, where);					haveConstrain := false;					constrainHoriz := true;					repeat						if PtInRect(where, pr) then							begin								loc := World_PointFromMouse(worldWind, where);								if (BAND(mods, shiftKey) = shiftKey) then									begin{shift-constrain keeps drawing on a line.}										if (not haveConstrain) then											begin												if (loc.v <> rememberLoc.v) then													begin														constrainHoriz := false;														haveConstrain := true;														loc.h := rememberLoc.h;													end												else if (loc.h <> rememberLoc.h) then													begin														haveConstrain := true;														loc.v := rememberLoc.v;													end;											end										else if (constrainHoriz) then											loc.v := rememberLoc.v										else											loc.h := rememberLoc.h;									end;								iconToDraw := tag^.drawIcon;								World_DrawSingleIconAt(tag^.pathOff, tag^.worldOff, tag, loc, iconToDraw);								World_SetGridIcon(tag, loc, iconToDraw);								World_RevealSingleIcon(worldWind, loc);							end;						GetMouse(where);					until (not Button);				end;			kFillThing: 				begin					loc := World_PointFromMouse(worldWind, where);					x := loc.h;					y := loc.v;					myStack := newStack;					fillVal := tag^.winWorld^.theWorld^[x, y].p;					Push(myStack, x, y);					while not StackEmpty(myStack) do						begin							Pop(myStack, newX, newY);							if (EqualPt(tag^.winWorld^.theWorld^[newX, newY].p, fillVal)) then								begin									if (newX + 1 <= kMaxWorldSize) then										Push(myStack, newX + 1, newY);									if (newY + 1 <= kMaxWorldSize) then										Push(myStack, newX, newY + 1);									if (newX - 1 > 0) then										Push(myStack, newX - 1, newY);									if (newY - 1 > 0) then										Push(myStack, newX, newY - 1);									tag^.winWorld^.theWorld^[newX, newY].p := tag^.drawIcon;								end;						end;					KillStack(myStack);					tag^.drawOffscreen := true;					DrawWorld(worldWind);				end;			kSelectThing: 				begin					loc := World_PointFromMouse(worldWind, where);					tag^.haveSelection := true;					SetRect(lastSelRect, -1, -1, -1, -1);					pr := worldWind^.portRect;					pr.right := pr.right - kFudge;					pr.bottom := pr.bottom - kFudge;					if (tag^.copyWorld <> nil) then						begin							DisposePtr(Ptr(tag^.copyWorld));							tag^.copyWorld := nil;						end;					while Button do						begin							GetMouse(where);							curLoc := World_PointFromMouse(worldWind, where);							if (loc.h < curLoc.h) then								begin									tag^.selectionRect.left := loc.h;									tag^.selectionRect.right := curLoc.h;								end							else								begin									tag^.selectionRect.right := loc.h;									tag^.selectionRect.left := curLoc.h;								end;							if (loc.v < curLoc.v) then								begin									tag^.selectionRect.top := loc.v;									tag^.selectionRect.bottom := curLoc.v;								end							else								begin									tag^.selectionRect.bottom := loc.v;									tag^.selectionRect.top := curLoc.v;								end;							if (not PtInRect(where, pr)) then								begin{scroll the window}									if (where.h < pr.left) then										World_HorizAction(tag^.hScroll, 20)									else if (where.h > pr.right) then										World_HorizAction(tag^.hScroll, 21);									if (where.v < pr.top) then										World_VertAction(tag^.vScroll, 20)									else if (where.v > pr.bottom) then										World_VertAction(tag^.vScroll, 21);									lastSelRect := tag^.selectionRect;								end							else if (not EqualRect(lastSelRect, tag^.selectionRect)) then								begin									DrawWorld(worldWind);									lastSelRect := tag^.selectionRect;								end;						end;					if (EmptyRect(tag^.selectionRect)) then						begin							tag^.haveSelection := false;							DrawWorld(worldWind);						end					else						begin							if (tag^.selectionRect.left < 0) then								tag^.selectionRect.left := 0							else if (tag^.selectionRect.right > kMaxWorldSize) then								tag^.selectionRect.right := kMaxWorldSize;							if (tag^.selectionRect.top < 0) then								tag^.selectionRect.top := 0							else if (tag^.selectionRect.bottom > kMaxWorldSize) then								tag^.selectionRect.bottom := kMaxWorldSize;							DrawWorld(worldWind);						end;				end;			kGrabSelectThing: 				begin{this is the big cheeze! i've actually got to move this sucker around.}{i think copying will be automatic, since I also have delete-fill implemented}					if (tag^.copyWorld = nil) then						begin							tag^.copyWorld := WorldArrayPtr(NewPtrClear(sizeof(WorldArray)));							BlockMove(Ptr(tag^.winWorld^.theWorld), Ptr(tag^.copyWorld), sizeof(WorldArray));							tag^.origSelRect := tag^.selectionRect;						end;					loc := World_PointFromMouse(worldWind, where);					offsetPt.h := loc.h - tag^.selectionRect.left;					offsetPt.v := loc.v - tag^.selectionRect.top;					pr := worldWind^.portRect;					pr.right := pr.right - kFudge;					pr.bottom := pr.bottom - kFudge;					while Button do						begin							GetMouse(where);							curLoc := World_PointFromMouse(worldWind, where);							if (loc.h <> curLoc.h) or (loc.v <> curLoc.v) then								begin{user moved. copy the original stuff to the world.}									World_CopyArea(tag^.copyWorld, tag^.winWorld^.theWorld, tag^.selectionRect, tag^.selectionRect);{now calculate the new selection rectangle}									OffsetRect(tag^.selectionRect, curLoc.h - loc.h, curLoc.v - loc.v);{now copy that stuff.}									World_CopyArea(tag^.copyWorld, tag^.winWorld^.theWorld, tag^.origSelRect, tag^.selectionRect);{set up for drawing}									loc := curLoc;									tag^.drawOffscreen := true;									if (not PtInRect(where, pr)) then										begin{scroll the window}											if (where.h < pr.left) then												World_HorizAction(tag^.hScroll, 20)											else if (where.h > pr.right) then												World_HorizAction(tag^.hScroll, 21);											if (where.v < pr.top) then												World_VertAction(tag^.vScroll, 20)											else if (where.v > pr.bottom) then												World_VertAction(tag^.vScroll, 21);										end									else{simply draw the world}										DrawWorld(worldWind);								end;						end;{the copyWorld gets disposed (1) when user clicks to unselect area, or (2) user hits delete.}				end;			kMultiInspectThing: 				begin					World_MultiInspect(worldWind, tag);				end;			kUnselectThing: 				begin					tag^.haveSelection := false;					DrawWorld(worldWind);				end;			kEyedropThing: 				begin					loc := World_PointFromMouse(worldWind, where);					tag^.drawIcon := tag^.winWorld^.theWorld^[loc.h, loc.v].p;					tag^.palUpdate := true;				end;			kInspectThing: 				begin					loc := World_PointFromMouse(worldWind, where);					iconToDraw := tag^.winWorld^.theWorld^[loc.h, loc.v].p;{Levels are rows 0-2}if ( iconToDraw.v < 3) and ( iconToDraw.h > 0 ) and ( iconToDraw.h < 9 ) then   World_LevelInspDlog(worldWind, tag, loc, iconToDraw)else if (iconToDraw.v = 6) and ( iconToDraw.h < 9 ) then   World_SwitchInspDlog(WorldWind, tag, loc, iconToDraw)else   World_PieceInspDlog(worldWind, tag, loc, iconToDraw);   		{			if (iconToDraw.v > 3) or ((iconToDraw.h = 0) and (iconToDraw.v = 0)) then						World_PieceInspDlog(worldWind, tag, loc, iconToDraw)					else if (iconToDraw.h = 3) then						World_LevelInspDlog(worldWind, tag, loc, iconToDraw)					else						World_SwitchInspDlog(WorldWind, tag, loc, iconToDraw);}				end;			kToggleThing: 				begin					loc := World_PointFromMouse(worldWind, where);					iconToDraw := tag^.winWorld^.theWorld^[loc.h, loc.v].p;					if (iconToDraw.v = 6)  then						begin{wowzers! time to toggle!}							trigVal := tag^.winWorld^.theWorld^[loc.h, loc.v].trig;							if (trigVal > 0) then								begin									World_ToggleAllTrig(worldWind, tag, trigVal);									tag^.drawOffscreen := true;									DrawWorld(worldWind);								end							else								World_Warning('Before toggling a switch, you must assign it an ID.');						end					else if (iconToDraw.v < 3) and (iconToDraw.h > 0 ) then						begin{attempt to open up that level}							tag^.openLevel := tag^.winWorld^.theWorld^[loc.h, loc.v].levelID;						end					else						World_Warning('You can only toggle switches (diamonds) into alternate states.');				end;			otherwise				;		end;{Park!}		SetPort(oldPort);	end;	procedure RLEDecompress (cFrom: IntArrayPtr;									cTo: IntArrayPtr);		var			fromIndex, toIndex: integer;			count: integer;			runLength: integer;			runInt: integer;	begin{prepare}		fromIndex := 1;		toIndex := 1;{decompress}		while cFrom^[fromIndex] <> kRLEEnd do			begin				if (cFrom^[fromIndex] = kRLEFlag) then					begin						fromIndex := fromIndex + 1;						runLength := cFrom^[fromIndex];						fromIndex := fromIndex + 1;						runInt := cFrom^[fromIndex];						fromIndex := fromIndex + 1;						for count := 1 to runLength do							begin								cTo^[toIndex] := runInt;								toIndex := toIndex + 1;							end;					end				else					begin						cTo^[toIndex] := cFrom^[fromIndex];						toIndex := toIndex + 1;						fromIndex := fromIndex + 1;					end;			end;{fini}	end;	function RLECompress (cFrom: IntArrayPtr;									cTo: IntArrayPtr): integer;		var			index: integer;			counter: integer;			runInt: integer;			{the integer being run}			runLength: integer;	{how long it is being run}			cntLength: integer;	begin{prepare}		index := 1;		runInt := cFrom^[1];		runLength := 0;{compress}		for counter := 1 to kMaxWorldSizeSquared do			begin{still in current run}				if (cFrom^[counter] = runInt) then					runLength := runLength + 1{end of previous run, but run was too short}				else if (runLength < 4) then					begin						for cntLength := 1 to runLength do							begin								cTo^[index] := runInt;								index := index + 1;							end;						runLength := 1;						runInt := cFrom^[counter];					end{end of previous run, got a big run.}				else					begin{add compression info}						cTo^[index] := kRLEFlag;						index := index + 1;						cTo^[index] := runLength;						index := index + 1;						cTo^[index] := runInt;						index := index + 1;{now reset the run info}						runLength := 1;						runInt := cFrom^[counter];					end;			end;{output the final run}		if (runLength < 4) then			begin				for cntLength := 1 to runLength do					begin						cTo^[index] := runInt;						index := index + 1;					end;				runLength := 1;				runInt := cFrom^[counter];			end{end of previous run, got a big run.}		else			begin{add compression info}				cTo^[index] := kRLEFlag;				index := index + 1;				cTo^[index] := runLength;				index := index + 1;				cTo^[index] := runInt;				index := index + 1;{now reset the run info}				runLength := 1;				runInt := cFrom^[counter];			end;{all done}		cTo^[index] := kRLEEnd;{fini}		RLECompress := index;	end;	procedure World_LevelDecompress (tag: MRWinTag;									lev: WorldArrayPtr;									p: Ptr);		var			e: ExtraLevelInfo;			c, d: FlatLevel;			count: integer;			x, y: integer;	begin		if (gLastCursor <> cWatch) then			begin				gCurrentCurs := GetCursor(cWatch);				gLastCursor := cWatch;				SetCursor(gCurrentCurs^^);			end;{allocate memory}		c.ph := IntArrayPtr(NewPtrClear(sizeof(IntArray)));		c.pv := IntArrayPtr(NewPtrClear(sizeof(IntArray)));		c.kind := IntArrayPtr(NewPtrClear(sizeof(IntArray)));		d.ph := IntArrayPtr(NewPtrClear(sizeof(IntArray)));		d.pv := IntArrayPtr(NewPtrClear(sizeof(IntArray)));		d.kind := IntArrayPtr(NewPtrClear(sizeof(IntArray)));{grab data}		tag^.usesExtendedData := false;		BlockMove(p, @e, sizeof(OldExtraLevelInfo));		if (e.reqInfo < 0) then			begin				BlockMove(p, @e, sizeof(ExtraLevelInfo));				p := Ptr(longint(p) + sizeof(ExtraLevelInfo));				tag^.usesExtendedData := true;			end		else			p := Ptr(longint(p) + sizeof(OldExtraLevelInfo));		BlockMove(p, Ptr(c.ph), e.phCount * sizeof(integer));		p := Ptr(longint(p) + e.phCount * sizeof(integer));		BlockMove(p, Ptr(c.pv), e.pvCount * sizeof(integer));		p := Ptr(longint(p) + e.pvCount * sizeof(integer));		BlockMove(p, Ptr(c.kind), e.kindCount * sizeof(integer));		p := Ptr(longint(p) + e.kindCount * sizeof(integer));{decompress data}		RLEDecompress(c.ph, d.ph);		RLEDecompress(c.pv, d.pv);		RLEDecompress(c.kind, d.kind);{unflatten data}		x := 1;		y := 1;		for count := 1 to kMaxWorldSizeSquared do			begin				lev^[x, y].p.h := d.ph^[count];				lev^[x, y].p.v := d.pv^[count];				lev^[x, y].kind := d.kind^[count];				x := x + 1;				if (x > kMaxWorldSize) then					begin						x := 1;						y := y + 1;					end;			end;{set extra data}		tag^.winTitle := e.levelTitle;		tag^.levelInfo := e.levelInfo;		tag^.reqInfo := e.reqInfo;		tag^.levelWorld := e.levelWorld;		if (tag^.usesExtendedData) then			begin				tag^.reqInfo := e.actualInfo;				tag^.hours := e.hours;				tag^.mins := e.mins;				tag^.secs := e.secs;			end;{release memory}		DisposePtr(Ptr(c.ph));		DisposePtr(Ptr(c.pv));		DisposePtr(Ptr(c.kind));		DisposePtr(Ptr(d.ph));		DisposePtr(Ptr(d.pv));		DisposePtr(Ptr(d.kind));		if (gLastCursor <> cArrow) then			begin				gLastCursor := cArrow;				InitCursor;			end;	end;	function World_LevelCompress (tag: MRWinTag;									lev: WorldArrayPtr): Ptr;		var			c: FlatLevel;			x, y: integer;			index: integer;			d: FlatLevel;			phInt, pvInt, kindInt: integer;			outPtr, addPtr: Ptr;			e: ExtraLevelInfo;	begin		if (gLastCursor <> cWatch) then			begin				gCurrentCurs := GetCursor(cWatch);				gLastCursor := cWatch;				SetCursor(gCurrentCurs^^);			end;{allocate}		c.ph := IntArrayPtr(NewPtrClear(sizeof(IntArray)));		c.pv := IntArrayPtr(NewPtrClear(sizeof(IntArray)));		c.kind := IntArrayPtr(NewPtrClear(sizeof(IntArray)));		d.ph := IntArrayPtr(NewPtrClear(sizeof(IntArray)));		d.pv := IntArrayPtr(NewPtrClear(sizeof(IntArray)));		d.kind := IntArrayPtr(NewPtrClear(sizeof(IntArray)));{set}		if (tag^.usesExtendedData) then			begin				e.reqInfo := -1;				e.actualInfo := tag^.reqInfo;				e.hours := tag^.hours;				e.mins := tag^.mins;				e.secs := tag^.secs;			end		else			e.reqInfo := tag^.reqInfo;		e.levelInfo := tag^.levelInfo;		e.levelWorld := tag^.levelWorld;		e.levelTitle := tag^.winTitle;{flatten out}		index := 1;		for y := 1 to kMaxWorldSize do			for x := 1 to kMaxWorldSize do				begin					c.ph^[index] := lev^[x, y].p.h;					c.pv^[index] := lev^[x, y].p.v;					c.kind^[index] := lev^[x, y].kind;					index := index + 1;				end;{RLE compress}		phInt := RLECompress(c.ph, d.ph);		pvInt := RLECompress(c.pv, d.pv);		kindInt := RLECompress(c.kind, d.kind);		e.phCount := phInt;		e.pvCount := pvInt;		e.kindCount := kindInt;{make the derned ptr}		outPtr := NewPtrClear(sizeof(ExtraLevelInfo) + ((phInt + pvInt + kindInt) * sizeof(integer)));{fill it}		if (tag^.usesExtendedData) then			begin				BlockMove(@e, outPtr, sizeof(ExtraLevelInfo));				addPtr := Ptr(longint(outPtr) + sizeof(ExtraLevelInfo));			end		else			begin				BlockMove(@e, outPtr, sizeof(OldExtraLevelInfo));				addPtr := Ptr(longint(outPtr) + sizeof(OldExtraLevelInfo));			end;		BlockMove(Ptr(d.ph), addPtr, sizeof(integer) * phInt);		addPtr := Ptr(longint(addPtr) + (sizeof(integer) * phInt));		BlockMove(Ptr(d.pv), addPtr, sizeof(integer) * pvInt);		addPtr := Ptr(longint(addPtr) + (sizeof(integer) * pvInt));		BlockMove(Ptr(d.kind), addPtr, sizeof(integer) * kindInt);		addPtr := Ptr(longint(addPtr) + (sizeof(integer) * kindInt));{release old data}		DisposePtr(Ptr(c.ph));		DisposePtr(Ptr(c.pv));		DisposePtr(Ptr(c.kind));		DisposePtr(Ptr(d.ph));		DisposePtr(Ptr(d.pv));		DisposePtr(Ptr(d.kind));{return it}		World_LevelCompress := outPtr;		if (gLastCursor <> cArrow) then			begin				gLastCursor := cArrow;				InitCursor;			end;	end;	function MakeWorldWindow (worldTitle: str255;									resID: integer): WindowPtr;		var			newWind: WindowPtr;			newTag: MRWinTag;			newWorld: MRWorldInfo;			picRect: rect;			winRect: rect;			pr: rect;	begin{make the window}		if (resID = 0) then			newWind := GetNewCWindow(wWorld + 1, nil, WindowPtr(-1))		else			newWind := GetNewCWindow(128, nil, WindowPtr(-1));		SetPort(newWind);{make the tag}		if (resID <> 0) then			newTag := World_MakeWinTag(newWind, worldTitle, kLevelKind)		else			newTag := World_MakeWinTag(newWind, worldTitle, kMapKind);		newTag^.resID := resID;{make the world itself}		newTag^.winWorld := World_MakeWorldInfo;{associate the tag with the window}		SetWRefCon(newWind, longint(newTag));{show the window}		if (not gDontShow) then			ShowWindow(newWind);		gDontShow := false;{make the controls}		World_MakeScrollInfo(newWind, newTag);{draw it}		DrawWorld(newWind);{resize safely}		ResizeWorld(newWind);{return the window}		MakeWorldWindow := newWind;	end;	function LoadWorldWindow (worldTitle: str255;									resID: integer): WindowPtr;		var			worldResource: Handle;			oldRes: integer;		var			newWind: WindowPtr;			newTag: MRWinTag;			newWorld: MRWorldInfo;			picRect: rect;			winRect: rect;			pr: rect;			id: integer;			theType: ResType;			theName: Str255;	begin		oldRes := CurResFile;		UseResFile(gListRes);		if (resID <> 0) then			worldResource := Get1Resource(kLevelResType, resID)		else			worldResource := Get1Resource(kWorldResType, kWorldResID);		if (worldResource = nil) then			begin				LoadWorldWindow := MakeWorldWindow(worldTitle, resID);			end		else			begin{make the window}				if (resID = 0) then					newWind := GetNewCWindow(wWorld + 1, nil, WindowPtr(-1))				else					newWind := GetNewCWindow(128, nil, WindowPtr(-1));				SetPort(newWind);{make the tag}				if (resID <> 0) then					begin						GetResInfo(worldResource, id, theType, theName);						newTag := World_MakeWinTag(newWind, theName, kLevelKind);					end				else					newTag := World_MakeWinTag(newWind, worldTitle, kMapKind);				newTag^.resID := resID;{make the world itself}				newTag^.winWorld := World_MakeWorldInfo;				HLockHi(worldResource);				if (resID = 0) then					BlockMove(Ptr(worldResource^), Ptr(newTag^.winWorld^.theWorld), sizeof(WorldArray))				else					begin{must decompress the data}						World_LevelDecompress(newTag, newTag^.winWorld^.theWorld, Ptr(worldResource^));{draw the correct world-pict}						World_DrawPicInOff(132 + newTag^.levelWorld, newTag^.pathOff);						newTag^.drawOffscreen := true;					end;				HUnlock(worldResource);				ReleaseResource(worldResource);{associate the tag with the window}				SetWRefCon(newWind, longint(newTag));{show the window}				if (not gDontShow) then					ShowWindow(newWind);				gDontShow := false;{make the controls}				World_MakeScrollInfo(newWind, newTag);{draw it}				DrawWorld(newWind);{resize safely}				ResizeWorld(newWind);{return it}				LoadWorldWindow := newWind;			end;		UseResFile(oldRes);	end;	procedure CloseWorldWindow (var worldWind: WindowPtr);		var			tag: MRWinTag;	begin{before closing, save, unless global save is off}	if ( map_glob_save ) then begin 		SaveWorld(worldWind);	end;{now close}		tag := MRWinTag(GetWRefCon(worldWind));		World_DestroyWorldInfo(tag^.winWorld);		World_DestroyWinTag(tag);		DisposeWindow(worldWind);	end;	procedure MouseOverWorldWindow (worldWind: WindowPtr;									where: point;									mods: integer);		var			tag: MRWinTag;			pr: Rect;			calcSelRect: Rect;	begin{get the tag}		tag := MRWinTag(GetWRefCon(worldWind));{how big is the window?}		pr := worldWind^.portRect;		OffsetRect(pr, -pr.left, -pr.top);		pr.right := pr.right - kFudge;		pr.bottom := pr.bottom - kFudge;{content point?}		if PtInRect(where, pr) then			begin{if ctrl-key is held down, reveal a magnifying glass}{if option-key is held down, reveal the eye-dropper}{otherwise, reveal the current tool}				if (BAND(mods, cmdKey) = cmdKey) and (not tag^.haveSelection) then					begin						if (gLastCursor <> cToggle) then							begin								gCurrentCurs := GetCursor(cToggle);								gLastCursor := cToggle;								SetCursor(gCurrentCurs^^);							end;					end				else					if (BAND(mods, controlKey) = controlKey) then						begin							if (gLastCursor <> cInspect) then								begin									gCurrentCurs := GetCursor(cInspect);									gLastCursor := cInspect;									SetCursor(gCurrentCurs^^);								end;						end  {ctrl mod key}					else if (BAND(mods, optionKey) = optionKey) and (not tag^.haveSelection) then						begin							if (gLastCursor <> cEyedrop) then								begin									gCurrentCurs := GetCursor(cEyedrop);									gLastCursor := cEyedrop;									SetCursor(gCurrentCurs^^);								end;						end {option mod key}					else if tag^.haveSelection then						begin{have selection. first calculate where the selection is onscreen}							calcSelRect := World_SelRectInWindow(tag);							if PtInRect(where, calcSelRect) then								begin									if (gLastCursor <> cArrow) then										begin											gLastCursor := cArrow;											InitCursor;										end;								end							else								begin									if (gLastCursor <> gCurTool) then										begin											gCurrentCurs := GetCursor(gCurTool);											gLastCursor := gCurTool;											SetCursor(gCurrentCurs^^);										end;								end;						end					else						begin							if (gLastCursor <> gCurTool) then								begin									gCurrentCurs := GetCursor(gCurTool);									gLastCursor := gCurTool;									SetCursor(gCurrentCurs^^);								end;						end; {no special mod keys}			end {point not in world window's contents}		else			begin{check to see if it needs to be changed back to the arrow}				if (gLastCursor <> cArrow) then					begin						gLastCursor := cArrow;						InitCursor;					end;			end;	end;	procedure WorldWindowClick (worldWind: WindowPtr;									where: point;									mods: integer);		var			pr: rect;			control: ControlHandle;			part: integer;			tag: MRWinTag;	begin{get the rectangle of the window's actual contents (-scrollbars)}		pr := worldWind^.portRect;		pr.right := pr.right - kFudge;		pr.bottom := pr.bottom - kFudge;{okay, first check to see if they clicked in the content area}		if PtInRect(where, pr) then			World_ContentClick(worldWind, where, mods)		else			begin{yikes. time to handle scrollbars.}				tag := MRWinTag(GetWRefCon(worldWind));				part := FindControl(where, worldWind, control);				case part of					129: 						begin							part := TrackControl(control, where, nil);							if (part = 129) then								begin									tag^.drawOffscreen := true;									DrawWorld(worldWind);								end; {129 again}						end;{thumb}					20, 21, 22, 23: 						begin							if (control = tag^.vScroll) then								part := TrackControl(control, where, @World_VertAction)							else								part := TrackControl(control, where, @World_HorizAction);						end;{btns}					otherwise						;				end;{case}{end of handle scrollbars.}			end;	end;	procedure SaveWorld (worldWind: WindowPtr);		var			resHandle: Handle;			oldHandle: Handle;			tag: MRWinTag;			curRef: integer;			error: OSErr;			outPtr: Ptr;	begin{get the tag}		tag := MRWinTag(GetWRefCon(worldWind));{make the handle}		if (tag^.winKind = kMapKind) then			error := PtrToHand(Ptr(tag^.winWorld^.theWorld), resHandle, sizeof(WorldArray))		else			begin				outPtr := World_LevelCompress(tag, tag^.winWorld^.theWorld);				error := PtrToHand(outPtr, resHandle, GetPtrSize(outPtr));			end;		if (error = noErr) then			begin				curRef := CurResFile;				UseResFile(gListRes);				if (tag^.winKind = kMapKind) then					oldHandle := Get1Resource(kWorldResType, kWorldResID)				else					oldHandle := Get1Resource(kLevelResType, tag^.resID);				if (oldHandle <> nil) then					begin						RemoveResource(oldHandle);						UpdateResFile(gListRes);					end;				if (tag^.winKind = kMapKind) then					AddResource(resHandle, kWorldResType, kWorldResID, 'Overhead World')				else					AddResource(resHandle, kLevelResType, tag^.resID, tag^.winTitle);				UpdateResFile(gListRes);				ReleaseResource(resHandle);				UpdateResFile(gListRes);				UseResFile(curRef);			end;		if (tag^.winKind = kLevelKind) then			DisposePtr(outPtr);	end;	procedure SaveWorldID (worldWind: WindowPtr;									resID: integer);		var			tag: MRWinTag;	begin{get the tag}		tag := MRWinTag(GetWRefCon(worldWind));		tag^.resID := resID;		SaveWorld(worldWind);	end;	procedure DrawWorld (worldWind: WindowPtr);		var			oldPort: GrafPtr;			tag: MRWinTag;			pr: Rect;			oldClip: RgnHandle;			calcRect: Rect;	begin		GetPort(oldPort);		SetPort(worldWind);{get the tag}		tag := MRWinTag(GetWRefCon(worldWind));{check to see if the offscreen needs to be redrawn}		if (tag^.drawOffscreen) then			World_DrawFullOffscreen(tag);{pop the offscreen onto the onscreen, but snip it correctly}		pr := worldWind^.portRect;		OffsetRect(pr, -pr.left, -pr.top);		pr.right := pr.right - kFudge;		pr.bottom := pr.bottom - kFudge;		CopyOffToOffRect(tag^.worldOff, true, GWorldPtr(worldWind), false, pr, pr);{draw the selection, if any}		if (tag^.haveSelection) then			begin				oldClip := NewRgn;				GetClip(oldClip);				ClipRect(pr);				calcRect := World_SelRectInWindow(tag);				ForeColor(whiteColor);				FrameRect(calcRect);				ForeColor(blackColor);				SetClip(oldClip);				DisposeRgn(oldClip);			end;{draw the controls}		UpdateControls(worldWind, worldWind^.visRgn);{and don't forget the grow thang}		DrawGrowIcon(worldWind);		SetPort(oldPort);	end;	procedure ResizeWorld (worldWind: WindowPtr);		const			kScrollbarWidth = 16;			kScrollBarAdjust = kScrollBarWidth - 1;			kScrollBarTweek = 2;		var			tag: MRWinTag;			pr: Rect;			cValue: integer;	begin		tag := MRWinTag(GetWRefCon(worldWind));{before anything, make sure that the window is a multiple of the size of the world items.}{this speeds up scrolling immensely}{get the window's portRect}		pr := worldWind^.portRect;		OffsetRect(pr, -pr.left, -pr.top);		if ((pr.right - kFudge) div gWorldItemSize) <> ((pr.right - kFudge) / gWorldItemSize) then			pr.right := (((pr.right - kFudge) div gWorldItemSize) * gWorldItemSize) + kFudge;		if ((pr.bottom - kFudge) div gWorldItemSize) <> ((pr.bottom - kFudge) / gWorldItemSize) then			pr.bottom := (((pr.bottom - kFudge) div gWorldItemSize) * gWorldItemSize) + kFudge;		SizeWindow(worldWind, pr.right, pr.bottom, false);{first deal with the piddly stuff - the controls}{hide 'em}		HideControl(tag^.vScroll);		HideControl(tag^.hScroll);{position the controls}		MoveControl(tag^.vScroll, pr.right - kScrollbarAdjust, -1);		SizeControl(tag^.vScroll, kScrollBarWidth, (pr.bottom - pr.top) - (kScrollBarAdjust - kScrollBarTweek));		MoveControl(tag^.hScroll, -1, pr.bottom - kScrollBarAdjust);		SizeControl(tag^.hScroll, (pr.right - pr.left) - (kScrollBarAdjust - kScrollBarTweek), kScrollBarWidth);{now figger out info about iconsdown and across}		tag^.iconsAcross := ((pr.right - kFudge) div gWorldItemSize);		tag^.iconsDown := ((pr.bottom - kFudge) div gWorldItemSize);{now calc the new control mins and maxes:}		SetControlMinimum(tag^.vScroll, 1);		SetControlMaximum(tag^.vScroll, kMaxWorldSize - tag^.iconsDown);		SetControlMinimum(tag^.hScroll, 1);		SetControlMaximum(tag^.hScroll, kMaxWorldSize - tag^.iconsAcross);{and make sure their values fall in range}		cValue := GetControlValue(tag^.vScroll);		if (cValue > kMaxWorldSize - tag^.iconsDown) then			SetControlValue(tag^.vScroll, kMaxWorldSize - tag^.iconsDown);		cValue := GetControlValue(tag^.hScroll);		if (cValue > kMaxWorldSize - tag^.iconsAcross) then			SetControlValue(tag^.hScroll, kMaxWorldSize - tag^.iconsAcross);{show 'em}		ShowControl(tag^.vScroll);		ShowControl(tag^.hScroll);{now deal with the less pidly stuff - the offscreen}		DestroyGWorld(tag^.worldOff);		pr.right := pr.right - kFudge;		pr.bottom := pr.bottom - kFudge;		tag^.worldOff := MakeGWorldDepth(pr, 8);{must update offscreen}		tag^.drawOffscreen := true;{draw the world}		DrawWorld(worldWind);	end;	procedure WorldActivate (worldWind: WindowPtr;									active: Boolean);		var			tag: MRWinTag;	begin		if (worldWind <> nil) then			begin				tag := MRWinTag(GetWRefCon(worldWind));				if (active) then					begin						HiliteControl(tag^.vScroll, 0);						HiliteControl(tag^.hScroll, 0);						HiliteWindow(worldWind, true);						gWorldItemSize := tag^.itemSize;					end				else					begin						HiliteControl(tag^.vScroll, 255);						HiliteControl(tag^.hScroll, 255);						HiliteWindow(worldWind, false);					end;				DrawWorld(worldWind);			end;	end;	procedure SetDrawIcon (worldWind: WindowPtr;									drawIcon: Point);		var			tag: MRWinTag;	begin		tag := MRWinTag(GetWRefCon(worldWind));		tag^.drawIcon := drawIcon;	end;	procedure DrawCurrentMapIcon (worldWind: WindowPtr;									drawRect: Rect);		var			tag: MRWinTag;			currentPort: GrafPtr;	begin		tag := MRWinTag(GetWRefCon(worldWind));		GetPort(currentPort);		EraseRect(drawRect);		if (tag^.winKind = kMapKind) then			InsetRect(drawRect, 4, 4);		World_DrawSingleIcon(tag^.pathOff, GWorldPtr(currentPort), drawRect, tag^.drawIcon);	end;	procedure SelectWorldIcon (worldWind: WindowPtr);		procedure AdjustRect (var r: rect);			var				fitInRect: Rect;		begin{where can we fit?}			fitInRect := qd.screenBits.bounds;			fitInRect.top := fitInRect.top + 25;{adjust a rectangle in global coords to fit inside the screen}			if not PtInRect(r.botRight, fitInRect) then				begin					if r.bottom > fitInRect.bottom then						OffsetRect(r, 0, fitInRect.bottom - r.bottom);					if r.right > fitInRect.right then						OffsetRect(r, fitInRect.right - r.right, 0);				end;			if not PtInRect(r.topLeft, fitInRect) then				begin					if (r.top < fitInRect.top) then						OffsetRect(r, 0, fitInRect.top - r.top);					if (r.left < fitInRect.left) then						OffsetRect(r, fitInRect.left - r.left, 0);				end;		end;		const			kSelWindSeparation = 4;			kSelWindStart = 4;			kSelWindAdjust = -10;		function SelPointFromLoc (p: Point): Point;			var				retPoint: Point;		begin			p.h := p.h - kSelWindStart;			p.v := p.v - kSelWindStart;			p.h := p.h div (gWorldItemSize + kSelWindSeparation);			p.v := p.v div (gWorldItemSize + kSelWindSeparation);			retPoint := p;			SelPointFromLoc := retPoint;		end;		function FrameRectFromLoc (p: Point): Rect;			var				retRect: Rect;				locPlace: Point;				curPort: GrafPtr;		begin			GetPort(curPort);			if PtInRect(p, curPort^.portRect) then				begin					locPlace := SelPointFromLoc(p);					SetRect(retRect, 0, 0, gWorldItemSize, gWorldItemSize);					InsetRect(retRect, -2, -2);					OffsetRect(retRect, kSelWindStart, kSelWindStart);					OffsetRect(retRect, locPlace.h * (gWorldItemSize + kSelWindSeparation), locPlace.v * (gWorldItemSize + kSelWindSeparation));				end			else				SetRect(retRect, -1, -1, -1, -1);			FrameRectFromLoc := retRect;		end;		var			tag: MRWinTag;			palWind: GrafPtr;			selectWind: WindowPtr;			iconsH, iconsV: integer;			picRect: Rect;			selWindRect: Rect;			mouseLoc: Point;			drawIconPoint: Point;			drawIconRect: Rect;			drawH, drawV: integer;			selRect: Rect;			lastSelRect: Rect;			selPoint: Point;			intIconsH : integer;			intIconsV : integer;				begin		GetPort(palWind);{get the tag}		tag := MRWinTag(GetWRefCon(worldWind));{figure out how many icons there are in each direction inside the PICT itself}		if (tag^.winKind = kMapKind) then			picRect := GetPRect(pWorld)		else			picRect := GetPRect(132);		OffsetRect(picRect, -picRect.left, -picRect.top);		picRect.right := picRect.right - kWorldItemStart;		picRect.bottom := picRect.bottom - kWorldItemStart;		iconsH := picRect.right div (gWorldItemSize + kWorldItemSeparation);		iconsV := picRect.bottom div (gWorldItemSize + kWorldItemSeparation);{now create a window with particular spacing properties}		SetRect(selWindRect, 0, 0, kSelWindStart + (iconsH * (gWorldItemSize + kSelWindSeparation)), kSelWindStart + (iconsV * (gWorldItemSize + kSelWindSeparation)));		OffsetRect(selWindRect, kSelWindAdjust, kSelWindAdjust);		GetMouse(mouseLoc);		LocalToGlobal(mouseLoc);		OffsetRect(selWindRect, mouseLoc.h, mouseLoc.v);{attempt to make the user's mouse centered over the currently selected icon}		selPoint := tag^.drawIcon;		selPoint.h := kSelWindAdjust + (gWorldItemSize div 2) + (selPoint.h * (gWorldItemSize + kSelWindSeparation));		selPoint.v := kSelWindAdjust + (gWorldItemSize div 2) + (selPoint.v * (gWorldItemSize + kSelWindSeparation));		OffsetRect(selWindRect, -selPoint.h, -selPoint.v);{fit the window to the screen}		AdjustRect(selWindRect);{because things are funky.}		iconsH := iconsH - 1;		iconsV := iconsV - 1;{actually make the window}		selectWind := NewCWindow(nil, selWindRect, '', TRUE, altDBoxProc, WindowPtr(-1), FALSE, 0);		ShowWindow(selectWind);		SetPort(selectWind);{now prepare to draw the window's contents - the icons}		SetRect(drawIconRect, 0, 0, gWorldItemSize, gWorldItemSize);		OffsetRect(drawIconRect, kSelWindStart, kSelWindStart);{draw 'em}		for drawH := 0 to iconsH do			begin				for drawV := 0 to iconsV do					begin					 	drawIconPoint.h := drawH;					 	drawIconPoint.v := drawV;						World_DrawSingleIcon(tag^.pathOff, GWorldPtr(selectWind), drawIconRect, drawIconPoint);						OffsetRect(drawIconRect, 0, kSelWindSeparation + gWorldItemSize);					end;				drawIconRect.top := kSelWindStart;				drawIconRect.bottom := drawIconRect.top + gWorldItemSize;				OffsetRect(drawIconRect, kSelWindSeparation + gWorldItemSize, 0);			end;{track the user's choice of map things.}		GetMouse(mouseLoc);		selRect := FrameRectFromLoc(mouseLoc);		ForeColor(blueColor);		FrameRect(selRect);		ForeColor(blackColor);		lastSelRect := selRect;		while Button do			begin				GetMouse(mouseLoc);				selRect := FrameRectFromLoc(mouseLoc);				if EmptyRect(selRect) then					begin						selPoint.h := -1;						selPoint.v := -1;						ForeColor(whiteColor);						FrameRect(lastSelRect);						ForeColor(blackColor);					end				else if ((selRect.top <> lastSelRect.top) or (selRect.left <> lastSelRect.left)) then					begin						ForeColor(whiteColor);						FrameRect(lastSelRect);						ForeColor(blueColor);						FrameRect(selRect);						ForeColor(blackColor);						selPoint := SelPointFromLoc(mouseLoc);					end;				lastSelRect := selRect;			end;		DisposeWindow(selectWind);{if the user picked an icon, set it}		if (selPoint.h >= 0) and (selPoint.h <= iconsH) and (selPoint.v >= 0) and (selPoint.v <= iconsV) then			begin				if (tag^.winKind = kMapKind) then					begin{adjust for level}					if ( selPoint.h > 0 ) and ( selPoint.v < 3 ) and ( selPoint.h < 9 ) then					  selPoint.h := 1;										if ( selPoint.v = 4 ) then begin					   if ( selPoint.h >= 0 ) and ( selPoint.h <= 2 ) then					     selPoint.h := 0					   else if ( selPoint.h >= 3 ) and ( selPoint.h <= 5 ) then					     selPoint.h := 3					   else if ( selPoint.h >= 6 ) and ( selPoint.h <= 8 ) then					     selPoint.h := 6;					end;					end;{set the selpt}				tag^.drawIcon := selPoint;			end;		SetPort(palWind);	end;	function WorldPaletteUpdate (worldWind: WindowPtr): Boolean;		var			tag: MRWinTag;	begin		tag := MRWinTag(GetWRefCon(worldWind));		WorldPaletteUpdate := tag^.palUpdate;		tag^.palUpdate := false;	end;	procedure ZeroWorldSelection (worldWind: WindowPtr);		var			tag: MRWinTag;	begin{get the tag}		tag := MRWinTag(GetWRefCon(worldWind));{no selection}		tag^.haveSelection := false;		if (tag^.copyWorld <> nil) then			begin				DisposePtr(Ptr(tag^.copyWorld));				tag^.copyWorld := nil;			end;{update screen}		DrawWorld(worldWind);	end;	procedure WorldKey (worldWind: WindowPtr;									theKey: char);		var			tag: MRWinTag;			h, v: integer;	begin		tag := MRWinTag(GetWRefCon(worldWind));		if (theKey = char(8)) and (tag^.haveSelection) then			begin{user wants to selection-fill, since they pressed the delete key}				if (tag^.copyWorld <> nil) then					begin{user wants to cancel a copy operation}						World_CopyArea(tag^.copyWorld, tag^.winWorld^.theWorld, tag^.selectionRect, tag^.selectionRect);						DisposePtr(Ptr(tag^.copyWorld));						tag^.copyWorld := nil;						tag^.haveSelection := false;						tag^.drawOffscreen := true;						DrawWorld(worldWind);					end				else if (World_ChoiceWarning('Are you sure you want to fill this entire selection with the current icon?')) then					begin						for h := tag^.selectionRect.left to tag^.selectionRect.right - 1 do							for v := tag^.selectionRect.top to tag^.selectionRect.bottom - 1 do								tag^.winWorld^.theWorld^[h, v].p := tag^.drawIcon;						tag^.drawOffscreen := true;						DrawWorld(worldWind);					end;			end		else if (theKey >= char(28)) and (theKey <= char(31)) and (tag^.haveSelection) then			begin{user pressed an arrow key and wants to move the selection by one grid square}{28 to 31 -> left,right,up,down}				SysBeep(5);			end;	end;	procedure WorldPaste (worldWind: WindowPtr);		var			tag: MRWinTag;			hCent, vCent: integer;			dropRect: Rect;			fromRect: Rect;	begin		tag := MRWinTag(GetWRefCon(worldWind));{calc place to drop it down}		hCent := GetControlValue(tag^.hScroll) + (tag^.iconsAcross div 2);		vCent := GetControlValue(tag^.vScroll) + (tag^.iconsDown div 2);		vCent := vCent - ((tag^.selectionRect.bottom - tag^.selectionRect.top) div 2);		hCent := hCent - ((tag^.selectionRect.right - tag^.selectionRect.left) div 2);		dropRect := tag^.selectionRect;		OffsetRect(dropRect, -dropRect.left, -dropRect.top);		OffsetRect(dropRect, hCent, vCent);{if there is no copyWorld, we've gotsta make one}		if (tag^.copyWorld = nil) then			begin				tag^.copyWorld := WorldArrayPtr(NewPtrClear(sizeof(WorldArray)));				BlockMove(Ptr(tag^.winWorld^.theWorld), Ptr(tag^.copyWorld), sizeof(WorldArray));				tag^.origSelRect := tag^.selectionRect;			end;		fromRect := tag^.origSelRect;		tag^.selectionRect := dropRect;{copy portion of world}		World_CopyArea(tag^.copyWorld, tag^.winWorld^.theWorld, tag^.origSelRect, tag^.selectionRect);		tag^.drawOffscreen := true;{draw it}		DrawWorld(worldWind);	end;	function WorldEditHilites (worldWind: WindowPtr): Boolean;		var			tag: MRWinTag;	begin		tag := MRWinTag(GetWRefCon(worldWind));		WorldEditHilites := tag^.haveSelection;	end;	procedure RenameLevel (resID: integer;									newName: Str255);		var			h: Handle;			oldRes: integer;	begin		oldRes := CurResFile;		UseResFile(gListRes);		h := Get1Resource(kLevelResType, resID);		SetResInfo(h, resID, newName);		ChangedResource(h);		UpdateResFile(gListRes);		UseResFile(oldRes);	end;{quark.h = 0, quark.v = 2}{scis.h = 1-4, v = 2}{info.h = 9, v = 1}	function QuarkCount (lev: WorldArrayPtr): integer;		var			x, y: integer;			c: integer;	begin		c := 0;		for x := 1 to kMaxWorldSize do			for y := 1 to kMaxWorldSize do				if (lev^[x, y].p.h = 0) and (lev^[x, y].p.v = 2) then					c := c + 1;		QuarkCount := c;	end;	function InfoCount (lev: WorldArrayPtr): integer;		var			x, y: integer;			c: integer;	begin		c := 0;		for x := 1 to kMaxWorldSize do			for y := 1 to kMaxWorldSize do				if (lev^[x, y].p.h = 9) and (lev^[x, y].p.v = 1) then					c := c + 1;		InfoCount := c;	end;	procedure WorldMapInfo (worldWind: WindowPtr);		var			mapDlog: dialogPtr;			itemHit: integer;			a: rect;			b: integer;			item: Handle;			whichML: integer;			infoNum: integer;			oldName, newName: str255;			oldInfos, newInfos: integer;			tempNewInfos: str255;			oldInfo, newInfo: Str255;			tag: MRWinTag;			chosenWorld: integer;			hoursVal, minsVal, secsVal: integer;			tempText: Str255;	begin		tag := MRWinTag(GetWRefCon(worldWind));		mapDlog := GetNewDialog(130, nil, WindowPtr(-1));		SetPort(mapDlog);		chosenWorld := tag^.levelWorld;		GetDialogItem(mapDlog, 3, b, item, a);		SetDialogItemText(item, tag^.winTitle);		oldName := tag^.winTitle;		GetDialogItem(mapDlog, 4, b, item, a);		infoNum := tag^.reqInfo;		oldInfos := infoNum;		if (infoNum < 1) then			infoNum := QuarkCount(tag^.winWorld^.theWorld) * 9 + InfoCount(tag^.winWorld^.theWorld);		SetDialogItemText(item, stringof(infoNum : 1));		GetDialogItem(mapDlog, 5, b, item, a);		SetDialogItemText(item, tag^.levelInfo);		oldInfo := tag^.levelInfo;		GetDialogItem(mapDlog, 6 + tag^.levelWorld, b, item, a);		SetControlValue(ControlHandle(item), 1);{handle time limit}		if (tag^.usesExtendedData) then			begin				GetDialogItem(mapDlog, 17, b, item, a);				SetDialogItemText(item, stringof(tag^.hours : 1));				GetDialogItem(mapDlog, 18, b, item, a);				SetDialogItemText(item, stringof(tag^.mins : 1));				GetDialogItem(mapDlog, 19, b, item, a);				SetDialogItemText(item, stringof(tag^.secs : 1));			end		else			begin				GetDialogItem(mapDlog, 17, b, item, a);				SetDialogItemText(item, '0');				GetDialogItem(mapDlog, 18, b, item, a);				SetDialogItemText(item, '0');				GetDialogItem(mapDlog, 19, b, item, a);				SetDialogItemText(item, '0');			end;		ParamText(stringof(InfoCount(tag^.winWorld^.theWorld) : 1), stringof(QuarkCount(tag^.winWorld^.theWorld) : 1), stringof((QuarkCount(tag^.winWorld^.theWorld) * 9) + InfoCount(tag^.winWorld^.theWorld) : 1), '');		ShowWindow(mapDlog);		repeat			ModalDialog(nil, ItemHit);			if (itemHit >= 6) and (itemHit <= 9) then				begin					chosenWorld := itemHit - 6;					GetDialogItem(mapDlog, 6, b, item, a);					SetControlValue(ControlHandle(item), 0);					GetDialogItem(mapDlog, 7, b, item, a);					SetControlValue(ControlHandle(item), 0);					GetDialogItem(mapDlog, 8, b, item, a);					SetControlValue(ControlHandle(item), 0);					GetDialogItem(mapDlog, 9, b, item, a);					SetControlValue(ControlHandle(item), 0);					GetDialogItem(mapDlog, itemHit, b, item, a);					SetControlValue(ControlHandle(item), 1);				end;		until (itemHit > 0) and (itemHit < 3);		if (itemHit = 1) then			begin				GetDialogItem(mapDlog, 3, b, item, a);				GetDialogItemText(item, newName);				GetDialogItem(mapDlog, 4, b, item, a);				GetDialogItemText(item, tempNewInfos);				GetDialogItem(mapDlog, 5, b, item, a);				GetDialogItemText(item, newInfo);				newInfos := Q_StrToInt(tempNewInfos);				if (newInfos > QuarkCount(tag^.winWorld^.theWorld) * 9 + InfoCount(tag^.winWorld^.theWorld)) then					begin						SysBeep(10);						SysBeep(10);						newInfos := QuarkCount(tag^.winWorld^.theWorld) * 9 + InfoCount(tag^.winWorld^.theWorld);					end;				if (newInfos <> oldInfos) then					tag^.reqInfo := newInfos;				if (oldInfo <> newInfo) then					tag^.levelInfo := newInfo;				if (oldName <> newName) then					begin						tag^.winTitle := newName;						SetWTitle(worldWind, tag^.winTitle);						RenameLevel(tag^.resID, newName);					end;{total time}				GetDialogItem(mapDlog, 17, b, item, a);				GetDialogItemText(item, tempText);				hoursVal := Q_StrToInt(tempText);				GetDialogItem(mapDlog, 18, b, item, a);				GetDialogItemText(item, tempText);				minsVal := Q_StrToInt(tempText);				GetDialogItem(mapDlog, 19, b, item, a);				GetDialogItemText(item, tempText);				secsVal := Q_StrToInt(tempText);				if ((hoursVal > 0) or (minsVal > 0) or (secsVal > 0)) then					begin						tag^.usesExtendedData := true;						tag^.hours := hoursVal;						tag^.mins := minsVal;						tag^.secs := secsVal;					end				else					begin						tag^.usesExtendedData := false;					end;				tag^.levelWorld := chosenWorld;				World_DrawPicInOff(132 + tag^.levelWorld, tag^.pathOff);				tag^.drawOffscreen := true;				DrawWorld(worldWind);			end;		DisposeDialog(mapDlog);	end;	function GetOpenLevel (worldWind: WindowPtr): integer;		var			tag: MRWinTag;	begin		tag := MRWinTag(GetWRefCon(worldWind));		GetOpenLevel := tag^.openLevel;		tag^.openLevel := 0;	end;{ The following code is for importing old MR levels }	function NewBoardDataStructure: oldboardds;		var			qd: oldboardds;			x, y: integer;	begin		qd := oldboardds(NewHandleClear(sizeOf(LevelRecord)));		if (qd <> nil) and (memError = noErr) then			begin				MoveHHi(handle(qd));				HLock(handle(qd));				qd^^.sizeX := 120;				qd^^.sizeY := 120;				for x := 1 to qd^^.sizeX do					for y := 1 to qd^^.sizeY do{$PUSH}{$R-}						qd^^.theBoard[x, y] := kBaseNum;{$POP}			end;		NewBoardDataStructure := qd;	end;	function DecompressBoard (c: bcp;									var b: oldboardds): boolean;				{FALSE if it failed}		var			atx, aty, atbn: integer;			q: integer;			lastVal: integer;			cnt: integer;	begin		b := NewBoardDataStructure;		b^^.name := c^^.name;		b^^.sizeX := c^^.sizeX;		b^^.sizeY := c^^.sizeY;		b^^.murphy := c^^.murphy;		b^^.term := c^^.term;		b^^.numScissors := c^^.numScissors;		b^^.numQuarks := c^^.numQuarks;		b^^.numInfotrons := c^^.numInfotrons;		b^^.numBugs := c^^.numBugs;		atx := 1;		aty := 1;		atbn := 0;{$PUSH}{$R-}		for cnt := 1 to c^^.numScissors do			begin				b^^.scissors[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;		for cnt := 1 to c^^.numQuarks do			begin				b^^.quarks[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;		for cnt := 1 to c^^.numBugs do			begin				b^^.bugs[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;{$R+}		lastVal := 128;		while (atbn < c^^.numComp) do			begin				atbn := atbn + 1;{$PUSH}{$R-}				if c^^.theBoard[atbn] < 0 then					begin						for q := 1 to (-c^^.theBoard[atbn] - 1) do{$R+}							begin								b^^.theBoard[atx, aty] := lastVal;								atx := atx + 1;								if atx > c^^.sizeX then									begin										aty := aty + 1;										atx := 1;									end;							end;					end				else					begin{$PUSH}{$R-}						b^^.theBoard[atx, aty] := c^^.theBoard[atbn];						lastVal := c^^.theBoard[atbn];{$R+}						atx := atx + 1;						if atx > c^^.sizeX then							begin								aty := aty + 1;								atx := 1;							end;					end;			end;		DecompressBoard := TRUE;		{it WILL work, darn it!}	end;	function LoadCompBoard (name: str255;									var compData: bcp): boolean;		var			i: Handle;			com: bcp;			err: OSErr;			worked: boolean;			oldRes: integer;	begin{    KillData;}		i := GetNamedResource(oldLevelResType, name);		worked := (i <> nil) and (ResError = noErr);		if worked then			begin				DetachResource(i);				com := bcp(i);				MoveHHi(handle(com));				HLock(handle(com));				compData := com;			end;		LoadCompBoard := worked;	end;	function loadBoard (name: str255;									var theBoard: oldboardds): boolean;		var			worked: boolean;			someData: oldboardds;			dorky: rect;			e: boolean;			c: integer;			tempComp: bcp;	begin		worked := LoadCompBoard(name, tempComp);		if worked then			begin				worked := DecompressBoard(tempComp, someData);				HUnlock(handle(tempComp));				DisposeHandle(handle(tempComp));				MoveHHi(handle(someData));				HLock(handle(someData));				theBoard := someData;			end;		LoadBoard := worked;	end;{$S Main}	procedure TransPoint (o: integer;									var p: Point);	begin		p.h := 0;		p.v := 0;		if (o = 129) then			begin				p.h := 1;				p.v := 0;			end		else if (o = 130) then			begin				p.h := 2;				p.v := 0;			end		else if (o = 131) then			begin				p.h := 5;				p.v := 2;			end		else if (o = 132) then			begin				p.h := 6;				p.v := 1;			end		else if (o = 133) then			begin				p.h := 3;				p.v := 0;			end		else if (o = 134) then			begin				p.h := 4;				p.v := 0;			end		else if (o = 135) then			begin				p.h := 5;				p.v := 0;			end		else if (o = 136) then			begin				p.h := 7;				p.v := 0;			end		else if (o = 138) then			begin				p.h := 6;				p.v := 0;			end		else if (o = 146) then			begin				p.h := 9;				p.v := 0;			end		else if ((o >= 300) and (o <= 305)) then			begin				p.h := 8;				p.v := 0;			end		else if ((o = 350) or (o = 850)) then			begin				p.h := 9;				p.v := 1;			end		else if (o = 650) then			begin				p.h := 0;				p.v := 2;			end		else if (o = 700) then			begin				p.h := 7;				p.v := 1;			end		else if (o = 710) then			begin				p.h := 8;				p.v := 1;			end		else if ((o >= 750) and (o <= 774)) then			begin				p.h := 9;				p.v := 3;				if (o > 750) then					begin						p.v := p.v + ((o - 751) div 10) + 1;						p.h := ((o - 751) mod 10);					end;			end		else if (o = 900) then			begin				p.h := 1;				p.v := 1;			end		else if (o = 902) then			begin				p.h := 0;				p.v := 1;			end		else if (o = 904) then			begin				p.h := 3;				p.v := 1;			end		else if (o = 906) then			begin				p.h := 2;				p.v := 1;			end		else if (o = 950) then			begin				p.h := 5;				p.v := 1;			end		else if (o = 952) then			begin				p.h := 4;				p.v := 1;			end		else if (o = 1000) then			begin				p.h := 1;				p.v := 2;			end		else if (o = 1002) then			begin				p.h := 2;				p.v := 2;			end		else if (o = 1004) then			begin				p.h := 3;				p.v := 2;			end		else if (o = 1006) then			begin				p.h := 4;				p.v := 2;			end		else if (o = 1100) then			begin				p.h := 6;				p.v := 2;			end		else if (o = 1102) then			begin				p.h := 9;				p.v := 2;			end		else if (o = 1104) then			begin				p.h := 7;				p.v := 2;			end		else if (o = 1106) then			begin				p.h := 8;				p.v := 2;			end;	end;	procedure ImportBoard (wind: WindowPtr);		var			tag: MRWinTag;			theBoard: oldboardds;			x, y: integer;			r: Point;			winTitle: Str255;	begin		tag := MRWinTag(GetWRefCon(wind));		GetWTitle(wind, winTitle);		SysBeep(5);		if LoadBoard(winTitle, theBoard) then			begin				for x := 1 to 120 do					for y := 1 to 120 do						TransPoint(theBoard^^.theBoard[x, y], tag^.winWorld^.theWorld^[x, y].p);				DisposeHandle(Handle(theBoard));				tag^.drawOffscreen := true;				DrawWorld(wind);			end		else			SysBeep(5);	end;end.
unit ColorOffScreen;{this is the revised color offscreen unit. Updated 6/4/94. Thanx to Brooke for discovering a bug,}{and to apprentice for fixing it!}{6/4: serious memory-leak/computer-crash problem fixed}{		routines renamed to make some damn sense!}{		got rid of COTBRand, since it seemed useless.}interface	uses		QDOffscreen;{MakeGWorld - call this to create an 8-bit GWorld the size of rect 'r'}	function MakeGWorld (r: rect): GWorldPtr;{MakeGWorldDepth - call this to create an n-bit GWorld the size of rect 'r'}	function MakeGWorldDepth (r: rect; n: integer): GWorldPtr;{DestroyGWorld - Call this when you are done using your GWorldPtr}	procedure DestroyGWorld (var o: GWorldPtr);{CopyWorldBits - This will copy data from the given GWorld directly to the given window.}{The rect 'r' is the place that the data from the world should be positioned in the window.}{Note: the ENTIRE world is copied in this routine.}	procedure CopyWorldBits (world: GWorldPtr; window: WindowPtr; r: rect);{CopyWorldBits2 - This will copy data from the given GWorld directly to the given window.}{The rect 'r1' is the rect, in the offscreen's coordinates, of what to copy}{The rect 'r2' is the rect, in window coordinates, of where the copy should be placed.}{Note: this is useful for copying small portions of the offscreen world onto your window.}	procedure CopyWorldBits2 (world: GWorldPtr; window: WindowPtr; r1, r2: rect);{CopyBitMapToOffscreen - if you have a bit map (such as screenBits) that you want to}{copy, here's what you use. The entire bitmap will be copied, but you can specify the}{destination rectangle of the copied image in GWorld coordinates, using 'r'}	procedure CopyBitMapToOffscreen (biting: BitMap; world: GWorldPtr; r: rect);{CopyOffscreenToBitMap - the reverse of CopyBitMapToOffscreen, this one will copy}{from your gworld to a bit map (such as screenBits).}{Note: 'r' is the rectangle of your SOURCE image, and not the destination.}{		The entire bitmap will be filled using this routine.}	procedure CopyOffscreenToBitMap (world: GWorldPtr; biting: BitMap; r: rect);implementation	function MakeGWorld (r: rect): GWorldPtr;		var			oldGD: GDHandle;			oldGW, newWorld: GWorldPtr;			err: QDErr;			pt: GrafPtr;	begin		GetPort(pt);		GetGWorld(oldGW, oldGD);		err := NewGWorld(newWorld, 8, r, nil, oldGD, []);		if err <> noErr then			ExitToShell;		makegworld := newWorld;	end;	function MakeGWorldDepth (r: rect; n: integer): GWorldPtr;		var			oldGD: GDHandle;			oldGW, newWorld: GWorldPtr;			err: QDErr;			pt: GrafPtr;	begin		GetPort(pt);		GetGWorld(oldGW, oldGD);		err := NewGWorld(newWorld, n, r, nil, oldGD, []);		if err <> noErr then			ExitToShell;		MakeGWorldDepth := newWorld;	end;	procedure DestroyGWorld (var o: GWorldPtr);{memory leak/bug fixed: 6/4/94}	begin		UnlockPixels(o^.portPixMap);		DisposeGWorld(o);	end;	procedure CopyWorldBits (world: GWorldPtr; window: WindowPtr; r: rect);		var			clr: RGBColor;			m: Boolean;	begin		m := LockPixels(world^.portPixMap);		CopyBits(GrafPtr(world)^.portBits, GrafPtr(window)^.portBits, world^.portRect, r, srcCopy, nil);		UnlockPixels(world^.portPixMap);	end;	procedure CopyWorldBits2 (world: GWorldPtr; window: WindowPtr; r1, r2: rect);		var			clr: RGBColor;			m: Boolean;	begin		m := LockPixels(world^.portPixMap);		CopyBits(GrafPtr(world)^.portBits, GrafPtr(window)^.portBits, r1, r2, srcCopy, nil);		UnlockPixels(world^.portPixMap);	end;	procedure CopyBitMapToOffscreen (biting: BitMap; world: GWorldPtr; r: rect);		var			clr: RGBColor;			m: Boolean;	begin		m := LockPixels(world^.portPixMap);		CopyBits(biting, GrafPtr(world)^.portBits, biting.bounds, r, srcCopy, nil);		UnlockPixels(world^.portPixMap);	end;	procedure CopyOffscreenToBitMap (world: GWorldPtr; biting: BitMap; r: rect);		var			clr: RGBColor;			m: Boolean;	begin		m := LockPixels(world^.portPixMap);		CopyBits(GrafPtr(world)^.portBits, biting, r, biting.bounds, srcCopy, nil);		UnlockPixels(world^.portPixMap);	end;end.
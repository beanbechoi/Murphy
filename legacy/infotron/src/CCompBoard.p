unit CCompBoard;interface	uses		BoardsIntf;implementation	function CCompBoard.LoadBoard (name: Str255): boolean;								{FALSE if it failed}		var			i: Handle;			com: bcp;			err: OSErr;			worked: boolean;	begin{    KillData;}		i := GetNamedResource(levelResType, name);		worked := (i <> nil) and (ResError = noErr);		if worked then			begin				com := bcp(i);				DetachResource(i);				MoveHHi(handle(com));				HLock(handle(com));				compData := com;			end;		LoadBoard := worked;	end;	function NewBoardDataStructure: bap;		var			qd: bap;			x, y: integer;	begin		qd := bap(NewHandleClear(sizeOf(LevelRecord)));		MoveHHi(handle(qd));		HLock(handle(qd));		qd^^.sizeX := 120;		qd^^.sizeY := 120;		for x := 1 to qd^^.sizeX do			for y := 1 to qd^^.sizeY do{$PUSH}{$R-}				qd^^.theBoard[x, y] := kBaseNum;{$POP}		NewBoardDataStructure := qd;	end;	function CCompBoard.DecompressBoard (var b: bap): boolean;				{FALSE if it failed}		var			atx, aty, atbn: integer;			q: integer;			lastVal: integer;			cnt: integer;			c: bcp;	begin		b := NewBoardDataStructure;		c := compData;		b^^.name := c^^.name;		b^^.sizeX := c^^.sizeX;		b^^.sizeY := c^^.sizeY;		b^^.murphy := c^^.murphy;		b^^.term := c^^.term;		b^^.numScissors := c^^.numScissors;		b^^.numQuarks := c^^.numQuarks;		b^^.numInfotrons := c^^.numInfotrons;		b^^.numBugs := c^^.numBugs;		atx := 1;		aty := 1;		atbn := 0;{$PUSH}{$R-}		for cnt := 1 to c^^.numScissors do			begin				b^^.scissors[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;		for cnt := 1 to c^^.numQuarks do			begin				b^^.quarks[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;		for cnt := 1 to c^^.numBugs do			begin				b^^.bugs[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;{$R+}		lastVal := 128;		while (atbn < c^^.numComp) do			begin				atbn := atbn + 1;{$PUSH}{$R-}				if c^^.theBoard[atbn] < 0 then					for q := 1 to (-c^^.theBoard[atbn] - 1) do{$R+}						begin							b^^.theBoard[atx, aty] := lastVal;							atx := atx + 1;							if atx > c^^.sizeX then								begin									aty := aty + 1;									atx := 1;								end;						end				else					begin{$PUSH}{$R-}						b^^.theBoard[atx, aty] := c^^.theBoard[atbn];						lastVal := c^^.theBoard[atbn];{$R+}						atx := atx + 1;						if atx > c^^.sizeX then							begin								aty := aty + 1;								atx := 1;							end;					end;			end;		DecompressBoard := TRUE;		{it WILL work, darn it!}	end;	procedure CCompBoard.KillData;	begin		if compData <> nil then			begin				HUnlock(handle(compData));				DisposeHandle(handle(compData));			end;	end;	procedure CCompBoard.Free;	begin		KillData;		inherited Free;	end;end.
type	gridPieceArray: array[1..20] of CGridPiece;const	grPortal = 1;	grExit = 2;	grBug = 3;	grTerminal = 4;	grBlank = 5;	grCircut = 6;	grChip = 7;	grHardware = 8;	grScissor = 9;	grQuark = 10;	grRed = 11;	grYellow = 12;	grGreen = 13;	grZonk = 14;	grInfotron = 15;	grMurphyObj = 16;var	gos: GridPieceArray;			{the grid pieces}function CInfoApp.LocFromDir (x, y, d: integer): point;	var		mtx, mty: integer;begin	case d of		kNoMove: 			begin				mtx := x;				mty := y;			end;		kUp: 			begin				mtx := x;				mty := y - 1;			end;		kRight: 			begin				mtx := x + 1;				mty := y;			end;		kDown: 			begin				mtx := x;				mty := y + 1;			end;		kLeft: 			begin				mtx := x - 1;				mty := y;			end;		kUpRight: 			begin				mtx := x + 1;				mty := y - 1;			end;		kUpLeft: 			begin				mtx := x - 1;				mty := y - 1;			end;		kDownRight: 			begin				mtx := x + 1;				mty := y + 1;			end;		kDownLeft: 			begin				mtx := x - 1;				mty := y + 1;			end;	end;	LocFromDir.h := mtx;	LocFromDir.v := mty;end;procedure CInfoApp.MakeGObjs;	var		c: integer;begin	New(CPortal(gos[1]));	New(CExit(gos[2]));	New(CBug(gos[3]));	New(CTerminal(gos[4]));	New(CBlank(gos[5]));	New(CCircut(gos[6]));	New(CChip(gos[7]));	New(CHardware(gos[8]));	New(CScissor(gos[9]));	New(CQuark(gos[10]));	New(CRedDisk(gos[11]));	New(CYellowDisk(gos[12]));	New(CGreenDisk(gos[13]));	New(CZonk(gos[14]));	New(CInfotron(gos[15]));	New(CMurphyObj(gos[16]));	for c := 1 to 16 do		gos[c].InitPiece;end;function CInfoApp.GetGridObj (x, y: integer): CGridPiece;	var		what: integer;		mo: CGridPiece;begin	what := self.GetGPane.GetBoard.GetData(x, y);	mo := gos[grBlank];	if what = 128 then		mo := gos[grCircut]	else if what = 129 then		mo := gos[grBlank]	else if (what >= 850) and (what <= 853) then		mo := gos[grInfotron]	else if (what >= 700) and (what <= 707) then		mo := gos[grZonk]	else if (what = 131) or ((what >= 1100) and (what <= 1106)) then		mo := gos[grChip]	else if ((what >= 750) and (what <= 757)) or ((what >= 1050) and (what <= 1057)) then		mo := gos[grHardware]	else if (what >= 1000) and (what <= 1007) then		mo := gos[grScissor]	else if (what >= 650) and (what <= 657) then		mo := gos[grQuark]	else if (what >= 300) and (What <= 304) then		mo := gos[grBug]	else if (what = 132) or ((what >= 900) and (what <= 952)) then		mo := gos[grPortal]	else if what = 133 then		mo := gos[grGreen]	else if what = 135 then		mo := gos[grRed]	else if what = 134 then		mo := gos[grYellow]	else if (what >= 550) and (what <= 561) then		mo := gos[grTerminal]	else if what = 130 then		mo := gos[grExit]	else if ((what >= 499) and (what <= 511)) or ((what >= 139) and (what <= 214)) or ((what >= 1200) and (what <= 1210)) then		mo := gos[grMurphyObj];	GetGridObj := mo;end;procedure CInfoApp.KillChores;	var		myObj: CObject;begin	for count := itsIdleChores.getNumItems downto 1 do		begin			myObj := itsIdleChores.nthItems(count);			itsIdleChores.remove(myObj);			myObj.free;		end;end;
unit DataIntf;{NO OOP}interface	uses		ObjIntf, QDOffscreen, sound, gammapasLibIntf, {}		coloroffscreen, myRGBColors, CInfoDialog, ColorOffScreen, {}		QIST, menubars, QuickDrawProcs, InfoWindows;	const{sound hearing ranges}		kBugRange = 4;		kExplRange = 22;		kThudRange = 20;		kResourceID = 129;		kBaseNum = 128;{directions}		kNoMove = 8;		kUp = 0;		kUpRight = 1;		kRight = 2;		kDownRight = 3;		kDown = 4;		kDownLeft = 5;		kLeft = 6;		kUpLeft = 7;		kInfoChore = 1;		kAnimChore = 2;		kContMoveChore = 3;		kFallChore = 4;		kSuicideChore = 5;		kWaitInsChore = 6;		kContAnimChore = 7;		kExplChore = 8;		kFallExplChore = 9;		kMoveReplyChore = 10;		kMoveChore = 11;		kKillGameChore = 12;		kWaitTimeChore = 13;		kRollAfterChore = 14;		sGotInfotron = 128;		{the sounds}		sThud = 129;		sOHit = 130;		sExplode = 131;		sQuarkExp = 132;		sGotRedDisk = 133;		sRedDiskReady = 134;		sGotLastInfo = 135;		sAboutBox = 136;		sMurphyDied = 137;		sPause = 138;		sUnpause = 139;		sBugZap = 140;		kBackgroundWidth = 20;		kBackgroundHeight = 20;		KWindowProcID = 2;{file menu commands}		iCmdReg = 2;		iCmdNew = 1;		iCmdOpen = 2;		iCmdRename = 3;		iCmdDelete = 4;		iCmdQuit = 1;{game menu commands}		iCmdLevel = 4;		iCmdKeys = 5;		iCmdStart = 1;		iCmdPause = 2;		iCmdSoundFX = 7;		iCmdSoundEffects = iCmdSoundFX;		iCmdMusic = 8;		iCmdHelp = 10;		grPortal = 1;		grExit = 2;		grBug = 3;		grTerminal = 4;		grBlank = 5;		grCircut = 6;		grChip = 7;		grHardware = 8;		grScissor = 9;		grQuark = 10;		grRed = 11;		grYellow = 12;		grGreen = 13;		grZonk = 14;		grInfotron = 15;		grMurphyObj = 16;		kMaxThings = 110;		kCurrentDir = -42;		maxList = 1000;	type		AnimArray = array[1..20] of integer;		MovingThingy = (murphy, scissor, quark, boulder, infotron);		somethingRec = record				dumInt1: integer;				dumFloat2: real;				ignoreS1: str255;				ignoreS2: str255;				theS: str255;				moreDum: integer;			end;		stPtr = ^somethingRec;		stHand = ^stPtr;		f10a = array[1..10] of str255;		infoState = (hasPlayer, hasLevel, isPlaying, isPaused, hasMusic, hasSound, fadeFromB, freezeMurphy);		infoStatus = set of infoState;		boardArray = array[1..150, 1..150] of integer;		ThingArray = array[1..kMaxThings] of integer;		twoZeroArray = array[1..120, 1..120] of integer;		oneZeroArray = array[0..0] of integer;		MovingThing = record				x, y, dir: integer;			end;		MovingArray = array[1..kMaxThings] of MovingThing;		bcp = ^bcpp;		bcpp = ^CompressedBoard;		CompressedBoard = record				name: str255;				sizeX, sizeY: integer;									{How far right and down does the level extend?}				murphy, term: integer;											{where does murphy start}				numScissors: integer;				numQuarks: integer;				numInfotrons: integer;				numBugs: integer;				numComp: integer;			{how many run-length compression thingys did we use up?}				theBoard: oneZeroArray;			end;		bap = ^bapp;		bapp = ^LevelRecord;		LevelRecord = record				name: str255;				sizeX, sizeY: integer;									{How far right and down does the level extend?}				murphy, term: integer;											{where does murphy start}				numScissors: integer;				numQuarks: integer;				numInfotrons: integer;				numBugs: integer;				scissors, quarks, bugs: ThingArray;				theBoard: twoZeroArray;			end;		CChore = object(CObject)				ListIndex: integer;				procedure Perform (var maxSleep: Longint);			end;		ListType = array[1..maxList] of CChore;		BigArr = array[1..120, 1..120] of boolean;		BigMomma = ^BigArr;		MurphyType = record				x, y: integer;				lastMove: longint;				startTime: longint;				totTime: longint;				lastDir: integer;				numBombs: integer;				numInfos: integer;			end;		CGridPiece = object(CObject)				destructable: boolean;				rounded: boolean;				explodes: boolean;				falls: boolean;				moves: boolean;				explAnim: AnimArray;				procedure InitPiece;			{Call this after creating the CGridPiece}				function IsDestructable: boolean;				function IsRounded: boolean;				function CanExplode: boolean;				function CanFall: boolean;				function CanMove: boolean;				procedure Destroy (x, y: integer);				procedure Explode (x, y: integer);				function WalkOnto (x, y: integer): boolean;  {TRUE if murphy could come here}				procedure Fall (x, y: integer);			{Don't call this; call CheckFall instead}				procedure Roll (x, y, dir: integer);		{Don't call this; call CheckRoll instead}				procedure Move (x, y: integer);				function Push (x, y: integer): boolean;	{WalkOnto might call this, but you shouldn't. TRUE if can be pushed.}				procedure CheckFall (x, y: integer);				function CheckRoll (x, y, dir: integer): boolean;			end;		gridPieceArray = array[1..20] of CGridPiece;		CBlank = object(CGridPiece)				procedure InitPiece;				override;			end;		CExplodes = object(CGridPiece)				procedure InitPiece;				override;				procedure Explode (x, y: integer);				override;				function WalkOnto (x, y: integer): boolean;				Override;			end;		CMurphyObj = object(CExplodes)	{To handle murphy's death}				procedure Destroy (x, y: integer);				override;				procedure Explode (x, y: integer);				override;				procedure KillMurphy;				procedure CMurphyObj.ExplodeTWO (x, y: integer);			end;		CGreenDisk = object(CExplodes)				procedure InitPiece;				override;				procedure Fall (x, y: integer);				override;				function WalkOnto (x, y: integer): boolean;				override;				function Push (x, y: integer): boolean;				override;			end;		CYellowDisk = object(CExplodes)				function WalkOnto (x, y: integer): boolean;				override;				function Push (x, y: integer): boolean;				override;				procedure CYellowDisk.InitPiece;				override;			end;		CCircut = object(CGridPIece)				procedure InitPiece;				override;			end;		CRedDisk = object(CExplodes)				procedure InitPiece;				override;				function WalkOnto (x, y: integer): boolean;				override;			end;		CMoves = object(CExplodes)				IAmA: MovingThingy;				facing: integer;				function WalkOnto (x, y: integer): boolean;				override;			{Must Start an explosion}				procedure CMoves.Move (x, y: integer);				override;				procedure InitPiece;				override;				procedure FigureFacing (x, y: integer);				procedure CMoves.DoMove (oldx, oldy, newx, newy, olddir, newdir: integer);			end;		CScissor = object(CMoves)				procedure InitPiece;				override;			end;		CQuark = object(CMoves)				qExplAnim: AnimArray;				procedure InitPiece;				override;				procedure Explode (x, y: integer);				override;			end;		CBug = object(CGridPiece)				bugAnim: AnimArray;				procedure InitPiece;				override;				procedure Make (x, y: integer);				function WalkOnto (x, y: integer): boolean;				override;			end;		CExit = object(CGridPiece)				procedure InitPiece;				override;				function WalkOnto (x, y: integer): boolean;				override;			end;		CPortal = object(CGridPiece)				function WalkOnto (x, y: integer): boolean;				override;				procedure InitPiece;				override;			end;		CTerminal = object(CGridPiece)				termAnim: AnimArray;				procedure Make (x, y: integer);				procedure InitPiece;				override;				function WalkOnto (x, y: integer): boolean;				override;			end;		CHardware = object(CGridPiece)				function WalkOnto (x, y: integer): boolean;				override;			end;		CChip = object(CGridPiece)				procedure InitPiece;				override;				function CChip.WalkOnto (x, y: integer): boolean;				override;			end;		CFalls = object(CGridPiece)				procedure InitPiece;				override;		{must fall}				procedure Fall (x, y: integer);				override;			end;		CZonk = object(CFalls)				procedure InitPiece;				override;				procedure Roll (x, y, dir: integer);				override;				function WalkOnto (x, y: integer): boolean;				override;				function Push (x, y: integer): boolean;	{WalkOnto might call this, but you shouldn't. TRUE if can be pushed.}				override;			end;		CInfotron = object(CFalls)				procedure InitPiece;				override;				procedure Roll (x, y, dir: integer);				override;				function WalkOnto (x, y: integer): boolean;				override;			end;		CInfoChore = object(CChore)		{Abstract class!}				xq, yq: integer;				myIdent: integer;				myCode: integer;				procedure CInfoChore.GetChoreLoc (var cx, cy: integer);				function CInfoChore.Identify: integer;				procedure CInfoChore.FreeMemory;		{do nothing here; other objects might want to free themselves??}				function CInfoChore.ShouldRemove: boolean;				procedure IInfoChore (xe, ye: integer);				procedure CInfoChore.Remove;				procedure Free;				override;			end;		CFallChore = object(CInfoChore)				ix, iy: integer;				procedure IFallChore (x, y: integer);				procedure DoOneFall;				procedure HitBottom;				procedure Perform (var maxSleep: longint);				override;			end;		CFallRollChore = object(CInfoChore)				ix, iy: integer;				myDir: integer;				procedure IFallChore (x, y: integer; theDir: integer);				procedure DoOneFall;				procedure HitBottom;				procedure Perform (var maxSleep: longint);				override;			end;		CWaitInsChore = object(CInfoChore)				toBeInstalled: CChore;				countDown: integer;				HaveInstalled: BOOLEAN;				procedure CWaitInsChore.FreeMemory;				override;				procedure Perform (var maxSleep: longint);				override;				procedure IWaitInsChore (someChore: CChore; theCount: integer);			end;		CWaitTimeChore = object(CWaitInsChore)				installedWhen: longint;				procedure IWaitTimeChore (someChore: CChore; numSecs: integer);				procedure Perform (var maxSleep: longint);				override;			end;		CKillGameChore = object(CInfoChore)				procedure IKillGameChore;				procedure Perform (var maxSleep: longint);				override;			end;		CFallExplChore = object(CFallChore)				procedure IFallExplChore (x, y: integer);				procedure HitBottom;				override;			end;		CAnimChore = object(CInfoChore)				animSequence: AnimArray;				animAt: integer;				finalAnim: integer;			{after everything is done}				delayBetween: longint;		{minimum delay between FRAMES}				lastTime: longint;				procedure DrawAt;				procedure IAnimChore (as: AnimArray; fa: integer; db: longint; x, y: integer);				procedure DoOneFrame;				procedure CAnimChore.SequenceDone;				procedure CAnimChore.FrameDone;				procedure Perform (var maxSleep: longint);				override;			end;		CExplChore = object(CAnimChore)			{this handles chain reaction explosions.}				procedure IExplChore (x, y: integer; aas: AnimArray; fa: integer);				procedure FrameDone;				override;			end;		CContAnimChore = object(CAnimChore)				cycleDelay: longint;		{or else}				inCycle: boolean;				betweenStart: longint;				procedure IContAnimChore (cd: longint; as: AnimArray; fa: integer; db: longint; x, y: integer);				procedure SequenceDone;				override;				procedure Perform (var maxSleep: longint);				override;			end;		CMoveChore = object(CAnimChore)				direction, oldDir: integer;				numPixels: integer;				notSoAnim: AnimArray;				itIsA: MovingThingy;				moveThereAtFram: integer;				mtx, mty: integer;				procedure CMoveChore.SequenceDone;				override;				procedure MakeArray;				procedure FrameDone;				override;				procedure CMoveChore.IMoveChore (d: integer; oldD: integer; whatIsIt: MovingThingy; x, y: integer);				procedure Perform (var maxSleep: longint);				override;			end;		CQuarkMover = object(CInfoChore)				quaX, quaY: integer;				lastAnim: integer;				currentDir: integer;				shouldMove: boolean;				procedure IQuarkMover (quarkX, quarkY: integer);				procedure Perform (var maxSleep: longint);				override;			end;		CScissorMover = object(CInfoChore)				sciX, sciY: integer;				currentDir: integer;				lastAnim: integer;		{the last base animation frame; i.e. 0,2,4,6}				afterMed: integer;		{After being medium, add: 0 or 10}				currentSize: integer;	{can be 0,10,20 (small,large,medium)}				forceNextMove: boolean;				shouldMove: boolean;				goingValue: integer;				turnAround: boolean;				procedure IScissorMover (scissorX, scissorY: integer);				procedure Perform (var maxSleep: longint);				override;			end;		CRollAfterChore = object(CInfoChore)				uselessCount: integer;		{this is an absolutely useless counter.}				myDir: integer;				procedure IRollAfterChore (x, y: integer; theDir: integer);				procedure Perform (var maxSleep: Longint);				override;			end;		CSuicideChore = object(CInfoChore)				uselessCount: integer;		{this is an absolutely useless counter.}				procedure ISuicideChore (x, y: integer);				procedure Perform (var maxSleep: Longint);				override;			end;	const{phases of murphy}		kBig = 0;		kMed = 2;		kSml = 4;		kLft = 0;		kRt = 1;		kBase = 201;	var		gMainWind: WindowPtr;		gBackWind: WindowPtr;		gSuspended: boolean;		gMoveH, gMoveV: integer;		gPhase: integer;		{either kBig,kMed,or kSml}		gFromMed: integer;		gAARDVARK_PLATYPUSS_WOMBAT: boolean;		fallingInfo: BigMomma;		fallChores: BigMomma;		gUpKey: integer;		gDownKey: integer;		gLeftKey: integer;		gRightKey: integer;		gSpecKey: integer;		gMyResFile: integer;		registered: boolean;		regisName: str255;		pauseKeyState: boolean;		{TRUE if paused when capsLock is DOWN}{from the CInfoApp}		gos: GridPieceArray;			{the grid pieces}		gameState: infoStatus;		gRegDial, gAboutDial, gNewDial, gRenDial, gKeysDial, gHelpDial: CInfoDialog;		gLevelDial, gOpenDial, gDeleteDial: CInfoScrollDialog;		toBeAdded, toBeRidded: ListType;		infoUrgents: ListType;				{the urgent chores dealing with the game.}											{these need to be handled differently than the TCL chores which}											{are urgent ones.}		tbaLen, tbrLen, iuLen: integer;		nextRollDir: integer;		shouldKillChores: boolean;		musicID: integer;		repeatCnt: integer;		whatToBlank: integer;		spaceBarWasDown: boolean;		{TRUE if the space bar was down during the LAST cycle}		whenWentDown: longint;			{when the space bar went down}		diskDropSndPlayed: boolean;	{TRUE if the disk-ready-to-drop sound signal was played}		loadNextLevel: boolean;		lastWasPortal: BOOLEAN;		myOldKeys: KeyMap;		lastFacingLR: integer;		isSleeping: boolean;		lastMoved: longint;		sleepPhase: integer;		{the icon}		scratchLongint: longint;	{a scratch longint}		scratchInteger: integer;	{a scratch integer}		scratchBoolean: boolean;{a scratch boolean}{end from the cinfo app}		gPlayer: playerType;		boardData: bap;		boardBounds: point;		{not in pixels, rather it is in ICONS}		quarkData, scissorData: MovingArray;		lowerRight, upperLeft: point;		myOff: GWorldPtr;		offrect: rect;		firstTen: f10a;		ldHrs, ldMins, ldSecs: integer;		gMurphy: MurphyType;implementation	procedure CChore.Perform (var maxSleep: longint);	begin	end;										{ null Method						}end.
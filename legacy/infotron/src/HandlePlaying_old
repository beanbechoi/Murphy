{OLD VERSION OF START OF HANDLE PLAYING}for count := toBeRidded.GetNumItems downto 1 do	begin																{unfortunatly, you can't assign chores from within}		obppassdaw := CChore(toBeRidded.nthItem(count));		if obppassdaw <> nil then			begin				infoUrgents.Remove(obppassdaw);				toBeRidded.remove(obppassdaw);				if CInfoChore(obppassdaw).identify = kSuicideChore then					begin						CInfoChore(obppassdaw).GetChoreLoc(cx, cy);						hasSuicide[cx, cy] := FALSE;					end;				CInfoChore(obppassdaw).GetChoreLoc(cx, cy);				if numChores^[cx, cy] > 0 then					numChores^[cx, cy] := numChores^[cx, cy] - 1;				DisposHandle(Handle(obppassdaw));				obppassdaw := nil;			end;	end;																	{chores - a loophole in TCL. Thanks to our genius,}for count := toBeAdded.GetNumItems downto 1 do				{we were able to circumvent this problem.}	begin																	{Of course, we completly broke TCL style for it.}		obppassdaw := CChore(toBeAdded.nthItem(count));				{But hey, it was fun.}		if obppassdaw <> nil then										{...}			begin																{It was also at 3 o'clock during the night}				infoUrgents.add(obppassdaw);				toBeAdded.remove(obppassdaw);			end;	end;for count := 1 to infoUrgents.GetNumItems do	begin		obppassdaw := CChore(infoUrgents.nthItem(count));		if obppassdaw <> nil then			obppassdaw.Perform(dumbVar);	end;if infoUrgents.GetNumItems > 0 then	GetGPane.GetBPane.draw(UNINITIALIZED_SO_THERE);
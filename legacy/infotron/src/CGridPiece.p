unit CGridPiece;interface	uses		TCL, GridPieceIntf;implementation	function CGridPiece.CanMove: boolean;	begin		CanMove := moves;	end;	procedure CGridPiece.CheckFall (x, y: integer);		var			newWhere: point;	begin		if falls then			begin				newWhere := CInfoApp(gApplication).LocFromDir(x, y, kDown);				if CInfoApp(gApplication).GetGPane.GetBoard.GetData(newWhere.h, newWhere.v) = 129 then					self.Fall(x, y);			end;	end;	function CGridPiece.CheckRoll (x, y, dir: integer): boolean;		var			below, nextTo, nextDown, nextUp: point;			whatBelow: integer;	begin		below := CInfoApp(gApplication).LocFromDir(x, y, kDown);		whatBelow := CInfoApp(gapplication).GetGPane.GetBoard.GetData(x, y);		nextTo := CInfoApp(gApplication).LocFromDir(x, y, dir);		nextUp.v := y - 1;		nextUp.h := nextTo.h;		nextDown.h := nextTo.h;		nextDown.v := below.v;		CheckRoll := FALSE;{provided that I can't fall,}{can I roll off of it?}{is there room to roll to?}{is something falling next to me?}{nope, so go for it!}		if whatBelow <> 129 then			if CInfoApp(gApplication).GetGridObj(below.h, below.v).IsRounded then				if CInfoApp(gApplication).GetGPane.GetBoard.GetData(nextTo.h, nextTo.v) = 129 then					if CInfoApp(gApplication).GetGPane.GetBoard.GetData(nextDown.h, nextDown.v) = 129 then						if not CInfoApp(gapplication).GetGridObj(nextUp.h, nextUp.v).CanFall then							begin								CheckRoll := TRUE;								self.Roll(x, y, dir);							end;	end;	procedure CGridPiece.Roll (x, y, dir: integer);	begin	end;	function CGridPiece.Push (x, y: integer): boolean;		var			murGT, murCF: integer;			whereTo: point;			iAm: integer;			whatAt: integer;	begin		murGT := CInfoApp(gApplication).GetMurphy.GetLastDir;		murCF := 7 - murGT;		whereTo := CInfoApp(gApplication).LocFromDir(x, y, murGT);		whatAt := CInfoApp(gApplication).GetGPane.GetBoard.GetData(whereTo.h, whereTo.v);		iAm := CInfoApp(gApplication).GetGPane.GetBoard.GetData(x, y);		if whatAt = 129 then			begin				pUsH := true;				CInfoApp(gApplication).gEtGpAnE.gEtBoArD.sEtDaTa(x, y, 129);				CInfoApp(gApplication).GetGPane.GetBoard.SetData(whereTo.h, whereTo.v, iAm);				self.CheckFall(x, y);			end		else			Push := false;	end;	procedure CGridPiece.Move (x, y: integer; callingChore: CContMoveChore);	begin	end;	procedure CGridPiece.Destroy (x, y: integer);		var			myChore: CAnimChore;			aa: animArray;			xloc, yloc: integer;			count: integer;	begin		if destructable then			begin				New(myChore);				myChore.IAnimChore(explAnim, 11, 0, x, y);				CInfoApp(gapplication).FudADD(myChore);			end;	end;	procedure CGridPiece.Explode (x, y: integer);	begin	end;	function CGridPiece.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := TRUE;	end;	function CGridPiece.CanExplode: boolean;	begin		CanExplode := explodes;	end;	procedure CGridPiece.InitPiece;			{Call this after creating the CGridPiece}		var			c: integer;	begin							{Make sure you call this BEFORE initing yourself!}		destructable := false;		rounded := false;		falls := false;		explodes := false;		moves := false;		for c := 0 to 9 do			explAnim[c + 1] := 600 + c;		explAnim[11] := 129;	end;	function CGridPiece.IsDestructable: boolean;	begin		IsDestructable := destructable;	end;	procedure CGridPiece.Fall (x, y: integer);	begin	end;	function CGridPiece.IsRounded: boolean;	begin		IsRounded := rounded;	end;	function CGridPiece.CanFall: boolean;	begin		CanFall := falls;	end;end.
unit CMoveChore;interface	uses		TCL, BackChoresIntf;implementation	procedure CMoveChore.MakeArray;		procedure MakeMurMove;		begin			case direction of				kUp, kRight: 					begin						animSequence[1] := 205;						animSequence[2] := 203;						animSequence[3] := 201;						animSequence[4] := 203;						animSequence[5] := 205;						finalAnim := 5;						moveThereAtFram := 3;					end;				kDown, kLeft: 					begin						animSequence[1] := 206;						animSequence[2] := 204;						animSequence[3] := 202;						animSequence[4] := 204;						animSequence[5] := 206;						finalAnim := 5;						moveThereAtFram := 3;					end;			end;		end;		procedure MakeSciMove;			var				c: integer;				di: integer;		begin			di := direction;			if di = kNoMove then				di := (oldDir + 2) mod 8;			if oldDir = di then				begin					animSequence[1] := 1000 + di;					animSequence[2] := 1150 + di;					animSequence[3] := 1000 + di;					finalAnim := 3;					moveThereAtFram := 2;				end			else if ((oldDir - di) + 8) mod 8 = 2 then		{truning left}				begin					animSequence[1] := 1000 + oldDir;					animSequence[2] := 999 + oldDir;					animSequence[3] := 998 + oldDir;					animSequence[4] := 1148 + oldDir;					animSequence[5] := 998 + oldDir;					finalAnim := 5;					moveThereAtFram := 3;					for c := 1 to 5 do						if c <> 4 then							begin								if animSequence[c] < 1000 then									animSequence[c] := animSequence[c] + 8;								if animSequence[c] > 1007 then									animSequence[c] := animSequence[c] - 8;							end						else if animSequence[4] < 1150 then							animSequence[4] := animSequence[4] + 8						else if animSequence[4] > 1157 then							animSequence[4] := animSequence[4] - 8;				end			else				begin					animSequence[1] := 1000 + oldDir;					animSequence[2] := 1001 + oldDir;					animSequence[3] := 1002 + oldDir;					animSequence[4] := 1152 + oldDir;					animSequence[5] := 1002 + oldDir;					for c := 1 to 5 do						if c <> 4 then							begin								if animSequence[c] < 1000 then									animSequence[c] := animSequence[c] + 8;								if animSequence[c] > 1007 then									animSequence[c] := animSequence[c] - 8;							end						else if animSequence[4] < 1150 then							animSequence[4] := animSequence[4] + 8						else if animSequence[4] > 1157 then							animSequence[4] := animSequence[4] - 8;					finalAnim := 5;					moveThereAtFram := 3;				end;		end;		procedure MakeQuaMove;			var				startAt: integer;				count: integer;		begin			startAt := CInfoApp(CInfoApp(gApplication)).GetGPane.GetBoard.GetData(xq, yq);			for count := 0 to 3 do				begin					animSequence[count + 1] := startAt + count;					if animSequence[count + 1] > 657 then						animSequence[count + 1] := animSequence[count + 1] - 8;				end;			finalAnim := 4;			moveThereAtFram := 2;		end;		procedure MakeBolMove;		begin			if direction = kDown then				begin					animSequence[1] := 700;					animSequence[2] := 700;					finalAnim := 2;					moveThereAtFram := 1;				end			else if direction > kDown then				begin					animSequence[1] := 700;					animSequence[2] := 703;					animSequence[3] := 702;					animSequence[4] := 701;					animSequence[5] := 700;					finalAnim := 5;					moveThereAtFram := 3;				end			else if direction < kDown then				begin					animSequence[1] := 700;					animSequence[2] := 701;					animSequence[3] := 702;					animSequence[4] := 703;					animSequence[5] := 700;					finalAnim := 5;					moveThereAtFram := 3;				end;		end;		procedure MakeInfMove;		begin			animSequence[1] := 850;			animSequence[2] := 851;			animSequence[3] := 852;			animSequence[4] := 853;			animSequence[5] := 850;			finalAnim := 5;			moveThereAtFram := 3;		end;	begin		case itIsA of			murphy: 				MakeMurMove;			scissor: 				MakeSciMove;			quark: 				MakeQuaMove;			boulder: 				MakeBolMove;			infotron: 				MakeInfMove;		end;	end;	procedure CMoveChore.FrameDone;		var			whichSci, whichQua: integer;			dd: integer;			mySuicide: CSuicideChore;			o: CGridPiece;	begin{    if (itIsA = boulder) or (itIsA = infotron) then}{    begin}{    dd := CInfoApp(gapplication).GetGPane.GetBoard.GetData(xq, yq + 1);}{o := CInfoApp(gapplication).GetGridObj(xq, yq);}{    if (dd = 129) then}{    begin}{    o.Fall(xq, yq);}{    remove;}{    Exit(frameDone);	{no more!}{    end;}{    end;}		if animAt = moveThereAtFram then			begin				dd := CInfoApp(gapplication).GetGPane.GetBoard.GetData(mtx, mty);				if (dd = 129) or (dd = 250) then					begin						CInfoApp(CInfoApp(gApplication)).GetGPane.GetBoard.SetData(xq, yq, 129);						CInfoApp(CInfoApp(gApplication)).GetGPane.GetBPane.Draw1(xq, yq);						if itIsA = scissor then							begin								whichSci := CInfoApp(gapplication).GetGPane.GetBoard.WhichScissor(xq, yq);								if whichSci <> -1 then									CInfoApp(gapplication).GetGPane.GetBoard.MovedScissor(whichSci, direction);							end;						if itIsA = quark then							begin								whichQua := CInfoApp(gapplication).GetGPane.GetBoard.WhichQuark(xq, yq);								if whichQua <> -1 then									CInfoApp(gapplication).GetGPane.GetBoard.MovedQuark(whichQua, direction);							end;						xq := mtx;						yq := mty;					end				else					begin						if itIsA = scissor then							begin								whichSci := CInfoApp(gapplication).GetGPane.GetBoard.WhichScissor(xq, yq);								if whichSci <> -1 then									CInfoApp(gapplication).GetGPane.GetBoard.MovedScissor(whichSci, 8);							end;						if itIsA = quark then							begin								whichQua := CInfoApp(gapplication).GetGPane.GetBoard.WhichQuark(xq, yq);								if whichQua <> -1 then									CInfoApp(gapplication).GetGPane.GetBoard.MovedQuark(whichQua, 8);							end;					end;				CInfoApp(CInfoApp(gApplication)).GetGPane.GetBoard.SetData(xq, yq, animSequence[animAt]);				CInfoApp(CInfoApp(gApplication)).GetGPane.GetBPane.Draw1(xq, yq);			end;	end;	procedure CMoveChore.IMoveChore (d: integer; oldD: integer; whatIsIt: MovingThingy; x, y: integer);	begin		IAnimChore(animSequence, finalAnim, 0, x, y);		myIdent := kMoveChore;		direction := d;		oldDir := oldD;		itIsA := whatIsIt;		case d of			kNoMove: 				begin					mtx := x;					mty := y;				end;			kUp: 				begin					mtx := x;					mty := y - 1;				end;			kRight: 				begin					mtx := x + 1;					mty := y;				end;			kDown: 				begin					mtx := x;					mty := y + 1;				end;			kLeft: 				begin					mtx := x - 1;					mty := y;				end;			kUpRight: 				begin					mtx := x + 1;					mty := y - 1;				end;			kUpLeft: 				begin					mtx := x - 1;					mty := y - 1;				end;			kDownRight: 				begin					mtx := x + 1;					mty := y + 1;				end;			kDownLeft: 				begin					mtx := x - 1;					mty := y + 1;				end;		end;		MakeArray;		if (itIsA = boulder) or (itIsA = infotron) then			CInfoApp(gapplication).GetGPane.GetBoard.SetData(mtx, mty, 250);	end;	procedure CMoveChore.SequenceDone;		var			whatHere: integer;			o: CGridPiece;			theDir: integer;	begin		if (itIsA = boulder) or (itIsA = infotron) then			begin				o := CInfoApp(gapplication).GetGridObj(xq, yq);				theDir := CInfoApp(gapplication).GetNextRollDir;				if not o.CheckRoll(xq, yq, theDir) then					if not o.CheckRoll(xq, yq, 8 - theDir) then						o.Fall(xq, yq);				CInfoApp(gapplication).ToggleRollDir;			end;		inherited SequenceDone;	end;	procedure CMoveChore.Perform (var maxSleep: longint);		var			what: integer;	begin		what := CInfoApp(gapplication).GetGPane.GetBoard.GetData(xq, yq);		if shouldRemove then			Remove		else if (itIsA = infotron) and (((what >= 499) and (what <= 511)) or ((what >= 139) and (what <= 214)) or ((what >= 1200) and (what <= 1210))) then			CInfoApp(gapplication).GetMurphyObj.Explode(xq, yq)		else			DoOneFrame;	end;end.
unit QuickDrawProcs;{misc. units for using Quick Draw}interface	procedure DrawPic2 (id: integer; at: Point);	procedure drawPic (id: integer; at: point);	procedure ShowPicCenter (pic: PicHandle; inside: rect);	procedure DrawPicCenterGraf (id: integer);	procedure ShowPicCenterGraf (pic: PicHandle);	procedure ShowPic (aPic: picHandle; at: Point);	procedure DrawPicCenter (id: integer; inside: rect);	function getPRect (id: integer): rect;	function isPointInRect (location: point; checkRect: rect): boolean;	function pOffsetRect (aRect: rect; a, b: integer): rect;	function CenterPict (num: integer; rec: rect): point;	function CenterKnownPict (aPic: PicHandle; rec: rect): point;	function RectsOverlap (r1, r2: rect): boolean;	function RectEqual (r1, r2: rect): boolean;	function InsetRectFunction (r: rect; dh, dv: integer): rect;implementation	function InsetRectFunction (r: rect; dh, dv: integer): rect;	begin		InsetRect(r, dh, dv);		InsetRectFunction := r;	end;	function RectEqual (r1, r2: rect): boolean;	begin		RectEqual := (r1.top = r2.top) and (r1.left = r2.left) and (r1.right = r2.right) and (r1.bottom = r2.bottom);	end;	function pOffsetRect (aRect: rect; a, b: integer): rect;	begin		offsetRect(aRect, a, b);		pOffsetRect := aRect;	end;	procedure WriteRect (r: rect);	begin		Writeln('Top,Left,Bot,Right:', r.top : 1, ' ', r.left : 1, ' ', r.bottom : 1, ' ', r.right : 1, ' ');	end;	procedure OlddrawPic (id: integer; at: point);		var			aPic: picHandle;			aRect: rect;			setVal, svt: integer;	begin		aPic := getPicture(id);		setVal := aPic^^.picFrame.top;		svt := aPic^^.picFrame.left;		setRect(aRect, at.v, at.h, aPic^^.picFrame.right - svt + at.h, aPic^^.picFrame.bottom - setVal + at.v);		WriteRect(aRect);		drawPicture(aPic, aRect);		releaseResource(handle(aPic));	end;	procedure DrawPic (id: integer; at: point);		var			aPic: picHandle;			aRect: rect;			setVal, svt: integer;	begin		aPic := getPicture(id);		setVal := aPic^^.picFrame.top;		svt := aPic^^.picFrame.left;		setRect(aRect, at.h, at.v, aPic^^.picFrame.right - svt + at.h, aPic^^.picFrame.bottom - setVal + at.v);		drawPicture(aPic, aRect);	end;	procedure FitPicCenterGraf (p: PicHandle);		var			pHeight, pWidth: integer;			pHalfHeight, pHalfWidth: integer;			currentGrafPort: GrafPtr;			cgpRect: rect;			pRect: rect;			cgpCenterH, cgpCenterV: integer;	begin		pHeight := p^^.picFrame.bottom;		pWidth := p^^.picFrame.right;		pHalfHeight := (p^^.picFrame.bottom) div 2;		pHalfWidth := (p^^.picFrame.right) div 2;		GetPort(currentGrafPort);		cgpRect := currentGrafPort^.portBits.bounds;{note that the cgpRect.top=cgpRect.left=0}		cgpCenterV := cgpRect.bottom div 2;		cgpCenterH := cgpRect.right div 2;		if pHeight > cgpRect.bottom then			begin				pRect.top := 0;				pRect.bottom := cgpRect.bottom;			end		else			begin				pRect.top := cgpCenterV - pHalfHeight;				pRect.bottom := cgpCenterV + pHalfHeight;			end;		if pWidth > cgpRect.right then			begin				pRect.left := 0;				pRect.right := cgpRect.right;			end		else			begin				pRect.left := cgpCenterH - pHalfWidth;				pRect.right := cgpCenterH + pHalfWidth;			end;		DrawPicture(p, pRect);	end;	procedure DrawPic2 (id: integer; at: Point);		var			aPic: picHandle;			aRect: rect;			setVal, svt: integer;	begin		aPic := getPicture(id);		setVal := aPic^^.picFrame.top;		svt := aPic^^.picFrame.left;		setRect(aRect, at.h, at.v, aPic^^.picFrame.right - svt + at.h, aPic^^.picFrame.bottom - setVal + at.v);		drawPicture(aPic, aRect);{    releaseResource(handle(aPic));}	end;	procedure ShowPic (aPic: picHandle; at: Point);		var			aRect: rect;			setVal, svt: integer;	begin		setVal := aPic^^.picFrame.top;		svt := aPic^^.picFrame.left;		setRect(aRect, at.h, at.v, aPic^^.picFrame.right - svt + at.h, aPic^^.picFrame.bottom - setVal + at.v);		drawPicture(aPic, aRect);	end;	function getPRect (id: integer): rect;		var			aPic: picHandle;			setVal, svt: integer;	begin		aPic := getPicture(id);		setVal := aPic^^.picFrame.top;		svt := aPic^^.picFrame.left;		setRect(getPRect, 0, 0, aPic^^.picFrame.right - svt, aPic^^.picFrame.bottom - setVal);		releaseResource(handle(aPic));	end;	function CenterPict (num: integer; rec: rect): point;		var			pr: rect;			prHalf, recHalf: integer;			tp: Point;	begin		pr := GetPRect(num);		prHalf := (pr.right - pr.left) div 2;		recHalf := (rec.right - rec.left) div 2;		tp.h := recHalf - prHalf;		prHalf := (pr.bottom - pr.top) div 2;		recHalf := (rec.bottom - rec.top) div 2;		tp.v := recHalf - prHalf;		CenterPict := tp;	end;	function CenterKnownPict (aPic: PicHandle; rec: rect): point;		var			pr: rect;			prHalf, recHalf: integer;			tp: Point;	begin		HLock(Handle(aPic));		setRect(pr, 0, 0, aPic^^.picFrame.right - aPic^^.picFrame.left, aPic^^.picFrame.bottom - aPic^^.picFrame.top);		HUnlock(Handle(aPic));		prHalf := (pr.right - pr.left) div 2;		recHalf := (rec.right - rec.left) div 2;		tp.h := recHalf - prHalf;		prHalf := (pr.bottom - pr.top) div 2;		recHalf := (rec.bottom - rec.top) div 2;		tp.v := recHalf - prHalf;		CenterKnownPict := tp;	end;	procedure DrawPicCenter (id: integer; inside: rect);		var			pic: PicHandle;	begin		pic := GetPicture(id);		ShowPic(pic, CenterKnownPict(pic, inside));		ReleaseResource(Handle(pic));	end;	procedure ShowPicCenter (pic: PicHandle; inside: rect);	begin		ShowPic(pic, CenterKnownPict(pic, inside));	end;	procedure DrawPicCenterGraf (id: integer);		var			g: GrafPtr;	begin		GetPort(g);		DrawPicCenter(id, g^.portRect);	end;	procedure ShowPicCenterGraf (pic: PicHandle);		var			g: GrafPtr;	begin		GetPort(g);		ShowPicCenter(pic, g^.portBits.bounds);	end;	function isPointInRect (location: point; checkRect: rect): boolean;	begin		isPointInRect := PtInRect(location, checkRect);		{Kept for compatability only}	end;	function RectsOverlap (r1, r2: rect): boolean;	begin		RectsOverlap := PtInRect(r2.topLeft, r1) or PtInRect(r2.botRight, r1);	end;end.
{-------------------------------------------------------------------------------}{Gamma utils by Matt Slot																		}{  																									}{  	This library is intended as a general tool for manipulating the Gamma Tables			}{  		of Graphics Devices, to ramp them up or down in order to achieve smooth			}{  		screen fades. The source is included for programmers who want to convert		}{  		the library to A4-based, but it is not commented for public consumption.			}{  	The library defines 2 globals to save state data, but the entire Table 					}{  		manipulation is performed with unlocked handles to be easy on your heap.			}{  		The typical memory chunk is about 600 bytes for a 13" Monitor in 8-bit 			}{  		depth, or about 1700 bytes for one in 24-bit color. Usage will vary.				}{  	Of course, the Classic Mac cannot use Gamma Fades, only Mac II or later machines	}{  		with attached monitors. (I don't know about the Color Classic thoÕ!). Also,			}{  		GDevice manipulation needs to follow InitGraf() & InitWindows() calls.				}{  	Please use the listed functions to see if you can use this code before you set			}{  		it up. As usual, this stuff is not warranteed, guaranteed, or anything--			}{  		use it at your own risk. It is not Apple-recommended for anything, but it			}{  		worked for me, so there!																}{  																									}{  		Written:	12/17/92, Matt Slot, fprefect@engin.umich.edu							}{-------------------------------------------------------------------------------}{	Ported to pascal by Matthew Xavier Mora													}{	mxmora@unix.sri.com																		}{	07-20-93																						}{-------------------------------------------------------------------------------}unit gammaPasLibIntf;interface	const		kGammaUtilsSig = 'GAMA';							{A quick signature}		kGetDeviceListTrapNum = $AA29;					{To help check    for compatibility }	function IsGammaAvailable: integer;	function IsOneGammaAvailable (theGDevice: GDHandle): Boolean;	function SetupGammaTools: OSErr;	function DisposeGammaTools: OSErr;	function DoGammaFade (percent: integer): OSErr;	function DoOneGammaFade (theGDevice: GDHandle; percent: integer): OSErr;	function GetDevGammaTable (theGDevice: GDHandle; var theTable: GammaTblPtr): OSErr;	function SetDevGammaTable (theGDevice: GDHandle; var theTable: GammaTblPtr): OSErr;	function GammaAvail: Boolean;{-------------------------------------------------------}	procedure DelayFadeToBlack (delayTicks: longint);	procedure FadeToBlack (speed: integer);	procedure FadeFromBlack (speed: integer);	procedure DelayFadeFromBlack (delayTicks: longint);{-------------------------------------------------------}implementation	function IsGammaAvailable: integer;	external;	function IsOneGammaAvailable (theGDevice: GDHandle): Boolean;	external;	function SetupGammaTools: OSErr;	external;	function DisposeGammaTools: OSErr;	external;	function DoGammaFade (percent: integer): OSErr;	external;	function DoOneGammaFade (theGDevice: GDHandle; percent: integer): OSErr;	external;	function GetDevGammaTable (theGDevice: GDHandle; var theTable: GammaTblPtr): OSErr;	external;	function SetDevGammaTable (theGDevice: GDHandle; var theTable: GammaTblPtr): OSErr;	external;{A cheezy function to use pascal true and false}	function GammaAvail: boolean;	begin		if (IsGammaAvailable = 0) then			GammaAvail := false		else			GammaAvail := true;	end;{-------------------------------------------------------}	procedure DelayFadeToBlack (delayTicks: longint);{-------------------------------------------------------}		var			i: integer;			oe: integer;			finalTicks: longint;	begin		i := 100;		while i > 0 do			begin				oe := DoGammaFade(i);				i := i - 1;				Delay(delayTicks, finalTicks);			end;	end;{-------------------------------------------------------}	procedure FadeToBlack (speed: integer);{-------------------------------------------------------}		var			i: integer;			oe: integer;			finalTicks: longint;	begin		i := 100;		while (i >= 0) do			begin				oe := DoGammaFade(i);				i := i - speed;			end;	end;{-------------------------------------------------------}	procedure FadeFromBlack (speed: integer);{-------------------------------------------------------}		var			i: integer;			oe: integer;			finalTicks: longint;	begin		i := 0;		while (i <= 100) do			begin				oe := DoGammaFade(i);				i := i + speed;			end;	end;{-------------------------------------------------------}	procedure DelayFadeFromBlack (delayTicks: longint);{-------------------------------------------------------}		var			i: integer;			oe: integer;			finalTicks: longint;	begin		i := 0;		while (i <= 100) do			begin				oe := DoGammaFade(i);				i := i + 1;				Delay(delayTicks, finalTicks);			end;	end;end.
program NEWInfotron;{NO OOP}	uses		ObjIntf, QDOffscreen, sound, gammapasLibIntf, {}		coloroffscreen, myRGBColors, CInfoDialog, ColorOffScreen, {}		QIST, menubars, palettes, picker, QuickDrawProcs, InfoWindows, {}		dataIntf, pictpal, everything;{---Begin PeckEvents Declarations---}	const		kTicksBetween = 5;	{was 4}		kSecondsForMusic = 120;		WNE_TRAP_NUM = $60;		UNIMPLEMENTED_TRAP_NUM = $9F;		MaxWind = 15;		MaxMenu = 10;	var		musicRefNum: integer;		lastMusicChange: longint;		dummy: boolean;		aRecta: rect;		windows: array[0..MaxWind] of WindowPtr;		menus: array[0..MaxMenu] of MenuHandle;		curNumWindows: integer;		curNumMenus: integer;		wantsToQuit: boolean;		gWNEImplemented: boolean;		hisApple: MenuHandle;		currentWindow: integer;		fstPtr: grafPtr;		myGoUp, myGoDown, myGoLeft, myGoRight: boolean;{-----------COPY THE FOLLOWING ROUTINES AT THE FRONT OF YOUR PROGRAM---------}	procedure peckInit (howMany: integer);	forward;	procedure peckQuit;	forward;	procedure peckNewWindow (var aWindow: windowPtr);	forward;	procedure peckKillWindow (var aWindow: windowPtr);	forward;	procedure peckNewMenu (var aMenu: menuHandle; disp: boolean);	forward;	procedure peckKillMenu (var aMenu: menuHandle);	forward;	procedure peckApple (aboutName: str255);	forward;	procedure peckMain;	forward;	procedure peckHalt;	forward;{-------------------MAIN EVENT DOING CODE GOES HERE-------------------------}	procedure ______________;	forward;	var		gFileMenu, gPlayerMenu, gGameMenu: MenuHandle;{128 file 129 game 130 player}	procedure resetRandom;	begin		randSeed := tickCount;	end;	procedure InitInfotron;		var			oe: OSErr;			at: point;			stop: longint;			continue: boolean;			tempRect: rect;			randomRect: rect;			tRegDial, tAboutDial, tNewDial, tRenDial, tKeysDial, tHelpDial: CInfoDialog;			tLevelDial, tOpenDial, tDeleteDial: CInfoScrollDialog;			gBigRect: rect;			oldPal: paletteHandle;			gTheGD: GDHandle;		function MultipleMonitors: boolean;  	{TRUE  if machine has more than one monitor attached}			var				agd: GDHandle;		begin			agd := GetDeviceList;			if (agd = nil) then				MultipleMonitors := FALSE			else if (GetNextDevice(agd) = nil) then				MultipleMonitors := FALSE			else				MultipleMonitors := TRUE;		end;		procedure MachineAbilities;			function ColorMachine: boolean;				var					mySE: SysEnvRec;					oe: OSErr;			begin				oe := SysEnvirons(2, mySE);				ColorMachine := mySE.hasColorQD;			end;			function FindGoodMonitor (var itsScreen: rect): boolean;				var					agd: GDHandle;					maxArea: longint;					area: longint;					commonRect: rect;					gotOne: boolean;					spmh: PixMapHandle;					pixDepth: integer;			begin				maxArea := 0;				gotOne := FALSE;				agd := GetDeviceList;				while (agd <> nil) do					begin						if SectRect(agd^^.gdRect, screenBits.bounds, commonRect) then							begin								if ((commonRect.right - commonRect.left) > 639) and ((commonRect.bottom - commonRect.top) > 479) then									begin										spmh := agd^^.gdPMap;										pixDepth := spmh^^.pixelSize;										if pixDepth = 8 then											begin												gotOne := TRUE;												itsScreen := CommonRect;												gTheGD := agd;											end;									end;							end;	{if sectrect}						agd := GetNextDevice(agd);					end;	{while agd<>nil}				FindGoodMonitor := GotOne;			end;	{FindGoodMonitors}{the new version of bigmonitor, below, will handle multiple monitors.}{it will find the correct monitor to place the window on, if possible.}			function BigMonitor: boolean;				var					hs, vs: integer;			begin				if MultipleMonitors then					BigMonitor := FindGoodMonitor(gBigRect)				else					begin						gTheGD := GetDeviceList;						hs := screenBits.bounds.right - screenBits.bounds.left;						vs := screenBits.bounds.bottom - screenBits.bounds.top;						BigMonitor := (hs > 639) and (vs > 479);					end;			end;{    function BigMonitor: boolean;}{    var}{    hs, vs: integer;}{    begin}{    hs := screenBits.bounds.right - screenBits.bounds.left;}{    vs := screenBits.bounds.bottom - screenBits.bounds.top;}{    BigMonitor := (hs > 639) and (vs > 479);}{    end;}			function Colors256: boolean;				var					spmh: PixMapHandle;					pixDepth: integer;					curDev: GDHandle;			begin				curDev := GetDeviceList;				spmh := curDev^^.gdPMap;				pixDepth := spmh^^.pixelSize;				Colors256 := (pixDepth = 8);			end;			procedure QuitError (s: str255; shouldQuit: boolean);				procedure SDD (num: integer);					var						tDlog: DialogPtr;						itemHit: integer;				begin					tDlog := GetNewDialog(num, nil, WindowPtr(-1));					ShowWindow(tDlog);					SetPort(tDlog);					ModalDialog(nil, itemHit);					DisposDialog(tDlog);				end;			begin				Sysbeep(10);				ParamText(s, '', '', '');				SDD(501);				if shouldQuit then					ExitToShell;			end;		begin			if not ColorMachine then				QuitError('Infotronª requires a color machine to run! Sorry!', TRUE)			else if not BigMonitor then				if not MultipleMonitors then					QuitError('Infotronª requires a 14 inch or larger monitor to run! Sorry!', TRUE)				else					QuitError('While you may have more than one monitor, none of them are large enough and/or can display enough colors to run correctly. Bummer for you. Try running Infotronª on a normal Mac. :-)', TRUE)			else if (not MultipleMonitors) then				if (not Colors256) then	{only do this if they have ONE monitor!}					QuitError('Infotronª needs exactly 256 colors. Please select 256 colors from the Monitors control panel, and then restart Infotronª.', TRUE);		end;		procedure FigureCenterMonitor;			var				monH, monV: integer;				sizH, sizV: integer;		begin			if not MultipleMonitors then				begin					monH := screenBits.bounds.right - screenBits.bounds.left;					monV := screenBits.bounds.bottom - screenBits.bounds.top;					gMoveH := (monH - 640) div 2;					gMoveV := (monV - 480) div 2;				end			else		{we have gBigRect to help us find the center}				begin					monV := gBigRect.top;					monH := gBigRect.left;					sizH := gBigRect.right - gBigRect.left;					sizV := gBigRect.bottom - gBigRect.top;					gMoveH := ((sizH - 640) div 2) + monH;					gMoveV := ((sizV - 480) div 2) + monV;				end;		end;		procedure GetPrefs;			const				prefsResType = 'MuPf';			type				pdp = ^prefsData;				pdh = ^pdp;				prefsData = record						wantsMusic: boolean;						wantsSound: boolean;					end;			var				p: pdh;				h: handle;		begin			h := Get1Resource(prefsResType, 128);			if (h = nil) or (resError <> noErr) then				begin					gameState := gameState + [hasSound, hasMusic];					p := pdh(NewHandle(sizeOf(prefsData)));					p^^.wantsMusic := TRUE;					p^^.wantsSound := TRUE;					AddResource(handle(p), prefsResType, 128, 'User Preferences');					UpdateResFile(curResFile);					ReleaseResource(handle(p));				end			else				begin					p := pdh(h);					if p^^.wantsMusic then						gameState := gameState + [hasMusic];					if p^^.wantsSound then						gameState := gameState + [hasSound];					ReleaseResource(handle(p));				end;			SoundState(hasSound in gameState);			CheckItem(gGameMenu, iCmdSoundFX, hasSound in gameState);			CheckItem(gGameMenu, iCmdMusic, hasMusic in gameState);		end;		procedure SetRegInfo;			var				mySH: stHand;				cnt: integer;		begin			registered := TRUE;			firstTen[1] := 'Warm Up';			firstTen[2] := 'Stone-Age';			firstTen[3] := 'Quick!';			firstTen[4] := 'Buggy';			firstTen[5] := 'Down they fall!';			firstTen[6] := 'Trickster';			firstTen[7] := 'Technicalities...';			firstTen[8] := 'But how?';			firstTen[9] := 'Anonymous';			firstTen[10] := 'Outsie';		end;		function showLogo (pic: integer): boolean;			var				stop: longint;		begin			FillRect(gMainWind^.portRect, black);			DrawPicCenterGraf(pic);			FadeFromBlack(2);			stop := tickCount + 180;			while not button and (tickCount < stop) do				;			showLogo := button;			FadeToBlack(2);			FillRect(gMainWind^.portRect, black);			CleanSounds;		end;		procedure GrayPal;			var				c: integer;				p: paletteHandle;				r: rgbColor;		begin			oldPal := NewPalette(256, nil, pmTolerant + pmExplicit, 128);			oldPal := GetPalette(gMainWind);			p := NewPalette(254, nil, pmTolerant + pmExplicit, 128);			for c := 0 to 253 do				begin					r.red := smallfract(longint(c + 1) * longint(255));					r.green := smallfract(r.red);					r.blue := smallfract(r.red);					setEntryColor(p, (253 - c) + 1, r);				end;			setPalette(gMainWind, p, TRUE);			ActivatePalette(gMainWind);		end;		procedure NormalPal;		begin			RestoreDeviceClut(gTheGD);			SetPalette(gMainWind, oldPal, TRUE);			ActivatePalette(gMainWind);			RestoreDeviceClut(gTheGD);		end;		function ShowQAnim: boolean;			var				c: integer;				stop: longint;		begin			FillRect(gMainWInd^.portRect, black);			DrawPicCenterGraf(1012);			FadeFromBlack(2);			Delay(2, stop);			ShowQAnim := FALSE;		end;		function ShowIncorporated: boolean;			var				c: integer;				stop: longint;				p: GrafPtr;				at: point;				pic: picHandle;				ir: rect;				pr: rect;		begin{    if c = 1006 then}{FillRect(gMainWInd^.portRect, black);}			GetPort(p);			pr := p^.portRect;			pic := getPicture(2000);			ir := pic^^.picFrame;			ReleaseResource(handle(pic));			at.h := ((pr.right + pr.left) div 2) - ((ir.right - ir.left) div 2);			pic := getPicture(1012);			ir := pic^^.picFrame;			ReleaseResource(handle(pic));			at.v := ((pr.top + pr.bottom) div 2) + ((ir.bottom - ir.top) div 2) + 10;{at.h := 100;}{    at.v := 100;}			DrawPic(2000, at);			Delay(20, stop);			PlaySound(143);			for c := 2000 to 2016 do				begin					Delay(2, stop);					DrawPic(c, at);				end;			stop := tickCount + 180;			while not button and (tickCount < stop) do				;			ShowIncorporated := button;			FadeToBlack(2);		end;		procedure MakeFallingInfo;			var				x, y: integer;		begin			fallingInfo := bigmomma(NewPtrClear(sizeOf(bigarr)));			fallChores := bigmomma(NewPtrClear(sizeOf(bigArr)));		end;		var			myWarningDialog: DialogPtr;			dih: integer;	begin		PeckInit(15);		gMyResFile := CurResFile;		MachineAbilities;		FigureCenterMonitor;		Init_QIST;		SoundState(TRUE);		MakeFallingInfo;		myWarningDialog := GetNewDialog(2000, nil, windowPtr(-1));		ShowWindow(myWarningDialog);		SetPort(myWarningDialog);		Sysbeep(10);		Sysbeep(10);		repeat			ModalDialog(nil, dih);		until (dih = 1);		DisposeDialog(myWarningDialog);		InitMenuBars;		oe := SetupGammaTools;		nextRollDir := kRight;		FadeToBlack(2);		HideCursor;		gBackWind := nil;		gSuspended := FALSE;		gMainWind := NewCWindow(nil, screenBits.bounds, '', TRUE, 2, WindowPtr(-1), false, 0);		PeckNewWindow(gMainWind);		ShowWindow(gMainWind);		SetPort(gMainWind);		GrayPal;			{******}		HideMenuBar(gMainWind);		RGBForeColor(myBlackColor);{continue := ShowLogo(147);}		continue := ShowQAnim;		if continue then			FadeToBlack(2);		SetPort(gMainWind);		makeGObjs;		shouldKillChores := FALSE;		CleanSounds;		if not continue then			continue := ShowIncorporated;		CleanSounds;		SetPictPalette;		{*****}		if not continue then			continue := ShowLogo(3000);		CleanSounds;		FillRect(gMainWind^.portRect, black);		NormalPal;		{*****}		CleanSounds;		InitalizeGraphics;		CleanSounds;		DrawPicCenterGraf(140);		FadeFromBlack(2);		while button do			;		while not button do			;		while button do			;		FadeToBlack(2);		ShowMenuBar(gMainWind);		PeckApple('About Infotron...');		GFileMenu := getMenu(128);		PeckNewMenu(gFileMenu, FALSE);		gPlayerMenu := getMenu(130);		PeckNewMenu(gPlayerMenu, FALSE);		gGameMenu := getMenu(129);		PeckNewMenu(gGameMenu, TRUE);		CleanSounds;		ResetRandom;		InitChoreLists;		ldHrs := 0;		ldMins := 0;		ldSecs := 0;		musicRefNum := -1;		musicID := ARandom(3) + 999;		repeatCnt := 1;		SetRegInfo;		GetPrefs;		CleanSounds;		setUpDials(tRegDial, tAboutDial, tNewDial, tRenDial, tKeysDial, tHelpDial, tLevelDial, tOpenDial, tDeleteDial);		gRegDial := tRegDial;		gAboutDial := tAboutDial;		gNewDial := tNewDial;		gRenDial := tRenDial;		gKeysDial := tKeysDial;		gHelpDial := tHelpDial;		gLevelDial := tLevelDial;		gOpenDial := tOpenDial;		gDeleteDial := tDeleteDial;		CleanSounds;		ShowCursor;		drawStatus;		loadNextLevel := FALSE;		FadeFromBlack(2);	end;	procedure DoFileMenu;	begin		KillBoard;		KillPlayer;		KillLevel;{    SoundsClose;}		PeckQuit;	end;	procedure getNewPlayer;		var			aName: str255;			ignore: boolean;	begin		if GetWinName(aName, gNewDial) then			begin				gPlayer.name := aName;				gPlayer.level := firstTen[1];				gPlayer.skippedLev := [];				gPlayer.highLev := 1;				gPlayer.current := 1;				gPlayer.numSkipped := 0;				gPlayer.time := 0;				gPlayer.keySet[1] := 91;				gPlayer.keySet[2] := 86;				gPlayer.keySet[3] := 88;				gPlayer.keySet[4] := 84;				gPlayer.keySet[5] := 49;				if aName = 'NoRtOfNi42' then					begin						gPlayer.highLev := Count1Resources(levelResType);					end;				savePlayer;				ignore := loadBoard(gPlayer.level);{    GotNewBoard;}				gameState := gameState + [hasPlayer];				drawStatus;			end;	end;	procedure DoPlayerMenu (theItem: integer);		var			n: str255;			name: str255;			tempData: handle;	begin		case theItem of			iCmdNew: 				begin					getNewPlayer;				end;			iCmdOpen: 				begin					OpenPlayer;				end;			iCmdRename: 				begin					if getWinName(n, gRenDial) then						begin							gPlayer.name := n;							savePlayer;						end;				end;			iCmdDelete: 				if DeleteChoice(name, gDeleteDial) then					begin						if name <> gplayer.name then							begin								tempData := GetNamedResource(playerResType, name);								if (tempData <> nil) and (resError = noErr) then									begin										RmveResource(tempData);										ReleaseResource(tempData);									end;							end						else							DoError('This game does not condone suicide.  Please call Dr. Jack Kevorkian.');					end;		end;	end;	procedure ChooseLevel;		var			ignore: boolean;			ol: str255;			osl: SkipSet;			ohl: integer;			ons: integer;			oc: integer;			e: boolean;			c: integer;	begin		ol := gPlayer.level;		osl := gPlayer.skippedLev;		ohl := gPlayer.highLev;		ons := gPlayer.numSkipped;		oc := gPlayer.current;		if LevelChoice(gPlayer.level, gPlayer.skippedLev, gPlayer.highLev, gPlayer.current, gPlayer.numSkipped, gLevelDial) then			begin{    CInfoApp(gappliCATion).GetGPane.GetBoard.KillData;   DAVID DEAL WITH THIS!!!}				ignore := LoadBoard(gPlayer.level);{GotNewBoard;}				SavePlayer;				DrawStatus;			end;	{if levlechoice}	end;	procedure DoGameMenu (theItem: integer);		var			dork, sounds: boolean;	begin		case theItem of			iCmdLevel: 				chooseLevel;			iCmdStart: 				begin					if isPlaying in gameState then						begin{    gameState := gameState - [isPlaying];}{    gameState := gameState - [isPaused];}{    gBartender.SetCmdText(iCmdStart, 'Start');}{    DoKillChores;		{get rid of the chores}						end					else						begin							gameState := gameState + [isPlaying];{gBartender.setCmdText(iCmdStart, 'Abort');}							startNewLevel;						end;				end;			iCmdKeys: 				begin					dork := doSetKey(gPlayer, gKeysDial);					savePlayer;				end;			iCmdHelp: 				doHelp(gHelpDial);			iCmdSoundFX: 				begin					sounds := hasSound in gameState;					checkItem(gGameMenu, iCmdSoundFX, not sounds);					if sounds then						gameState := gameState - [hasSound]					else						gameState := gameState + [hasSound];					SoundState(not sounds);{    SetPrefs;}				end;			iCmdMusic: 				begin					if (hasMusic in gameState) then						begin							gameState := gameState - [hasMusic];							ContSoundStop(musicRefNum);							musicRefNum := -1;{    if ChanUsed(1) then}{    ChanStop(1);}						end					else						begin							gameState := gameState + [hasMusic];							musicID := aRandom(3) + 999;							repeatCnt := 1;						end;					checkItem(gGameMenu, iCmdMusic, (hasMusic in gameState));{    SetPrefs;}				end;		end;	{case}	end;	procedure FixMenuHilites;	begin		DisableItem(gPlayerMenu, iCmdNew);		DisableItem(gPlayerMenu, iCmdOpen);		DisableItem(gPlayerMenu, iCmdRename);		DisableItem(gPlayerMenu, iCmdDelete);		DisableItem(gGameMenu, iCmdStart);		DisableItem(gGameMenu, iCmdPause);		DisableItem(gGameMenu, iCmdLevel);		DisableItem(gGameMenu, iCmdKeys);		EnableItem(gGameMenu, iCmdHelp);		EnableItem(gPlayerMenu, iCmdDelete);		EnableItem(gFileMenu, iCmdQuit);		EnableItem(gGameMenu, iCmdSoundFX);		EnableItem(gGameMenu, iCmdMusic);		checkItem(gGameMenu, iCmdSoundFX, hasSound in gameState);		checkItem(gGameMenu, iCmdMusic, hasMusic in gameState);		if not (isPaused in GameState) then			begin				EnableItem(gPlayerMenu, iCmdNew);				EnableItem(gPlayerMenu, iCmdOpen);			end;		if hasPlayer in GameState then			begin				EnableItem(gPlayerMenu, iCmdRename);				EnableItem(gGameMenu, iCmdKeys);				if not (isPaused in GameState) then					EnableItem(gGameMenu, iCmdLevel);				if (hasLevel in GameState) and not loadNextLevel and not (isPaused in GameState) then					EnableItem(gGameMenu, iCmdStart);				if isPlaying in GameState then					SetItem(gGameMenu, iCmdStart, 'Abort')				else					SetItem(gGameMenu, iCmdStart, 'Start');			end;	end;	procedure Process1Event;		var			myKeys: keyMap;		function ResourceName (id: integer; daKind: ResType): str255;			var				h: handle;				myId: integer;				myType: ResType;				myName: str255;		begin			ResourceName := '';			h := GetResource(daKind, id);			if h <> nil then				begin					GetResInfo(h, myId, myType, myName);					ReleaseResource(h);					ResourceName := myName;				end;		end; {ResourceName}		function CanScroll (dir: integer): boolean;			var				mx, my: integer;				bx, by: integer;		begin			GetLoc(mx, my);			GetSize(bx, by);			if ((dir = kUp) and (my > 7) and (my < by - 6)) then					{7,6}				CanScroll := true			else if ((dir = kRight) and (mx < bx - 9) and (mx > 11)) then		{9,11}				CanScroll := true			else if ((dir = kDown) and (my > 8) and (my < by - 5)) then		{8,5}				CanScroll := true			else if ((dir = kLeft) and (mx > 10) and (mx < bx - 10)) then		{10,10}				CanScroll := true			else				canScroll := false;		end;		{CanScroll}		procedure SmoothMusic;			var				nmid: integer;		begin			if (hasMusic in gameState) and not (isPaused in gameState) then				if ((tickCount - lastMusicChange) > (kSecondsForMusic * 60)) or (musicRefNum = -1) then					begin						nmid := ARandom(3) + 999;						if (musicRefNum = -1) then							begin								musicID := nmid;								musicRefNum := ContSound(musicID);							end						else if nmid <> musicID then							begin								ContSoundStop(musicRefNum);								musicID := nmid;								musicRefNum := ContSound(musicID);							end;						lastMusicChange := tickCount;					end;		end;		{SmoothMusic}		procedure CoolPortals (oldX, oldY, newX, newY, myDir, num: integer);			var				murphPic, offX, offY, offX2, offY2, realNewX, realNewY: integer;		begin			whatToBlank := num;			lastWasPortal := TRUE;			myGoUp := myKeys[gUpKey];			myGoDown := myKeys[gDownKey];			myGoLeft := myKeys[gLeftKey];			myGoRight := myKeys[gRightKey];			murphPic := GetData(newX, newY);			realNewX := LocFromDir(newX, newY, myDir).h;			realNewY := LocFromDir(newX, newY, myDir).v;			case myDir of				kUp: 					begin						offX := 0;						offX2 := 0;						offY := -16;						offY2 := 16;					end;				kDown: 					begin						offX := 0;						offX2 := 0;						offY := 16;						offY2 := -16;					end;				kLeft: 					begin						offX := -16;						offX2 := 16;						offY := 0;						offY2 := 0;					end;				kRight: 					begin						offX := 16;						offX2 := -16;						offY := 0;						offY2 := 0;					end;			end;			SetData(newX, newY, num);			DrawOffset(oldX, oldY, offX, offY, murphPic);			DrawOffset(realNewX, realNewY, offX2, offY2, murphPic);			Draw1(newX, newY);		end;		{CoolPortals}		procedure MurphyMove (oldX, oldY, newX, newY, myDir: integer; spaceDown: boolean);			const				kExplStart = 600;				kExplEnd = 609;				kInfoStart = 350;				kInfoEnd = 358;				kBoldStart = 700;				kBoldEnd = 707;				kGreen = 133;				kYellow = 134;				kRed = 135;				k4Way = 132;				kPortStart = 900;				kPortEnd = 952;				kBugStart = 300;				kBugEnd = 305;				kTheInfo = 850;				kRedStart = 400;				kRedEnd = 406;				kCirc = 128;				kCircStart = 450;				kCircEnd = 456;			var				what: CGridPiece;				num, onum, count: integer;				xSize, ySize: integer;		begin			lastMoved := tickCount;			isSleeping := FALSE;	{damn it!}			if not spaceDown then				begin					what := GetGridObj(newX, newY);					num := GetData(newX, newY);					onum := GetData(oldX, oldY);					GetSize(xSize, ySize);					SetLastDir(myDir);					if ((num >= kExplStart) & (num <= kExplEnd)) | ((num >= kInfoStart) & (num <= kInfoEnd)) then						GetMurphyObj.killMurphy		{used to be explode(newX,newY)}					else if (what.WalkOnto(newX, newY)) then						if not gAARDVARK_PLATYPUSS_WOMBAT then							begin	{ok, murphy can move}								SetLoc(newX, newY);	{set his location}								if (myDir = kUp) or (myDir = kDown) then	{and his data}									begin										if lastFacingLR = kLeft then											SetData(newX, newY, kBase + kLft + gPhase)										else											SetData(newX, newY, kBase + kRt + gPhase);									end	{up or down}								else if (myDir = kLeft) then									begin										SetData(newX, newY, kBase + kLft + gPhase);										lastFacingLR := kLeft;									end	{left}								else if (myDir = kRight) then									begin										SetData(newX, newY, kBase + kRt + gPhase);										lastFacingLR := kRight;									end;	{right}								if (gPhase = kSml) or (gPhase = kBig) then	{change his chomp}									gPhase := kMed								else									begin										gPhase := gFromMed;										gFromMed := 4 - gFromMed;									end;	{gPhase is kMed}								if ((num >= kBoldStart) and (num <= kBoldEnd)) or (num = kGreen) or (num = kYellow) then									begin										if lastFacingLR = kLeft then											SetData(newX, newY, 196)										else											SetData(newX, newY, 197);										PlaySound(141);	{the pushing noise}									end;		{pushing nums}								SetData(oldX, oldY, whatToBlank);								Draw1(oldX, oldY);								Draw1(newX, newY);								if (num = k4Way) or ((num >= kPortStart) and (num <= kPortEnd)) then									CoolPortals(oldX, oldY, newX, newY, myDir, num)								else									whatToBlank := 129;								if CanScroll(myDir) then									case myDir of										kUp: 											MoveUp;										kLeft: 											MoveLeft;										kRight: 											MoveRight;										kDown: 											MoveDown;									end	{case myDir}								else									RedrawBoard;							end;	{not gAARDVARK_P_W}				end {if not spaceDown}			else		{woops space is down}				begin					num := GetData(newX, newY);					if (num >= kBugStart) and (num <= kBugEnd) then						GetMurphyObj.ExplodeTWO(oldX, oldY)					else if (num = kTheInfo) or (num = kRed) or (num = kCirc) then						begin							case myDir of								kLeft: 									SetData(oldX, oldY, 195);								kUp: 									SetData(oldX, oldY, 199);								kRight: 									SetData(oldX, oldY, 194);								kDown: 									SetData(oldX, oldY, 200);							end;	{case myDir of}							DrawOne(oldX, oldY);							if (num = kTheInfo) then								begin									for count := kInfoStart to kInfoEnd - 1 do										begin											SetData(newX, newY, count);											DrawOne(newX, newY);										end;	{for count}									GotInfotron;								end {it is an infotron}							else if (num = kRed) then {it is a red disk}								begin									for count := kRedStart to kRedEnd do										begin											SetData(newX, newY, count);											DrawOne(newX, newY);										end;	{for count}									GotRedDisk;								end							else	{it is a circuit}								for count := kCircStart to kCircEnd do									begin										SetData(newX, newY, count);										DrawOne(newX, newY);									end;	{for count}							SetData(newX, newY, 129);							DrawOne(newX, newY);						end;	{num=kTheInfo or num=kRed or num=kCirc}				end;		{end space is down}			gMurphy.lastMove := tickCount;		end;		procedure HandlePlaying;			const				kPauseKey = 57;				kMUp = 34;				kMLeft = 38;				kMRight = 37;				kMDown = 46;				kSuicideKey = 53;			var				startTick, endTick: longint;			procedure DoAllChores;				var					count: integer;					listInd: integer;			begin				for count := 1 to tbrLen do					if toBeRidded[count] <> nil then						begin							listInd := toBeRidded[count].listindex;							infoUrgents[listind] := infoUrgents[iuLen];							infoUrgents[listind].listindex := listind;							iuLen := iuLen - 1;							DisposeHandle(Handle(toBeRidded[count]));							toBeRidded[count] := nil;						end;				tbrLen := 0;				for count := 1 to tbaLen do					if toBeAdded[count] <> nil then						begin							iuLen := iuLen + 1;							infoUrgents[iuLen] := toBeAdded[count];							infoUrgents[iuLen].listindex := iuLen;							toBeAdded[count] := nil;						end;				tbaLen := 0;				for count := 1 to iuLen do					if infoUrgents[count] <> nil then						infoUrgents[count].perform(startTick);				if iulen > 0 then	{abcdefg}					RedrawBoard;			end;			procedure DoPause;			begin				gameState := gameState + [isPaused];				ShowCursor;				ContSoundStop(musicRefNum);				musicRefNum := -1;				HaltSounds;				PlaySound(sPause);				StopTime;				ShowMenuBar(gMainWind);			end;			procedure DoLastWasPortal;				var					oldX, oldY: integer;			begin				myKeys[gUpKey] := myGoUp;				myKeys[gRightKey] := myGoRight;				myKeys[gLeftKey] := myGoLeft;				myKeys[gDownKey] := myGoDown;				GetLoc(oldX, oldY);				Draw1(oldX - 1, oldY);				Draw1(oldX + 1, oldY);				Draw1(oldX, oldY - 1);				Draw1(oldX, oldY + 1);				lastWasPortal := FALSE;			end;			procedure PrepareMove (u, r, d, l, s: boolean);				var					oldX, oldY, newX, newY, myDir: integer;			begin				if u then					myDir := kUp				else if r then					myDir := kRight				else if d then					myDir := kDown				else if l then					myDir := kLeft;				if u | r | d | l then					begin						GetLoc(oldX, oldY);						newX := LocFromDir(oldX, oldY, myDir).h;						newY := LocFromDir(oldX, oldY, myDir).v;						MurphyMove(oldX, oldY, newX, newY, myDir, s);						spaceBarWasDown := FALSE;						diskDropSndPlayed := FALSE;					end;			end;			procedure MajikMurphy (u, l, r, d: boolean);				var					oldX, oldY, newX, newY: integer;					myDir: integer;			begin				if u then					myDir := kUp				else if r then					myDir := kRight				else if d then					myDir := kDown				else if l then					myDir := kLeft;				if u | r | d | l then					begin						GetLoc(oldX, oldY);						newX := LocFromDir(oldX, oldY, myDir).h;						newY := LocFromDir(oldX, oldY, myDir).v;						spaceBarWasDown := FALSE;						diskDropSndPlayed := FALSE;						lastMoved := TICKCOUNT;						SetData(oldX, oldY, whatToBlank);						Draw1(oldX, oldY);						whatToBlank := GetData(newX, newY);						SetData(newX, newY, 198);						Draw1(newX, newY);						SetLoc(newX, newY);						if canScroll(myDir) then							case myDir of								kUp: 									moveUp;								kRight: 									moveRight;								kDown: 									moveDown;								kLeft: 									moveLeft;							end						else							RedrawBoard;					end;			end;			procedure SpaceBarDown;			begin				whenWentDown := tickCount;				spaceBarWasDown := TRUE;				diskDropSndPlayed := FALSE;			end;			procedure NoLongerDown;				var					oldX, oldY, count: integer;					myAnim: AnimArray;					myExplChore: CExplChore;					myWaitChore: CWaitTimeChore;			begin				spaceBarWasDown := FALSE;				if tickCount - whenWentDown > 90 then					if UseRedDisk then						begin							whatToBlank := 1105;							GetLoc(oldX, oldY);							for count := 600 to 609 do								myAnim[count - 599] := count;							myAnim[11] := 129;							New(myExplChore);							myExplChore.IExplChore(oldX, oldY, myAnim, 11);							new(myWaitChore);							myWaitChore.IWaitTimeChore(myExplChore, 2);							FudAdd(myWaitChore);						end;			end;			procedure SpaceBarStillDown;			begin				if (tickCount - whenWentDown > 90) and not diskDropSndPlayed then					if gMurphy.NumBombs > 0 then						begin							PlaySound(134);							diskDropSndPlayed := TRUE;						end;			end;			procedure NormalMurphy;				var					mx, my, md: integer;			begin				GetLoc(mx, my);				md := GetData(mx, my);				if (md <> 198) and not isSleeping then					begin						SetData(mx, my, 198);						DrawOne(mx, my);						gMurphy.LastMove := tickCount;						gPhase := kMed;						gFromMed := kBig;					end;			end;			procedure DoSleepStuff;				var					mx, my: integer;			begin				if (sleepPhase <> 144) and (sleepPhase <> 141) then					begin						if (scratchInteger < 3) and (tickCount - scratchLongint > (30 * 60)) then {still on yawning}							begin								sleepPhase := sleepPhase + 1;								scratchLongint := 0;								if sleepPhase > 511 then	{finished a yawn}									begin										sleepPhase := 499;										scratchLongint := tickCount;										scratchInteger := scratchInteger + 1;									end	{sleepPhase>511}								else									begin										GetLoc(mx, my);										SetData(mx, my, sleepPhase);										DrawOne(mx, my);									end;		{sleepPhase<=511}							end {scratchInt<3}						else if (scratchInteger = 3) and (tickCount - scratchLongint > (2 * 60)) then	{gets mad}							begin								if lastFacingLR = kLeft then									sleepPhase := 139								else									sleepPhase := 142;								GetLoc(mx, my);								SetData(mx, my, sleepPhase);								DrawOne(mx, my);								scratchLongint := tickCount;								scratchInteger := 4;							end	{scratchInt=3}						else if (scratchInteger = 4) and (tickCount - scratchLongint > (3 * 60)) then	{gets idea}							begin								sleepPhase := sleepPhase + 1;								GetLoc(mx, my);								SetData(mx, my, sleepPhase);								DrawOne(mx, my);								scratchLongint := tickCount;								scratchInteger := 5;							end						else if (scratchInteger = 5) and (tickCount - scratchLongint > (45)) then {falls asleep}							begin								sleepPhase := sleepPhase + 1;								GetLoc(mx, my);								SetData(mx, my, sleepPhase);								DrawOne(mx, my);								scratchInteger := 6;							end;					end;		{not 144 or 141}			end;			procedure StartSleep;			begin				sleepPhase := 500;				isSleeping := TRUE;				scratchInteger := 0;				scratchLongint := 0;			end;		begin			startTick := tickCount;			DoAllChores;			GetKeys(myKeys);			if (myKeys[kPauseKey] = pauseKeyState) then				DoPause			else if (not (freezeMurphy in gameState)) then {i'm not paused}				begin					if lastWasPortal then						DoLastWasPortal;					PrepareMove(myKeys[gUpKey], myKeys[gRightKey], myKeys[gDownKey], myKeys[gLeftKey], myKeys[gSpecKey]);					if GetName = 'NoRtOfNi42' then {Majik Murphyª}						MajikMurphy(myKeys[kMUp], myKeys[kMLeft], myKeys[kMRight], myKeys[kMDown]);					if myKeys[kSuicideKey] then						GetMurphyObj.KillMurphy;		{might be Explode(mx,my)}					if (not spaceBarWasDown) and myKeys[gSpecKey] then						SpaceBarDown	{the space bar (or special key) went down.}					else if (spaceBarWasDown) and (not myKeys[gSpecKey]) then						NoLongerDown; {the space bar (or special key) is no longer down.}					if spaceBarWasDown and myKeys[gSpecKey] then						SpaceBarStillDown;					if ((tickCount - gMurphy.LastMove) > 15) & (not gAARDVARK_PLATYPUSS_WOMBAT) then						NormalMurphy;					if isSleeping then						DoSleepStuff					else if (tickCount - lastMoved) > (45 * 60) then						StartSleep;				end;		{not (myKeys[kPauseKey]=pauseKeyState)}			endTick := tickCount;			if (endTick - startTick) < kTicksBetween then				while (tickCount - startTick) < kTicksBetween do					;		end;	begin		{Process1Event}		HandlePlaying;		SmoothMusic;		if shouldKillChores then			begin				DoKillChores;				ShowMenuBar(gMainWind);				ContSoundStop(musicRefNum);				musicRefNum := -1;				HaltSounds;			end;		DrawTBoxes(FALSE);	end;	function ResourceName (id: integer; daKind: ResType): str255;		var			h: handle;			myId: integer;			myType: ResType;			myName: str255;	begin		ResourceName := '';		h := GetResource(daKind, id);		if h <> nil then			begin				GetResInfo(h, myId, myType, myName);				ReleaseResource(h);				ResourceName := myName;			end;	end;	procedure DrawBackWind;		var			op: GrafPtr;			p: point;	begin		GetPort(op);		SetPort(gBackWind);		p.h := 0;		p.v := 0;		DrawPic(139, p);		SetPort(op);	end;	procedure SetPrefs;		const			prefsResType = 'MuPf';		type			pdp = ^prefsData;			pdh = ^pdp;			prefsData = record					wantsMusic: boolean;					wantsSound: boolean;				end;		var			p: pdh;			h: handle;	begin		h := Get1Resource(prefsResType, 128);		if (h = nil) or (resError <> noErr) then			begin				gameState := gameState + [hasSound];				gameState := gameState - [hasMusic];				p := pdh(NewHandle(sizeOf(prefsData)));				p^^.wantsMusic := hasMusic in gameState;				p^^.wantsSound := hasSound in gameState;				AddResource(handle(p), prefsResType, 128, 'User Preferences');				UpdateResFile(curResFile);				ReleaseResource(handle(p));			end		else			begin				p := pdh(h);				p^^.wantsMusic := hasMusic in gameState;				p^^.wantsSound := hasSound in gameState;				WriteResource(handle(p));				ChangedResource(handle(p));				UpdateResFile(curResFile);				ReleaseResource(handle(p));			end;	end;	procedure PrepareQuit;	begin		SetPrefs;		if fallingInfo <> nil then			DisposePtr(ptr(fallingInfo));		if fallChores <> nil then			DisposePtr(ptr(fallChores));		Close_QIST;	end;	procedure BigMonUpdate;		var			r: rect;	begin			{need to draw the border around the game / fill in extra area with black!}{draw black space}		RGBForeColor(myBlackColor);		r := screenBits.bounds;		r.bottom := gMoveV - 1;		FillRect(r, black);		r := screenBits.bounds;		r.top := screenBits.bounds.bottom - gMoveV + 1;		FillRect(r, black);		r := screenBits.bounds;		r.right := gMoveH - 1;		FillRect(r, black);		r := screenBits.bounds;		r.left := screenBits.bounds.right - gMoveH + 1;		FillRect(r, black);		PenSize(2, 2);		r.top := gMoveV - 3;		r.left := gMoveH - 3;		r.right := screenBits.bounds.right - gMoveH + 1 + 3;		r.bottom := screenBits.bounds.bottom - gMoveV + 1 + 3;		RGBForeColor(myLightGrayColor);		FrameRect(r);		InsetRect(r, -2, -2);		RGBForeColor(myGrayColor);		FrameRect(r);		InsetRect(r, -2, -2);		RGBForeColor(myDarkGrayColor);		FrameRect(r);		RGBForeColor(myBlackColor);	end;	procedure ______________;	begin	end;{-------------------MAIN EVENT DOING CODE GOES HERE-------------------------}	procedure doUpdate (theWindow: windowPtr; resized: boolean);	begin		if (theWindow = gMainWind) and (gMainWind <> nil) then			begin				RedrawBoard;				DrawStatus;				if (gMoveH <> 0) or (gMoveV <> 0) then					BigMonUpdate;			end		else if (theWindow = gBackWind) and (gBackWind <> nil) then			DrawBackWind;	end;	procedure DoResume;	begin		PeckKillWindow(gBackWind);		DisposeWindow(gBackWind);		gBackWind := nil;		gMainWind := NewCWindow(nil, screenBits.bounds, '', TRUE, 2, WindowPtr(-1), false, 0);		PeckNewWindow(gMainWind);		ShowWindow(gMainWind);		SetPort(gMainWind);		FillRect(gMainWind^.portRect, black);		DoUpdate(gMainWind, FALSE);	end;	procedure DoSuspend;		var			chosenRect: rect;	begin		PeckKillWindow(gMainWind);		disposeWindow(gMainWind);		gMainWind := nil;		chosenRect := screenBits.bounds;		OffsetRect(chosenRect, 10, -10);		chosenRect.top := chosenRect.bottom - 55;		chosenRect.right := chosenRect.left + 55;		gBackWind := NewCWindow(nil, chosenRect, '', TRUE, 2, WindowPtr(-1), false, 0);		PeckNewWindow(gBackWind);		ShowWindow(gBackWind);		SetPort(gBackWind);		DrawBackWind;	end;	procedure DoSuspendRes (event: EventRecord);	begin		if (BAnd(event.Message, resumeFlag) <> 0) then			DoResume		else			DoSuspend;	end;	procedure doMenu (theMenu: menuHandle; theItem: integer);	begin		if theMenu = gFileMenu then			DoFileMenu;		if theMenu = gPlayerMenu then			DoPlayerMenu(theItem);		if theMenu = gGameMenu then			DoGameMenu(theItem);	end;	procedure doMouseDown (theWindow: windowPtr; where: point; when: longint; mods: integer);	begin	end;	procedure doKeyDown (theWindow: windowPtr; theKey: char; mods: integer);	begin	end;	procedure doCloseWindow (theWindow: windowPtr);	begin	end;	procedure DorkyButts (i: integer);		var			dork: boolean;			mySH: stHand;			tempRes: integer;	begin		if i = 1 then			DoAbout(gAboutDial);	end;	procedure doIdle (theWindow: windowPtr);	begin	end;	procedure doKillMenu (theMenu: menuHandle);	begin	end;	procedure doActivate (theWindow: windowPtr);	begin	end;{------------------------- Peck Event Main Routines -------------------------------}	procedure peckInit (howMany: integer);		var			counter: integer;	begin		for counter := 1 to howMany do						{Get enough pointer/heap memory}			moreMasters;		getPort(fstPtr);		curNumWindows := 0;									{Initalize These Variables}		curNumMenus := 0;		wantsToQuit := false;		currentWindow := 0;		for counter := 0 to MaxWind do								{Clear window array}			windows[counter] := nil;		for counter := 0 to MaxMenu do								{Clear menu array}			menus[counter] := nil;		initCursor;												{Arrow Cursor}	end;	procedure peckQuit;	begin		wantsToQuit := true;				{Will halt execution next time main peckEvents gets called}	end;	procedure peckNewWindow (var aWindow: windowPtr);	begin		curNumWindows := curNumWindows + 1;		if curNumWindows > MaxWind then			curNumWindows := MaxWind		else			begin				windows[curNumWindows] := aWindow;				setPort(aWindow);				currentWindow := curNumWindows;			end;	end;	function findAWindow (wFind: windowPtr): integer;		var			winSearchCount: integer;	begin		winSearchCount := 1;		while (windows[winSearchCount] <> wFind) and (winSearchCount < curNumWindows) do			winSearchCount := winSearchCount + 1;		if winSearchCount <= curNumWindows then			findAWindow := winSearchCount		else			findAWindow := 0;	end;	procedure peckKillWindow (var aWindow: windowPtr);		var			recordNum: integer;			wKcounter: integer;	begin		recordNum := findAWindow(aWindow);				{Search array for the window}		doCloseWindow(windows[recordNum]);		if recordNum > 0 then			begin				curNumWindows := curNumWindows - 1;				if curNumWindows > 0 then					begin						for wKcounter := recordNum to curNumWindows do			{Fix List}							windows[wKcounter] := windows[wKcounter + 1];						windows[curNumWindows + 1] := nil;						setPort(windows[1]);					end				else					setPort(fstPtr);													{Whatever it was before}			end;	end;	procedure peckNewMenu (var aMenu: menuHandle; disp: boolean);	begin		curNumMenus := curNumMenus + 1;		if curNumMenus > MaxMenu then			curNumMenus := MaxMenu		else			begin				menus[curNumMenus] := aMenu;				insertMenu(menus[curNumMenus], 0);			end;		if disp then			drawMenuBar;	end;	function findMenu (mFind: menuHandle): integer;		var			menSearchCount: integer;	begin		menSearchCount := 1;		while (menus[menSearchCount] <> mFind) and (menSearchCount <= curNumMenus) do			menSearchCount := menSearchCount + 1;		if menSearchCount <= curNumMenus then			findMenu := menSearchCount		else			findMenu := 0;	end;	function findMenuByID (mFind: integer): integer;		var			msc: integer;	begin		msc := 1;		while (menus[msc]^^.menuID <> mFind) and (msc <= curNumMenus) do			msc := msc + 1;		if msc <= curNumMenus then			findMenuByID := msc		else			findMenuByID := 0;	end;	procedure peckKillMenu (var aMenu: menuHandle);		var			recordNum: integer;			wKcounter: integer;	begin		recordNum := findMenu(aMenu);					{Search array for the menu}		if recordNum > 0 then			begin				doKillMenu(menus[recordNum]);				curNumMenus := curNumMenus - 1;				if curNumMenus > 0 then					begin						for wKcounter := recordNum to curNumMenus do			{Fix List}							menus[wKcounter] := menus[wKcounter + 1];						menus[curNumMenus + 1] := nil;					end;			end;	end;	procedure appleSelect (theItem: integer);	begin		dorkyButts(theItem);	end;	procedure peckApple (aboutName: str255);		var			appleTitle: Str255;			appleID: integer;			dummy: boolean;	begin		appleTitle := ' ';		appleTitle[1] := char($14);		appleID := 1;		hisApple := NewMenu(appleID, appleTitle);		appendMenu(hisApple, aboutName);		appendMenu(hisApple, '(-');		addResMenu(hisApple, 'DRVR');		peckNewMenu(hisApple, false);	end;	procedure doEvent (theEvent: eventRecord);		var			evnWhat: integer;			wCIn: windowPtr;			winNum: integer;			resultCode: integer;			aBrect: rect;			theSize: longint;			menuID, item: integer;			menNum: integer;			wCntr: integer;			evnChar: char;			evnMods: integer;			itemName: str255;			oldPort: grafPtr;			aDummy: integer;			isActive: boolean;			db: boolean;			de: EventRecord;	begin		evnWhat := theEvent.what;		if evnWhat = osEvt then			if BAnd(BRotL(theEvent.message, 8), $FF) = suspendResumeMessage then				DoSuspendRes(theEvent);		if evnWhat = nullEvent then			if currentWindow > 0 then				for wCntr := 1 to curNumWindows do					doIdle(windows[wCntr]);		if evnWhat = mouseDown then			begin				resultCode := findWindow(theEvent.where, wCIn);				if resultCode = inContent then					begin						winNum := findAWindow(wCIn);						if currentWindow <> winNum then							begin											{Make sure it was current wind}								setPort(wCIn);	{Set it to the wind it was clicked}								currentWindow := winNum;					{In!}								selectWindow(wCIn);							end						else							begin								globalToLocal(theEvent.where);								if winNum > 0 then									doMouseDown(windows[winNum], theEvent.where, theEvent.when, theEvent.modifiers);							end;					end;				if resultCode = inDrag then					begin						aBrect := screenBits.bounds;						dragWindow(wCIn, theEvent.where, aBrect);						setPort(wCIn);						selectWindow(wCIn);					end;				if resultCode = inSysWindow then					systemClick(theEvent, wCIn);				if resultCode = inGoAway then					if trackGoAway(wCIn, theEvent.where) then						peckKillWindow(wCIn);				if resultCode = inGrow then					begin						aBrect := screenBits.bounds;						setPort(wCIn);						theSize := growWindow(wCIn, theEvent.where, aBrect);						sizeWindow(wCIn, loWord(theSize), hiWord(theSize), true);						eraseRect(wCIn^.portRect);						drawGrowIcon(wCIn);						winNum := findAWindow(wCIn);						doUpdate(windows[winNum], true)					end;				if (resultCode = inZoomIn) or (resultCode = inZoomOut) then					begin						winNum := findAWindow(wCIn);						setPort(wCIn);						zoomWindow(wCIn, resultCode, true);						eraseRect(wCIn^.portRect);						doUpdate(windows[winNum], true)					end;				if resultCode = inMenuBar then					begin						theSize := menuSelect(theEvent.where);						hiliteMenu(0);						menuID := hiWord(theSize);						if menuID <> 0 then							begin								item := loWord(theSize);								menNum := findMenuByID(menuID);								if (menNum <> 1) then									doMenu(menus[menNum], item)								else if item < 3 then									DorkyButts(item)			{hahahahahaha i called it dorkybutts}								else									begin										getItem(menus[menNum], item, itemName);										aDummy := openDeskAcc(itemName);										setPort(windows[currentWindow]);									end;							end;					end;			end;		if evnWhat = updateEvt then			begin				getPort(oldPort);				setPort(windowPtr(theEvent.message));				beginUpdate(windowPtr(theEvent.message));				winNum := findAWindow(windowPtr(theEvent.message));				if winNum > 0 then					doUpdate(windowPtr(theEvent.message), false);				endUpdate(windowPtr(theEvent.message));				setPort(oldPort);			end;		if evnWhat = activateEvt then			begin				isActive := (BitAnd(theEvent.modifiers, activeFlag) <> 0);				if isActive then					begin						wCIn := windowPtr(theEvent.message);						winNum := findAWindow(wCIn);						setPort(wCIn);						selectWindow(wCIn);						doActivate(wCIn);					end;				currentWindow := winNum;			end;		if evnWhat = keyDown then			begin				evnChar := char(BitAnd(theEvent.message, charCodeMask));				evnMods := theEvent.modifiers;				if BitAnd(evnMods, cmdKey) > 0 then					begin						theSize := menuKey(evnChar);						hiliteMenu(0);						menuID := hiWord(theSize);						if menuID = 0 then							doKeyDown(windows[currentWindow], evnChar, evnMods)						else							begin								item := loWord(theSize);								menNum := findMenuByID(menuID);								doMenu(menus[menNum], item);							end;					end				else					doKeyDown(windows[currentWindow], evnChar, evnMods);			end;	end;	procedure peckMain;		var			isMine: boolean;			allMask: integer;			anEvent: eventRecord;			evnCode: integer;			mykeys: keymap;			e, ignore: boolean;			myOldLNum: integer;			myNewLevName: str255;			c: integer;	begin		gWNEImplemented := (NGetTrapAddress(WNE_TRAP_NUM, ToolTrap) <> NGetTrapAddress(UNIMPLEMENTED_TRAP_NUM, ToolTrap));		while not wantsToQuit do										{Make sure user doesn't wanna leave}			begin			{INFOTRON: MAIN LOOP!}				CleanSounds;				if (isPlaying in gameState) and not (isPaused in gameState) then					Process1Event				else					begin						if gWNEImplemented then							isMine := waitNextEvent(everyEvent, anEvent, 10, nil)						else							begin								systemTask;								isMine := getNextEvent(everyEvent, anEvent);							end;						FixMenuHilites;						if (isMine) or (anEvent.what = nullEvent) then				{Null event returns false}							doEvent(anEvent);						if (isplaying in gamestate) and (isPaused in gameState) then							begin								GetKeys(myKeys);								if not (myKeys[57] = pauseKeyState) then {caps lock NOT in pause position}									begin										gameState := gameState - [isPaused];										HideCursor;										PlaySound(sUnpause);										startGameTime;										lastMoved := tickCount;										HideMenuBar(GMainWind);									end;							end;						if not (isPaused in gameState) then							if loadNextLevel then			{the next level needs to be loaded into memory}								begin									ShowMenuBar(gMainWind);									loadNextLevel := FALSE;									myOldLNum := gPlayer.current;									myNewLevName := ResourceName(myOldLNum + 301, levelResType);									gPlayer.current := myOldLNum + 1;									DrawStatus;									gPlayer.level := myNewLevName;									ignore := LoadBoard(myNewLevName);									if myOldLNum in gPlayer.SkippedLev then										begin											gPlayer.SkippedLev := gPlayer.SkippedLev - [myOldLNum];											gPlayer.numSkipped := gPlayer.numSkipped - 1;										end;									if gPlayer.highLev = myOldLNum then										gPlayer.highLev := gPlayer.highLev + 1;									gPlayer.current := myOldLNum + 1;									SavePlayer;									GotNewBoard;									ShowMenuBar(gMainWind);									DrawMenuBar;								end;					end;			end;	end;	procedure peckHalt;		var			winCountr, menCountr: integer;	begin		for winCountr := 1 to curNumWindows do			disposeWindow(windows[winCountr]);		for menCountr := 1 to curNumMenus do			disposeMenu(menus[menCountr]);	end;{---------- End of Peck Event Routines -----------}begin	InitInfotron;	PeckMain;	PrepareQuit;	PeckHalt;end.
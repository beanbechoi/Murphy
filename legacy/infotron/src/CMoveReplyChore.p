unit CMoveReplyChore;{replys to a CMoveChore after it has finished moving}interface	uses		TCL, backChoresIntf;implementation	procedure CMoveReplyChore.DoOneFrame;		var			what: integer;	begin		what := CInfoApp(gapplication).GetGPane.GetBoard.GetData(xq, yq);		if not (((what >= 998) and (what <= 1009)) or ((what >= 1148) and (what <= 1160)) or ((what >= 650) and (what <= 666)) or (what = 129)) then			Remove		else			begin				if tickCount - lastTime > delayBetween then					begin		{do one animate frame}						DrawAt;						lastTime := tickCount;						FrameDone;						animAt := animAt + 1;					end;				if animAt > finalAnim then					SequenceDone;			end;	end;	procedure CMoveReplyChore.Remove;		var			myTBI: CContMoveChore;	begin		if shouldRemove then			if myReplyTo <> nil then				begin					myTBI := myReplyTo;					myTBI.RemoveOnRespond := TRUE;					myTBI.SubsidiaryDone(xq, yq);		{I'm done.}				end;		inherited Remove;	end;	procedure CMoveReplyChore.SequenceDone;		var			myTBI: CContMoveChore;	begin		if myReplyTo <> nil then			begin				myTBI := myReplyTo;				myTBI.SubsidiaryDone(xq, yq);		{I'm done.}			end;		inherited SequenceDone;	end;	procedure CMoveReplyChore.IMoveReplyChore (whoTo: CContMoveChore; d: integer; oldD: integer; whatIsIt: MovingThingy; x, y: integer);	begin		myReplyTo := whoTo;		IMoveChore(d, oldD, whatIsIt, x, y);		myIdent := kMoveReplyChore;	end;end.
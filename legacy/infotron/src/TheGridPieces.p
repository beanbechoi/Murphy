unit TheGridPieces;{NO OOP}interface	uses		ObjIntf, QDOffscreen, sound, gammapasLibIntf, {}		coloroffscreen, myRGBColors, CInfoDialog, ColorOffScreen, {}		QIST, menubars, QuickDrawProcs, InfoWindows, {}		dataIntf, everything;implementation	procedure CQuark.InitPiece;		var			count: integer;	begin		inherited InitPiece;		IAmA := quark;		for count := 358 downto 351 do			qExplAnim[359 - count] := count;		qExplAnim[9] := 850;	end;	procedure CQuark.Explode (x, y: integer);		var			myAnim: CAnimChore;			mySuicide: CSuicideChore;			myWaitChore: CWaitInsChore;			myArray: AnimArray;			xc, yc: integer;			what: integer;			myObj: CGridPiece;	begin		PlaySound(sQuarkExp);		SetData(x, y, 358);		for xc := x - 1 to x + 1 do			for yc := y - 1 to y + 1 do				begin					what := GetData(xc, yc);					if not (((what >= 750) and (what <= 757)) or ((what >= 1050) and (what <= 1057))) then	{santa}						begin							if (xc <> x) or (yc <> y) then								begin									myObj := GetGridObj(xc, yc);									myObj.explode(xc, yc);								end;							new(myAnim);							myArray := qExplAnim;							myAnim.IAnimChore(myArray, 9, 0, xc, yc);							FudADD(myAnim);{    if (xc <> x) or (yc <> y) then}{    begin}{    end;}							new(myWaitChore);							new(mySuicide);							mySuicide.ISuicideChore(xc, yc);							myWaitChore.IWaitInsChore(mySuicide, 9);							FudADD(myWaitChore);						end;				end;	end;	procedure CScissor.InitPiece;	begin		inherited InitPiece;		IAmA := scissor;	end;	procedure CBlank.InitPiece;	begin		inherited initPiece;		destructable := true;	end;	procedure CBug.InitPiece;	begin		inherited initPiece;		destructable := true;		bugAnim[1] := 300;		bugAnim[2] := 301;		bugAnim[3] := 302;		bugAnim[4] := 303;		bugAnim[5] := 304;		bugAnim[6] := 305;		bugAnim[7] := 128;{    bugAnim[1] := 301;}{    bugAnim[2] := 302;}{    bugAnim[3] := 303;}{    bugAnim[4] := 304;}{    bugAnim[5] := 303;}{    bugAnim[6] := 302;}{    bugAnim[7] := 303;}{    bugAnim[8] := 302;}{    bugAnim[9] := 301;}{    bugAnim[10] := 302;}{    bugAnim[11] := 303;}{    bugAnim[12] := 304;}{    bugAnim[13] := 303;}{    bugAnim[14] := 302;}{    bugAnim[15] := 303;}{    bugAnim[16] := 302;}{    bugAnim[17] := 301;}{    bugAnim[18] := 300;}{    bugAnim[19] := 128;}	end;	function CBug.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := TRUE;		GetMurphyObj.ExplodeTWO(x, y);	end;	procedure CBug.Make (x, y: integer);		var			myChore: CContAnimChore;	begin		New(myChore);		MyChore.IContAnimChore(ARandom(240) + 120, bugAnim, 7, 0, x, y);	{was 19}		FudADD(myChore);	end;	procedure CChip.InitPiece;	begin		inherited InitPiece;		rounded := true;		destructable := true;	end;	function CChip.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := FALSE;	end;	procedure CCircut.initPiece;	begin		inherited initPiece;		destructable := true;	end;	function CExit.WalkOnto (x, y: integer): boolean;		var			aa: AnimArray;			count: integer;			mx, my: integer;	begin		WalkOnto := FALSE;		GetLoc(mx, my);		if NumInfosLeft < 1 then			begin				WalkOnto := FALSE;				for count := 1200 to 1211 do					begin						SetData(mx, my, count);						DrawOne(mx, my);					end;				WonGame;			end;	end;	procedure CExit.initPiece;	begin		inherited initPiece;		destructable := true;	end;	procedure CExplodes.InitPiece;	begin		inherited InitPiece;		destructable := true;		explodes := true;	end;	function CExplodes.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := FALSE;	end;	procedure CExplodes.Explode (x, y: integer);		var			myChore: CAnimChore;			aa: animArray;			xloc, yloc: integer;			tempAnim: AnimArray;			whatIsWhereIAm: integer;			myExplChore: CExplChore;	begin		New(myExplChore);		myExplChore.IExplChore(x, y, explAnim, 11);		FudADD(myExplChore);	end;	procedure CFalls.Fall (x, y: integer);		var			myChore: CFallChore;	begin		new(myChore);		myChore.IFallChore(x, y);		FudADD(myChore);{MoveThere(x, y + 1, FALSE);	{haha}	end;	procedure CFalls.InitPiece;	begin		inherited InitPiece;		Falls := true;	end;	procedure CGreenDisk.InitPiece;	begin		inherited InitPiece;		falls := true;	end;	procedure CGreenDisk.Fall (x, y: integer);		var			myChore: CFallExplChore;	begin		new(myChore);		myChore.IFallExplChore(x, y);		FudADD(myChore);{MoveThere(x, y + 1, FALSE);}	end;	function CGreenDisk.Push (x, y: integer): BOOLEAN;		var			murGT, murCF: integer;			whereTo: point;			iAm: integer;			myChore: CMoveChore;			whatAt: integer;			pushedTo: point;			whatBelow: integer;	begin		murGT := GetLastDir;		murCF := 8 - murGT;		whereTo := LocFromDir(x, y, murGT);		whatAt := GetData(whereTo.h, whereTo.v);{whatBelow := CINfoapp(gapplication).GetGPane.GetBoard.GetData(x, y + 1);}		iAm := GetData(x, y);		Push := FALSE;		if whatAt = 129 then			begin				pUsH := true;				whatAt := GetData(x, y);				SetData(whereTo.h, whereTo.v, whatAt);{    SetData(x, y, 250);}{CInfoApp(gapplication).GetGPane.GetBoard.boardData^^.theBoard[x, y] := 129;}{This has to be done, because if you move the disk, murphy still hasn't moved. If there are things}{above where the disk was, they would fall in between murphy and the disk... which would be}{yucky.}				Draw1(x, y);				Draw1(whereTo.h, whereTo.v);				self.CheckFall(whereTo.h, whereTo.v);			end;	end;	function CGreenDisk.WalkOnto (x, y: integer): BOOLEAN;	begin		WalkOnto := false;		if (GetLastDir = kRight) or (GetLastDir = kLeft) then			WalkOnto := Push(x, y);	end;	function CGridPiece.CanMove: boolean;	begin		CanMove := moves;	end;	procedure CGridPiece.CheckFall (x, y: integer);		var			newWhere: point;	begin		if falls then			begin				newWhere := LocFromDir(x, y, kDown);				if MoveInfo(x, y + 1) then					self.Fall(x, y);			end;	end;	function CGridPiece.CheckRoll (x, y, dir: integer): boolean;		var			below, nextTo, nextDown, nextUp: point;			whatBelow: integer;	begin		below := LocFromDir(x, y, kDown);		nextTo := LocFromDir(x, y, dir);		nextDown.h := nextTo.h;		nextDown.v := below.v;		CheckRoll := FALSE;{provided that I can't fall,}{can I roll off of it?}{is there room to roll to?}{is something falling next to me?}{nope, so go for it!}		if not fallChores^[x, y] then			if not fallChores^[x, y + 1] then				if MoveInfo(nextTo.h, nextTo.v) then					if MoveInfo(nextDown.h, nextDown.v) then						if GetGridObj(below.h, below.v).IsRounded then							begin								CheckRoll := TRUE;								self.Roll(x, y, dir);							end;	end;	procedure CGridPiece.Roll (x, y, dir: integer);	begin	end;	function CGridPiece.Push (x, y: integer): boolean;		var			murGT, murCF: integer;			whereTo: point;			iAm: integer;			whatAt: integer;	begin		murGT := GetLastDir;		murCF := 7 - murGT;		whereTo := LocFromDir(x, y, murGT);		whatAt := GetData(whereTo.h, whereTo.v);		iAm := GetData(x, y);		if whatAt = 129 then			begin				pUsH := true;				sEtDaTa(x, y, 129);				SetData(whereTo.h, whereTo.v, iAm);				self.CheckFall(x, y);			end		else			Push := false;	end;	procedure CGridPiece.Move (x, y: integer);	begin	end;	procedure CGridPiece.Destroy (x, y: integer);		var			myChore: CAnimChore;			aa: animArray;			xloc, yloc: integer;			count: integer;	begin		if destructable then			begin				New(myChore);				myChore.IAnimChore(explAnim, 11, 0, x, y);				FudADD(myChore);			end;	end;	procedure CGridPiece.Explode (x, y: integer);	begin	end;	function CGridPiece.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := TRUE;	end;	function CGridPiece.CanExplode: boolean;	begin		CanExplode := explodes;	end;	procedure CGridPiece.InitPiece;			{Call this after creating the CGridPiece}		var			c: integer;	begin							{Make sure you call this BEFORE initing yourself!}		destructable := false;		rounded := false;		falls := false;		explodes := false;		moves := false;		for c := 0 to 9 do			explAnim[c + 1] := 600 + c;		explAnim[11] := 129;	end;	function CGridPiece.IsDestructable: boolean;	begin		IsDestructable := destructable;	end;	procedure CGridPiece.Fall (x, y: integer);	begin	end;	function CGridPiece.IsRounded: boolean;	begin		IsRounded := rounded;	end;	function CGridPiece.CanFall: boolean;	begin		CanFall := falls;	end;	function CHardware.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := FALSE;	end;	procedure CInfotron.InitPiece;	begin		inherited InitPiece;		rounded := true;		destructable := true;	end;	procedure CInfotron.Roll (x, y, dir: integer);		var			fallDir: integer;			myChore: CMoveChore;			whereTo: point;			what: integer;	begin		if dir = kLeft then			begin{    falldir := kDownLeft;}				MoveThere(x - 1, y, FALSE);				MoveThere(x - 1, y + 1, FALSE);			end		else			begin{    fallDir := kDownRight;}				MoveThere(x + 1, y, FALSE);				MoveThere(x + 1, y + 1, FALSE);			end;		new(myChore);		myChore.IMoveChore(dir, dir, infotron, x, y);		FudADD(myChore);	end;	function CInfotron.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := true;		GotInfotron;	end;	function CMoves.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := TRUE;		GetMurphyObj.KillMurphy;	end;	procedure CMoves.DoMove (oldx, oldy, newx, newy, olddir, newdir: integer);	begin	end;	procedure CMoves.FigureFacing (x, y: integer);		var			whic: integer;	begin		case IAmA of			scissor: 				begin					whic := WhichScissor(x, y);					facing := ScissorDir(whic);				end;			quark: 				begin					whic := WhichQuark(x, y);					facing := QuarkDir(whic);				end;		end;	end;	procedure CMoves.Move (x, y: integer);		var			newFacing: integer;			dirLeft, dirRight: integer;			locS, locL, locR: point;			whatS, whatL, whatR: integer;	begin		FigureFacing(x, y);		dirLeft := (facing + 6) mod 8;		dirRight := (facing + 2) mod 8;		locS := LocFromDir(x, y, facing);		locL := LocFromDir(x, y, dirLeft);		locR := LocFromDir(x, y, dirRight);		whatS := GetData(locS.h, locS.v);		whatL := GetData(locL.h, locL.v);		whatR := GetData(locR.h, locR.v);		if ((whatL >= 499) and (whatL <= 511)) or ((whatL >= 139) and (whatL <= 214)) or ((whatL >= 1200) and (whatL <= 1210)) then			GetMurphyObj.killMurphy		else if whatL = 129 then			DoMove(x, y, locL.h, locL.v, facing, dirLeft)		else if ((whatS >= 499) and (whatS <= 511)) or ((whatS >= 139) and (whatS <= 214)) or ((whatS >= 1200) and (whatS <= 1210)) then			GetMurphyObj.killMurphy		else if whatS = 129 then			DoMove(x, y, locS.h, locS.v, facing, facing)		else if ((whatR >= 499) and (whatR <= 511)) or ((whatR >= 139) and (whatR <= 214)) or ((whatR >= 1200) and (whatR <= 1210)) then			GetMurphyObj.killMurphy		else if whatR = 129 then			DoMove(x, y, locR.h, locR.v, facing, dirRight)		else			DoMove(x, y, x, y, facing, kNoMove);	end;	procedure CMoves.InitPiece;	begin		inherited InitPiece;		moves := true;	end;	procedure CMurphyObj.KillMurphy;		var			mx, my: integer;			dorkyt: longint;	begin		if not gAARDVARK_PLATYPUSS_WOMBAT then			begin				GetLoc(mx, my);				inherited Explode(mx, my);				SetData(mx, my, 145);				DrawOne(mx, my);				Delay(9, dorkyt);				gAARDVARK_PLATYPUSS_WOMBAT := TRUE;				KillMurphyMain;			end;	end;	procedure CMurphyObj.Destroy (x, y: integer);	begin		if not gAardvark_platypuss_wombat then			KillMurphy;	end;	procedure CMurphyObj.ExplodeTWO (x, y: integer);		var			mx, my: integer;			dorkyt: longint;	begin		if not gAARDVARK_PLATYPUSS_WOMBAT then			begin				GetLoc(mx, my);				SetData(mx, my, 129);				DrawOne(mx, my);				mx := x;				my := y;				inherited Explode(mx, my);				SetData(mx, my, 147);				DrawOne(mx, my);				Delay(12, dorkyt);				gAARDVARK_PLATYPUSS_WOMBAT := TRUE;				KillMurphyMain;			end;	end;	procedure CMurphyObj.Explode (x, y: integer);	begin		if not gAARDVARK_PLATYPUSS_WOMBAT then			KillMurphy;	end;	procedure CPortal.InitPiece;	begin		inherited InitPiece;		destructable := true;	end;	function CPortal.WalkOnto (x, y: integer): boolean;		var			murFDir, murTDir: integer;			otherSide: point;			myIcon: integer;	begin		murFDir := GetLastDir;		murTDir := 8 - murFDir;		otherSide := LocFromDir(x, y, murFDir);		WalkOnto := FALSE;	{HAAHAHAHAHAHAHAHAHAHAHAHAH I AM INSANE}{AND I WILL TAKE OVER THE WORLD HAHAHAHAHAHAHHAHAA}{AND YOU WILL BE UNDER MY POWER HAHAHAHAHAHAHHA}		if GetData(otherSide.h, otherSide.v) = 129 then			begin				myIcon := GetData(x, y);				if (myIcon = 132) then					WalkOnto := TRUE				else if (myIcon = 950) and ((murFDir = kUp) or (murFDir = kDown)) then					WalkOnto := TRUE				else if (myIcon = 952) and ((murFDir = kRight) or (murFDir = kLeft)) then					WalkOnto := TRUE				else if (myIcon <> 950) and (myIcon <> 952) and (myIcon <> 132) then					WalkOnto := (murFDir = (myIcon mod 8));			end;	end;	procedure CRedDisk.InitPiece;	begin		inherited InitPiece;		explodes := FALSE;	end;	function CRedDisk.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := TRUE;		GotRedDisk;{PlaySound?}	end;	procedure CTerminal.InitPiece;		var			c: integer;	begin		inherited InitPiece;		destructable := true;		for c := 1 to 11 do			termAnim[c] := 549 + c;	end;	procedure CTerminal.Make (x, y: integer);		var			myChore: CContAnimChore;	begin		new(myChore);		myChore.IContAnimChore(0, termAnim, 11, 0, x, y);		FudADD(myChore);	end;	function CTerminal.WalkOnto (x, y: integer): boolean;		var			sizeX, sizeY: integer;			cx, cy: integer;	begin		WalkOnto := FALSE;		GetSize(sizeX, sizeY);		for cx := 1 to sizeX do			for cy := 1 to sizeY do				if GetData(cx, cy) = 134 then					GetGridObj(cx, cy).Explode(cx, cy);	end;	procedure CYellowDisk.InitPiece;	begin		inherited InitPiece;		explodes := FALSE;	end;	function CYellowDisk.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := Push(x, y);	end;	function CYellowDisk.Push (x, y: integer): boolean;		var			murphyGoingTo: integer;			mx, my: integer;			afterX, afterY: integer;			whatThere: integer;			whatMe: integer;	begin		murphyGoingTo := GetLastDir;		GetLoc(mx, my);		afterX := LocFromDir(x, y, murphyGoingTo).h;		afterY := LocFromDir(x, y, murphyGoingTo).v;		whatThere := GetData(afterX, afterY);		whatMe := GetData(x, y);		Push := FALSE;		if whatThere = 129 then			begin				Push := TRUE;{SetData(x, y, 250);}				SetData(afterX, afterY, whatMe);				Draw1(x, y);				Draw1(afterX, afterY);			end;	end;	function CZonk.Push (x, y: integer): boolean;		var			murGT, murCF: integer;			whereTo: point;			iAm: integer;			myChore: CMoveChore;			whatAt: integer;			pushedTo: point;			whatBelow: integer;			mySuicide: CSuicideChore;			myWaitChore: CWaitInsChore;			myRollAfter: CRollAfterChore;			myChore2: CFallRollChore;			newWhere: point;	begin		murGT := GetLastDir;		murCF := 8 - murGT;		whereTo := LocFromDir(x, y, murGT);		whatAt := GetData(whereTo.h, whereTo.v);{whatBelow := GetData(x, y + 1);}		iAm := GetData(x, y);		Push := FALSE;		if whatAt = 129 then			if fallChores^[x, y] then				begin					GetMurphyObj.killMurphy;					pUsH := FALSE;				end			else				begin					pUsH := true;					whatAt := GetData(x, y);					if murGT = kRight then						begin							whatAt := whatAt + 1;							if whatAt = 704 then								whatAt := 700;						end					else						begin							whatAt := whatAt - 1;							if whatAt = 699 then								whatAt := 703;						end;					SetData(whereTo.h, whereTo.v, whatAt);{    SetData(x, y, 250);}{    CInfoApp(gapplication).GetGPane.GetBoard.boardData^^.theBoard[x, y] := 129; {MUST be done this way}					Draw1(x, y);			{We can explain to you if you wish.}					Draw1(whereTo.h, whereTo.v);{    self.CheckFall(whereTo.h, whereTo.v);}					if falls then						begin							newWhere := LocFromDir(whereTo.h, whereTo.v, kDown);							if MoveInfo(whereTo.h, whereTo.v + 1) then								begin									new(myChore2);									myChore2.IFallChore(whereTo.h, whereTo.v, murGT);									FudADD(myChore2);								end;						end;					new(myWaitChore);{    new(mySuicide);}{    mySuicide.ISuicideChore(whereTo.h, whereTo.v);}{    myWaitChore.IWaitInsChore(mySuicide, 3);}					new(myRollAfter);					myRollAfter.IRollAfterChore(whereTo.h, whereTo.v, murGT);					myWaitChore.IWaitInsChore(myRollAfter, 3);					FudADD(myWaitChore);				end;	end;	procedure CZonk.InitPiece;	begin		inherited InitPiece;		rounded := true;		destructable := true;	end;	procedure CZonk.Roll (x, y, dir: integer);		var			fallDir: integer;			myChore: CMoveChore;			whereTo: point;			what: integer;	begin		if dir = kLeft then			begin{    falldir := kDownLeft;}				MoveThere(x - 1, y, FALSE);				MoveThere(x - 1, y + 1, FALSE);			end		else			begin{    fallDir := kDownRight;}				MoveThere(x + 1, y, FALSE);				MoveThere(x + 1, y + 1, FALSE);			end;		new(myChore);		myChore.IMoveChore(dir, dir, boulder, x, y);		FudADD(myChore);	end;	function CZonk.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := false;		if (GetLastDir = kRight) or (GetLastDir = kLeft) then			WalkOnto := Push(x, y);	end;end.
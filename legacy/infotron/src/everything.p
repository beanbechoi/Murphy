unit Everything;{NO OOP}{there is one easy way to get around the problems that we are having.}{And that is, of course, to put everything HERE...}interface	uses		ObjIntf, QDOffscreen, sound, gammapasLibIntf, {}		coloroffscreen, myRGBColors, CInfoDialog, ColorOffScreen, {}		QIST, menubars, QuickDrawProcs, InfoWindows, {}		dataIntf;{These declarations come from BadScopeFixes.p}	function GetMurphyObj: CMurphyObj;		{What's this?}	procedure EndLevel;		{safely end the level.}	procedure FudADD (c: CChore);	procedure FudRID (c: CChore);	procedure TheyWonTheLevel;	procedure MoveThere (x, y: integer; b: boolean);	function MoveInfo (x, y: integer): boolean;{These declarations come from BoardStuff.p}	const		statHeight = 4;	var		gIconLocs: array[128..1211] of rect;		gIconOff: GWorldPtr;		statRect: rect;		inRect: rect;		stP: GrafPtr;	function PlotIconID (TheRect: Rect; Align: integer; Transform: integer; TheResID: INTEGER): OSErr;		{keep same format}	procedure InitalizeGraphics;	procedure moveup;	procedure movedown;	procedure moveleft;	procedure moveright;{BoardStuff.p declarations}	procedure SetData (x, y, what: integer);	procedure Draw1 (x, y: integer);	procedure DrawOne (x, y: integer);	procedure DrawOffset (x, y: integer; offX, offY: integer; icn: integer);	function GetData (x, y: integer): integer;	function WhichScissor (x, y: integer): integer;	function WhichQuark (x, y: integer): integer;	procedure MovedScissor (which, dir: integer);	procedure MovedQuark (which, dir: integer);	function ScissorDir (which: integer): integer;	function QuarkDir (which: integer): integer;	procedure getSize (var x, y: integer);	procedure killLevel;	procedure KillData;		{killdata=kill level. sue me.}	procedure killBoard;	procedure redrawBoard;	function loadBoard (name: str255): boolean;	procedure GotNewBoard;	function PtToInt (x, y: integer): integer;							{transfer a point to an integer}	function IntToPt (i: integer): point;									{vv}	function MurphyStart: point;	procedure SetUpOffScreen;	procedure DrawOffscreen;	procedure MakeSciStuff;	procedure FixSize;	function ScissorCount: integer;			{get info about the board}	function QuarkCount: integer;	function InfoCount: integer;	function BugCount: integer;	function ScissorLoc (which: integer): point;							{where is scissor #x}	function QuarkLoc (which: integer): point;							{where is scissor #x}{StatusStuff.p}	procedure drawStatus;	procedure drawTBoxes (anyWay: boolean);	procedure drawName;	procedure drawLevStats;	procedure drawGameStats;{Players.p}	procedure AddToTime (t: longint);	procedure GetTheKeys;	procedure savePlayer;	procedure killPlayer;	procedure loadPlayer;	procedure OpenPlayer;	function getLevelName: str255;	function getName: str255;{Murphys.p}	procedure GetLoc (var x2, y2: integer);	procedure SetLoc (x2, y2: integer);	procedure KillMurphyMain;	function GetGameTime: longint;	procedure WonGame;	function NumInfosLeft: integer;	function GetLastDir: integer;	procedure gotInfotron;	procedure gotRedDisk;	function UseRedDisk: boolean;		{TRUE if I had one}	procedure stopTime;	procedure startGameTime;	procedure init;	procedure setLastDir (newDir: integer);{AppStuff.p}	procedure ClearSuicides;	{clear the hasSuicides array}	procedure DoKillChores;	{actually kill the chores. NEVER call this!!!}	procedure MakeGObjs;	function GetGridObj (x, y: integer): CGridPiece;	function GetNextRollDir: integer;	function GetInfoStatus: InfoStatus;	procedure SetInfoStatus (s: InfoStatus);	procedure KillChores;	procedure ToggleRollDir;	function ARandom (upper: integer): integer;	function LocFromDir (x, y, d: integer): point;	procedure InitChoreLists;	procedure StartNewLevel;implementation{These declarations come from BadScopeFixes.p}	procedure ___BadScopeFixes;	begin	end;	procedure StandardDialogDo (num: integer);		var			tDlog: DialogPtr;			itemHit: integer;	begin		tDlog := GetNewDialog(num, nil, WindowPtr(-1));		ShowWindow(tDlog);		SetPort(tDlog);		ModalDialog(nil, itemHit);		DisposDialog(tDlog);	end;	procedure GenericError (s: str255);	begin		Sysbeep(10);		ParamText(s, '', '', '');		StandardDialogDo(500);		ExitToShell;	end;	procedure TheyWonTheLevel;	begin		loadNextLevel := TRUE;	end;	function GetMurphyObj: CMurphyObj;		{What's this?}	begin		GetMurphyObj := CMurphyObj(gos[16]);	end;	procedure EndLevel;		{safely end the level.}		var			myWChore: CWaitTimeChore;			myKChore: CKillGameChore;	begin		gameState := gameState + [freezeMurphy];		new(myWChore);		new(myKChore);		myKChore.IKillGameChore;		myWChore.IWaitTimeChore(myKChore, 4);		FudADD(myWChore);	end;	procedure FudADD (c: CChore);		var			mi: integer;	begin		if c <> nil then			begin				mi := CInfoChore(c).myIdent;				if (mi = kFallChore) or (mi = kFallExplChore) or (mi = kMoveChore) then					if not fallchores^[CInfoChore(c).xq, CInfoChore(c).yq] then						begin							tbaLen := tbaLen + 1;							toBeAdded[tbaLen] := c;							fallchores^[CInfoChore(c).xq, CInfoChore(c).yq] := TRUE;						end					else						DisposeHandle(handle(c))				else					begin						tbaLen := tbaLen + 1;						toBeAdded[tbaLen] := c;					end;			end;	end;	procedure FudRID (c: CChore);		var			mi: integer;	begin		if c <> nil then			begin				mi := CInfoChore(c).myIdent;				if (mi = kFallChore) or (mi = kFallExplChore) or (mi = kMoveChore) then					fallChores^[CInfoChore(c).xq, CInfoChore(c).yq] := FALSE;				tbrLen := tbrLen + 1;				toBeRidded[tbrLen] := c;			end;	end;	procedure MoveThere (x, y: integer; b: boolean);	begin		fallingInfo^[x, y] := b;	end;	function MoveInfo (x, y: integer): boolean;	begin		MoveInfo := fallingInfo^[x, y];	end;{These declarations come from BoardStuff.p}	procedure ___BoardStuff;	begin	end;	procedure MoveDown;		var			row, col: integer;			err: oserr;			temprect: rect;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;			icnID: integer;			uninitalizedRectangle: rect;	begin		getGWorld(oldGW, oldGD);		ignore := lockPixels(myOff^.portPixMap);		setGWorld(myOff, nil);		ForeColor(blackColor);		BackColor(whiteColor);		CopyBits(grafptr(myOff)^.portbits, grafptr(myOff)^.portbits, myOff^.portRect, pOffSetRect(myOff^.portRect, 0, -32), srcCopy, nil);		tempRect.bottom := 480 - 64 + 16;		tempRect.top := 480 - 64 - 16;		tempRect.left := -16;		tempRect.right := 16;		row := upperLeft.v + 14;		for col := 0 to 20 do			begin				icnID := getData(Upperleft.h + col, row);				err := PlotIconID(tempRect, 0, 0, icnID);				offsetRect(tempRect, 32, 0);			end;		UpperLeft.v := UpperLeft.v + 1;		setGWorld(oldGW, oldGD);		UnlockPixels(myOff^.PortPixMap);		RedrawBoard;	end;	procedure MoveUp;		var			row, col: integer;			err: oserr;			temprect: rect;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;			icnID: integer;			uninitalizedRectangle: rect;	begin		getGWorld(oldGW, oldGD);		ignore := lockPixels(myOff^.portPixMap);		setGWorld(myOff, nil);		CopyBits(grafptr(myOff)^.portbits, grafptr(myOff)^.portbits, myOff^.portRect, pOffSetRect(myOff^.portRect, 0, 32), srcCopy, nil);		tempRect.top := -16;		tempRect.bottom := 16;		tempRect.left := -16;		tempRect.right := 16;		row := upperLeft.v - 1;		for col := 0 to 20 do			begin				icnID := getData(Upperleft.h + col, row);				err := PlotIconID(tempRect, 0, 0, icnID);				offsetRect(tempRect, 32, 0);			end;		UpperLeft.v := UpperLeft.v - 1;		setGWorld(oldGW, oldGD);		UnlockPixels(myOff^.PortPixMap);		RedrawBoard;	end;	procedure MoveRight;		var			row, col: integer;			err: oserr;			temprect: rect;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;			icnID: integer;			uninitalizedRectangle, r, r2: rect;			c: integer;	begin		getGWorld(oldGW, oldGD);		ignore := lockPixels(myOff^.portPixMap);		setGWorld(myOff, nil);		CopyBits(grafptr(myOff)^.portbits, grafptr(myOff)^.portbits, myOff^.portRect, pOffSetRect(myOff^.portRect, -32, 0), srcCopy, nil);		tempRect.top := -16;		tempRect.bottom := 16;		tempRect.left := 640 - 16;		tempRect.right := 640 + 16;		col := upperLeft.h + 21;		for row := 0 to 14 do			begin				icnID := getData(col, row + upperLeft.v);				err := PlotIconID(tempRect, 0, 0, icnID);				offsetRect(tempRect, 0, 32);			end;		UpperLeft.h := UpperLeft.h + 1;		setGWorld(oldGW, oldGD);		UnlockPixels(myOff^.PortPixMap);		RedrawBoard;	end;	procedure MoveLeft;		var			row, col: integer;			err: oserr;			temprect: rect;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;			icnID: integer;			uninitalizedRectangle: rect;	begin		getGWorld(oldGW, oldGD);		ignore := lockPixels(myOff^.portPixMap);		setGWorld(myOff, nil);		CopyBits(grafptr(myOff)^.portbits, grafptr(myOff)^.portbits, myOff^.portRect, pOffSetRect(myOff^.portRect, 32, 0), srcCopy, nil);		tempRect.top := -16;		tempRect.bottom := 16;		tempRect.left := -16;		tempRect.right := 16;		col := upperLeft.h - 1;		for row := 0 to 14 do			begin				icnID := getData(col, row + upperLeft.v);				err := PlotIconID(tempRect, 0, 0, icnID);				offsetRect(tempRect, 0, 32);			end;		UpperLeft.h := UpperLeft.h - 1;		setGWorld(oldGW, oldGD);		UnlockPixels(myOff^.PortPixMap);		RedrawBoard;	end;	function ScissorCount: integer;			{get info about the board}	begin		ScissorCount := boardData^^.numScissors;	end;	function QuarkCount: integer;	begin		QuarkCount := boardData^^.numQuarks;	end;	function InfoCount: integer;	begin		InfoCount := boardData^^.numInfotrons;	end;	function BugCount: integer;	begin		BugCount := boardData^^.numBugs;	end;	function PlotOld (TheRect: Rect; Align: integer; Transform: integer; TheResID: INTEGER): OSErr;	inline			{the old plot routine}		$303C, $0500, $ABC9;	procedure CreateStatus (stGW: GWorldPtr; stGD: GDHandle; count: integer; maxCount: integer);		var			oldGW: GWorldPtr;			oldGD: GDHandle;			p: GrafPtr;			pht, pwt: integer;			swt: integer;	begin		GetGWorld(oldGW, oldGD);		SetGWorld(stGW, stGD);		GetPort(stP);		pht := (stP^.portRect.bottom - stP^.portRect.top);		pwt := (stP^.portRect.right - stP^.portRect.left);		statRect.top := pht div 2 + stP^.portRect.top;		statRect.bottom := statRect.top;		statRect.left := pwt div 2 + stP^.portRect.left;		statRect.right := statRect.left;		inRect := statRect;		InsetRect(statRect, -maxCount - 2, -statHeight - 2);		InsetRect(inRect, -maxCount, -statHeight);		inRect.right := inRect.left;		RGBForeColor(myBlueColor);		FrameRect(statRect);{RGBForeColor(myRedColor);}		FillRect(inRect, black);		RGBForeColor(myRedColor);		TextSize(9);		TextMode(srcOr);		swt := StringWidth('Loading Graphics...');		MoveTo(stP^.portRect.left + (pwt div 2 - swt div 2), statRect.top - 4);		DrawString('Loading Graphics...');		TextSize(12);		RGBForeColor(myBlackColor);		SetGWorld(oldGW, oldGD);	end;	procedure UpdateStatus (stGW: GWorldPtr; stGD: GDHandle);		var			oldGW: GWorldPtr;			oldGD: GDHandle;			op: GrafPtr;	begin		GetGWorld(oldGW, oldGD);		GetPort(op);		SetGWorld(stGW, stGD);		SetPort(stp);		RGBForeColor(myRedColor);		inRect.right := inRect.right + 1;		if inRect.right > statRect.right - 2 then			inrect.right := statRect.right - 2;		FillRect(inRect, black);		RGBForeColor(myBlackColor);		SetPort(op);		SetGWorld(oldGW, oldGD);	end;	procedure SetUpIcons;		var			count: integer;			oldGD: GDHandle;			oldGW: GWorldPtr;			numAc: integer;			r: rect;			myIcn: handle;			err: OSErr;			ignore: boolean;			invalidR: rect;	begin		SetRect(r, 0, 0, 482, 386);		gIconOff := MakeGWorld(r);		SetRect(invalidR, -1, -1, -1, -1);		r.top := 1;		r.left := 1;		r.right := 1 + 32;		r.bottom := 1 + 32;		GetGWorld(oldGW, oldGD);		SetGWorld(gIconOff, nil);		CreateStatus(oldGW, oldGD, 0, 90);		FadeFromBlack(2);		ignore := LockPixels(gIconOff^.PortPixMap);		numAc := 0;		for count := 128 to 1211 do			begin				if (count / 6) = trunc(count / 6) then					UpdateStatus(oldGW, oldGD);				myIcn := GetResource('icl8', count);				if (myIcn <> nil) and (resError = noErr) then					begin						gIconLocs[count] := r;						err := PlotOld(r, 0, 0, count);						ReleaseResource(myIcn);						OffsetRect(r, 32, 0);						numAc := numAc + 1;						if numAc = 15 then							begin								r.left := 1;								r.right := 1 + 32;								numAc := 0;								OffsetRect(r, 0, 32);							end;					end				else					gIconLocs[count] := invalidR;				myIcn := nil;			end;		UnlockPixels(gIconOff^.portPixMap);		SetGWorld(oldGW, oldGD);		FadeToBlack(2);	end;	function PlotIconID (TheRect: Rect; Align: integer; Transform: integer; TheResID: INTEGER): OSErr;		{keep same format}		var			gp: GrafPtr;	begin		GetPort(gp);		CopyWorldBits2(gIconOff, gp, gIconLocs[theResID], theRect);	end;	procedure InitalizeGraphics;	begin		SetupIcons;		setUpOffScreen;		FillRect(gMainWind^.portRect, black);	end;	procedure KillLevel;	begin		KillData;	end;	procedure DrawOffscreen;		var			x, y, icnID: integer;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;			tempRect: rect;			err: OSErr;			r, r2: rect;	begin		getGWorld(oldGW, oldGD);		ignore := lockPixels(myOff^.portPixMap);		setGWorld(myOff, nil);		tempRect.top := -16;		tempRect.bottom := -16 + 32;		for y := 0 to 14 do			begin				tempRect.left := -16;				tempRect.right := -16 + 32;				for x := 0 to 20 do					begin						icnID := GetData(x + upperLeft.h, y + upperLeft.v);						if icnID = 300 then							icnId := 128;						err := PlotIconID(tempRect, 0, 0, icnID);						offsetRect(tempRect, 32, 0);					end;				offsetRect(tempRect, 0, 32);			end;		setGWorld(oldGW, oldGD);		UnlockPixels(myOff^.PortPixMap);		r.top := 0;		r.bottom := r.top + 480 - 61;		r.left := 0;		r.right := r.left + 640;		r2 := r;		OffsetRect(r2, gMoveH, gMoveV);		foreColor(blackcolor);		backColor(whitecolor);		copyWorldBits2(myOff, gMainWind, r, r2);	end;	procedure GotNewBoard;		var			MurphLoc: point;			temprect: rect;			appState: InfoStatus;	begin		GetSize(LowerRight.h, LowerRight.v);		MurphLoc := MurphyStart;		SetLoc(murphLoc.h, murphLoc.v);		UpperLeft.v := MurphLoc.v - 7;		UpperLeft.h := MurphLoc.h - 10;		if (LowerRight.h - MurphLoc.h) < 10 then			UpperLeft.h := LowerRight.h - 20;		if (LowerRIght.v - MurphLoc.v) < 7 then			UpperLeft.v := LowerRight.v - 13;		if UpperLeft.h < 1 then			UpperLeft.h := 1;		if UpperLeft.v < 1 then			UpperLeft.v := 1;		DrawOffScreen;	end;	procedure SetUpOffScreen;	begin		OffRect.top := -32;		offrect.left := -32;		offrect.right := 640 + 32;		offrect.bottom := 480 - 61 + 32;		myOff := MakeGWorld(OffRect);	end;	function NewBoardDataStructure: bap;		var			qd: bap;			x, y: integer;	begin		qd := bap(NewHandleClear(sizeOf(LevelRecord)));		if (qd <> nil) and (memError = noErr) then			begin				MoveHHi(handle(qd));				HLock(handle(qd));				qd^^.sizeX := 120;				qd^^.sizeY := 120;				for x := 1 to qd^^.sizeX do					for y := 1 to qd^^.sizeY do{$PUSH}{$R-}						qd^^.theBoard[x, y] := kBaseNum;{$POP}			end		else			GenericError('Could not allocate board data; you might be out of memory. Err#nwbddase1');		NewBoardDataStructure := qd;	end;	function DecompressBoard (c: bcp; var b: bap): boolean;				{FALSE if it failed}		var			atx, aty, atbn: integer;			q: integer;			lastVal: integer;			cnt: integer;	begin		b := NewBoardDataStructure;		b^^.name := c^^.name;		b^^.sizeX := c^^.sizeX;		b^^.sizeY := c^^.sizeY;		b^^.murphy := c^^.murphy;		b^^.term := c^^.term;		b^^.numScissors := c^^.numScissors;		b^^.numQuarks := c^^.numQuarks;		b^^.numInfotrons := c^^.numInfotrons;		b^^.numBugs := c^^.numBugs;		atx := 1;		aty := 1;		atbn := 0;{$PUSH}{$R-}		for cnt := 1 to c^^.numScissors do			begin				b^^.scissors[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;		for cnt := 1 to c^^.numQuarks do			begin				b^^.quarks[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;		for cnt := 1 to c^^.numBugs do			begin				b^^.bugs[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;{$R+}		lastVal := 128;		while (atbn < c^^.numComp) do			begin				atbn := atbn + 1;{$PUSH}{$R-}				if c^^.theBoard[atbn] < 0 then					for q := 1 to (-c^^.theBoard[atbn] - 1) do{$R+}						begin							b^^.theBoard[atx, aty] := lastVal;							atx := atx + 1;							if atx > c^^.sizeX then								begin									aty := aty + 1;									atx := 1;								end;						end				else					begin{$PUSH}{$R-}						b^^.theBoard[atx, aty] := c^^.theBoard[atbn];						lastVal := c^^.theBoard[atbn];{$R+}						atx := atx + 1;						if atx > c^^.sizeX then							begin								aty := aty + 1;								atx := 1;							end;					end;			end;		DecompressBoard := TRUE;		{it WILL work, darn it!}	end;	function LoadCompBoard (name: str255; var compData: bcp): boolean;		var			i: Handle;			com: bcp;			err: OSErr;			worked: boolean;			oldRes: integer;	begin{    KillData;}		oldRes := CurResFile;		UseResFile(gMyResFile);		i := GetNamedResource(levelResType, name);		worked := (i <> nil) and (ResError = noErr);		if worked then			begin				DetachResource(i);				com := bcp(i);				MoveHHi(handle(com));				HLock(handle(com));				compData := com;			end;		if not worked then			GenericError('Error: ldcpbd1');		LoadCompBoard := worked;		UseResFile(oldRes);	end;	function loadBoard (name: str255): boolean;		var			worked: boolean;			appStat: InfoStatus;			someData: bap;			dorky: rect;			e: boolean;			c: integer;			tempComp: bcp;	begin		KillData;{CInfoApp(gapplication).KillChores;}		worked := LoadCompBoard(name, tempComp);		if worked then			begin				worked := DecompressBoard(tempComp, someData);				HUnlock(handle(tempComp));				DisposeHandle(handle(tempComp));				MoveHHi(handle(someData));				HLock(handle(someData));				boardData := someData;				if boardData <> nil then					begin						FixSize;						MakeSciStuff;					end				else					GenericError('Error: ldbd#1');				gameState := gameState + [hasLevel]			end;		if (boardData <> nil) and worked then			begin				GotNewBoard;				DrawStatus;				SetLoc(murphyStart.h, murphyStart.v);			end		else			GenericError('Error: ldbd#2');		LoadBoard := worked;	end;	procedure doFallArrayChecking;		var			x, y: integer;			r: rect;	begin		for x := upperLeft.h to upperLeft.h + 21 do			for y := upperLeft.v to upperLeft.v + 14 do				begin					RGBForeColor(myBlueColor);					r.left := ((x - upperLeft.h - 1) * 32) + 26;					r.top := ((y - upperLeft.v - 1) * 32) + 26;					r.bottom := r.top + 4;					r.right := r.left + 4;					if FallingInfo^[x, y] then						fillRect(r, black);					RGBForeColor(myRedColor);					OffsetRect(r, 0, 4);					if FallChores^[x, y] then						fillRect(r, black);				end;		foreColor(blackColor);	end;	procedure redrawBoard;		var			r, r2: rect;	begin		r.top := 0;		r.bottom := screenbits.bounds.bottom - (480 - 419);		r.left := 0;		r.right := screenbits.bounds.right;		if hasLevel in gameState then			begin				r.top := 0;				r.bottom := r.top + 480 - 61;				r.left := 0;				r.right := r.left + 640;				r2 := r;				OffsetRect(r2, gMoveH, gMoveV);				foreColor(blackcolor);				backColor(whitecolor);				copyWorldBits2(myOff, gMainWind, r, r2);{    doFallArrayChecking;}			end		else			begin				ForeColor(blackCOlor);	{WWHAODHUSA}				OffsetRect(r, gMoveH, gMoveV);				FillRect(r, black);			end;	end;	procedure KillData;	begin		if boardData <> nil then			begin				HUnlock(handle(boardData));				DisposeHandle(handle(boardData));				gameState := gameState - [hasLevel];				boardData := nil;			end;	end;	function MurphyStart: point;	begin		MurphyStart := IntToPt(boardData^^.murphy);	end;	procedure killBoard;	begin		KillData;	end;	function ScissorDir (which: integer): integer;	begin		scissorDir := scissorData[which].dir;	end;	procedure getSize (var x, y: integer);	begin		x := boardBounds.h;		y := boardBounds.v;	end;	function QuarkDir (which: integer): integer;	begin		QuarkDir := quarkData[which].dir;	end;	procedure SetData (x, y, what: integer);		procedure FallChecking (x, y: integer);			var				o: CGridPiece;		begin			o := GetGridObj(x, y);			o.CheckFall(x, y);		end;		procedure RollRight (x, y: integer);			var				o: CGridPiece;				dork: boolean;		begin			o := GetGridObj(x, y);			dork := o.CheckRoll(x, y, kRight);		end;		procedure RollLeft (x, y: integer);			var				o: CGridPiece;				dork: boolean;		begin			o := GetGridObj(x, y);			dork := o.CheckRoll(x, y, kLeft);		end;	begin		if boardData <> nil then			begin				boardData^^.theBoard[x, y] := what;				if what = 129 then					begin						MoveThere(x, y, TRUE);						FallChecking(x, y - 1);						RollRight(x - 1, y - 1);						RollLeft(x + 1, y - 1);						RollRight(x - 1, y);						RollLeft(x + 1, y);					end				else					MoveThere(x, y, FALSE);			end;	end;	procedure DrawOffset (x, y: integer; offX, offY: integer; icn: integer);		var			err: oserr;			icnID: integer;			tempRect: rect;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;	begin		if (x >= upperLeft.h) and (y >= upperLeft.v) and (x <= upperLeft.h + 20) and (y <= upperLeft.v + 14) then			begin				getGWorld(oldGW, oldGD);				ignore := lockPixels(myOff^.portPixMap);				setGWorld(myOff, nil);				icnID := icn;				x := x - upperleft.h;				y := y - upperleft.v;				temprect.top := y * 32 - 16;				temprect.left := x * 32 - 16;				temprect.right := tempRect.left + 32;				temprect.bottom := tempRect.top + 32;				OffsetRect(tempRect, offX, offY);				err := PlotIconID(temprect, 0, 0, icnID);				setGWorld(oldGW, oldGD);				UnlockPixels(myOff^.PortPixMap);			end;	end;	procedure Draw1 (x, y: integer);{Plots an icon to the offscreen bitmap but does not draw the bitmap to the screen}		var			err: oserr;			icnID: integer;			tempRect: rect;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;	begin		if (x >= upperLeft.h) and (y >= upperLeft.v) and (x <= upperLeft.h + 20) and (y <= upperLeft.v + 14) then			begin				getGWorld(oldGW, oldGD);				ignore := lockPixels(myOff^.portPixMap);				setGWorld(myOff, nil);				icnID := getData(x, y);				x := x - upperleft.h;				y := y - upperleft.v;				temprect.top := y * 32 - 16;				temprect.left := x * 32 - 16;				temprect.right := tempRect.left + 32;				temprect.bottom := tempRect.top + 32;				err := PlotIconID(temprect, 0, 0, icnID);				setGWorld(oldGW, oldGD);				UnlockPixels(myOff^.PortPixMap);			end;	end;	procedure DrawOne (x, y: integer);{Plots an icon to the offscreen bitmap and draws it to the screen automatically}	begin		draw1(x, y);		RedrawBoard;	end;	function GetData (x, y: integer): integer;	begin		if boardData <> nil then			GetData := boardData^^.theBoard[x, y];	end;	function WhichScissor (x, y: integer): integer;		var			sc: integer;			done: boolean;			count: integer;			result: integer;			sloc: point;	begin		result := -1;		done := false;		sc := ScissorCount;		count := 0;		while not done and (count < sc) do			begin				count := count + 1;				sloc := ScissorLoc(count);				done := (sloc.h = x) and (sloc.v = y);			end;		if done then			result := count;		WhichScissor := result;	end;	function ScissorLoc (which: integer): point;							{where is scissor #x}	begin		ScissorLoc.h := scissorData[which].x;		ScissorLoc.v := scissorData[which].y;	end;	function QuarkLoc (which: integer): point;							{where is quark #x}	begin		QuarkLoc.h := quarkData[which].x;		QuarkLoc.v := quarkData[which].y;	end;	function WhichQuark (x, y: integer): integer;		var			sc: integer;			done: boolean;			count: integer;			result: integer;			sloc: point;	begin		result := -1;		done := false;		sc := QuarkCount;		count := 0;		while not done and (count < sc) do			begin				count := count + 1;				sloc := QuarkLoc(count);				done := (sloc.h = x) and (sloc.v = y);			end;		if done then			result := count;		WhichQuark := result;	end;	procedure MovedScissor (which, dir: integer);		var			ix, iy: integer;			nx, ny: integer;	begin		if dir <> 8 then			begin				ix := scissorData[which].x;				iy := scissorData[which].y;				nx := LocFromDir(ix, iy, dir).h;				ny := LocFromDir(ix, iy, dir).v;				scissorData[which].x := nx;				scissorData[which].y := ny;				scissorData[which].dir := dir;			end		else			scissorData[which].dir := (scissorData[which].dir + 2) mod 8;	end;	procedure MovedQuark (which, dir: integer);		var			ix, iy: integer;			nx, ny: integer;	begin		if dir <> 8 then			begin				ix := quarkData[which].x;				iy := quarkData[which].y;				nx := LocFromDir(ix, iy, dir).h;				ny := LocFromDir(ix, iy, dir).v;				quarkData[which].x := nx;				quarkData[which].y := ny;				quarkData[which].dir := dir;			end		else			quarkData[which].dir := (quarkData[which].dir + 2) mod 8;	end;	function PtToInt (x, y: integer): integer;							{transfer a point to an integer}	begin		PtToInt := integer((x * 256) + y);	end;	function IntToPt (i: integer): point;									{vv}	begin		IntToPt.h := i div 256;		IntToPt.v := i mod 256;	end;	procedure FixSize;		var			c: integer;	begin		c := boardData^^.sizeX;		while boardData^^.theBoard[c, 2] = 128 do			c := c - 1;		boardData^^.sizeX := c;		c := boardData^^.sizeY;		while boardData^^.theBoard[2, c] = 128 do			c := c - 1;		boardData^^.sizeY := c;		boardBounds.h := boardData^^.sizeX;		boardBounds.v := boardData^^.sizeY;	end;	procedure MakeSciStuff;		var			count1, count2: integer;			myX, myY: integer;			what: integer;	begin		count1 := 0;		count2 := 0;		for myX := 1 to boardBounds.h do			for myY := 1 to boardBounds.v do				begin					what := GetData(myX, myY);					if (((what >= 998) and (what <= 1009)) or ((what >= 1148) and (what <= 1160))) then						begin							count1 := count1 + 1;							scissorData[count1].x := myX;							scissorData[count1].y := myY;							scissorData[count1].dir := GetData(myX, myY) mod 8;						end					else if (what >= 650) and (what <= 666) then						begin							count2 := count2 + 1;							quarkData[count2].x := myX;							quarkData[count2].y := myY;							quarkData[count2].dir := kRight						end;				end;	end;{StatusStuff.p}	procedure ___StatusStuff;	begin	end;	procedure drawName;	begin		if hasPlayer in gameState then			begin				fillRect(429 + gMoveV, 187 + gMoveH, 447 + gMoveV, 338 + gMoveH, black);				RGBForeColor(myRedColor);				centerString(gPlayer.name, 443 + gMoveV - 1, 191 + gMoveH, 334 + gMoveH);				foreColor(blackColor);			end;	end;	procedure drawLevStats;	begin		if hasPlayer in gameState then			begin				fillRect(453 + gMoveV, 187 + gMoveH, 471 + gMoveV, 413 + gMoveH, black);				fillRect(453 + gMoveV, 425 + gMoveH, 471 + gMoveV, 455 + gMoveH, black);				RGBForeColor(myGreenColor);				centerString(gPlayer.level, 465 + gMoveV + 1, 191 + gMoveH, 409 + gMoveH);				moveTo(427 + gMoveH, 466 + gMoveV);				drawInteger(gPlayer.current, 3);				foreColor(blackColor);			end;	end;	procedure DrawDiskStat;	begin		ForeColor(blackColor);		fillRect(453 + gMoveV, 492 + gMoveH, 471 + gMoveV, 524 + gMoveH, black);		if gMurphy.numBombs = 0 then			RGBForeColor(myBlueColor)		else			RGBForeColor(myRedColor);		moveTo(495 + gMoveH, 466 + gMoveV);		DrawInteger(gMurphy.numBombs, 3);		foreColor(blackColor);	end;	procedure DrawInfoStat;	begin		ForeColor(blackColor);		fillRect(429 + gMoveV, 492 + gMoveH, 447 + gMoveV, 524 + gMoveH, black);		moveTo(495 + gMoveH, 442 + gMoveV);		if NumInfosLeft = 0 then			RGBForeColor(myGreenColor)		else			RGBForeColor(myRedColor);		DrawInteger(NumInfosLeft, 3);		foreColor(blackColor);	end;	procedure drawGameStats;	begin		if isPlaying in gameState then			begin				DrawDiskStat;				DrawInfoStat;			end		else			begin				ForeColor(blackColor);				fillRect(453 + gMoveV, 492 + gMoveH, 471 + gMoveV, 524 + gMoveH, black);				fillRect(429 + gMoveV, 492 + gMoveH, 447 + gMoveV, 524 + gMoveH, black);			end;	end;	procedure convertTime (theTime: longint; var hrs, mins, secs: integer);	begin		hrs := theTime div 216000;		mins := (theTime mod 216000) div 3600;		secs := ((theTime mod 216000) mod 3600) div 60;	end;	procedure drawTBoxes (anyWay: boolean);{anyway is to make sure that the times will be drawn no matter what}{keeping it false will make sure the numbers don't flicker}		var			h, m, s: integer;	begin		if hasPlayer in gameState then			begin				if isPlaying in GameState then					if isPaused in gameState then						ConvertTime(gPlayer.time, h, m, s)					else						ConvertTime(GetGameTime, h, m, s)				else					ConvertTime(gPlayer.time, h, m, s);				if (ldHrs <> h) or anyway then					begin	{TOP LEFT BOTTOM RIGHT ---> V H V H}						fillRect(429 + gMoveV, 357 + gMoveH, 429 + 18 + gMoveV, 357 + 22 + gMoveH, black);						RGBForeColor(myBlueColor);						moveTo(359 + gMoveH, 442 + gMoveV);						drawInteger(h, 2);						ForeColor(blackColor);						ldHrs := h;					end;				if (ldMins <> m) or anyway then					begin						fillRect(429 + gMoveV, 395 + gMoveH, 429 + 18 + gMoveV, 395 + 22 + gMoveH, black);						RGBForeColor(myBlueColor);						moveTo(397 + gMoveH, 442 + gMoveV);						drawInteger(m, 2);						ForeColor(blackColor);						ldMins := m;					end;				if (ldSecs <> s) or anyway then					begin						fillRect(429 + gMoveV, 433 + gMoveH, 429 + 18 + gMoveV, 433 + 22 + gMoveH, black);						RGBForeColor(myBlueColor);						moveTo(435 + gMoveH, 442 + gMoveV);						drawInteger(s, 2);						ForeColor(blackColor);						ldSecs := s;					end;			end;	end;	procedure drawStatus;		var			at: point;	begin		BackColor(blackColor);		at.h := 1 + gMoveH;		at.v := 419 + gMoveV;		drawPic(129, at);		drawTBoxes(true);		drawName;		drawLevStats;		DrawGameStats;	end;{Players.p}	procedure ___Players;	begin	end;	function getName: str255;	begin		getName := gPlayer.name;	end;	function getLevelName: str255;	begin		getLevelName := gPlayer.level;	end;	procedure killPlayer;			{can be left BLANK}	begin		gameState := gameState - [hasPlayer];	end;	procedure AddToTime (t: longint);	begin		gplayer.time := gplayer.time + t;		savePlayer;	end;	procedure GetTheKeys;		{who knows?}	begin	end;	procedure savePlayer;		var			data: handle;			tempData: handle;			c, x: integer;			oldRes: integer;			theErr: boolean;	begin		gUpKey := gplayer.keyset[1];		gDownKey := gplayer.keyset[4];		gLeftKey := gplayer.keyset[2];		gRightKey := gplayer.keyset[3];		gSpecKey := gplayer.keyset[5];		oldRes := CurResFile;		UseResFile(gMyResFile);		data := GetNamedResource(playerResType, gplayer.name);		if (resError = noErr) and (data <> nil) then			begin				PlayerHandle(data)^^ := gPlayer;				ChangedResource(data);			end		else			begin		{it doesn't exist; add it to the res file}				data := NewHandleClear(sizeOf(PlayerType));				if data <> nil then					begin						PlayerHandle(data)^^ := gPlayer;						AddResource(data, playerResType, uniqueID(playerResType), gplayer.name);					end				else					GenericError('Error: svpl#2');			end;		if data <> nil then			begin				UpdateResFile(gMyResFile);				ReleaseResource(data);			end;		UseResFile(oldRes);	end;	procedure loadPlayer;		{this is absolutely unnecessary. deal.}	begin	end;	procedure OpenPlayer;		var			data: handle;			theName: Str255;			playerData: PlayerType;			appState: InfoStatus;			ignore: boolean;			oldRes: integer;			e: boolean;			c: integer;			result: boolean;	begin		oldRes := CurResFile;		UseResFile(gMyResFile);		if OpenChoice(theName, gOpenDial) then			begin				data := GetNamedResource(playerResType, theName);				if (ResError = noErr) and (data <> nil) then					begin						MoveHHi(data);						HLock(data);						playerData := PlayerHandle(data)^^;						gameState := gameState + [hasPlayer];						HUnlock(data);						ReleaseResource(data);						gPlayer := playerData;						gUpKey := gplayer.keyset[1];						gDownKey := gplayer.keyset[4];						gLeftKey := gplayer.keyset[2];						gRightKey := gplayer.keyset[3];						gSpecKey := gplayer.keyset[5];						if gplayer.name = 'NoRtOfNi42' then							gplayer.highLev := Count1Resources(levelResType);{level := gPlayer.level;}{time := gPlayer.time;}{Init;}						KillData;						result := LoadBoard(gplayer.level);						if not result then							GenericError('Error: oppl#2');{GotNewBoard;}					end				else					GenericError('Error: oppl#1');				drawStatus;			end;		UseResFile(oldRes);	end;{Murphys.p}	procedure ___Murphys;	begin	end;	function UseRedDisk: boolean;		{TRUE if I had one}		var			dorky: rect;	begin		UseRedDisk := FALSE;		if gMurphy.numBombs > 0 then			begin				useRedDisk := TRUE;				gMurphy.numBombs := gMurphy.numBombs - 1;				DrawDiskStat;				PlaySound(sGotRedDisk);			end;	end;	procedure stopTime;	begin		gMurphy.totTime := gMurphy.totTime + (tickCount - gMurphy.startTime);	end;	procedure startGameTime;	begin		gMurphy.startTime := tickCount;	end;	function getGameTime: longint;	begin		getGameTime := gMurphy.totTime + (tickCount - gMurphy.startTime);	end;	function MyIntToPt (i: integer): point;									{vv}	begin		MyIntToPt.h := i div 256;		MyIntToPt.v := i mod 256;	end;	procedure init;		var			at: point;	begin		with gmurphy do			begin				lastMove := 0;				totTime := 0;				startGameTime;				numBombs := 0;				lastDir := 2;				if boardData <> nil then					begin						numInfos := boardData^^.numInfotrons;						at := MyIntToPt(boardData^^.murphy);					end				else					GenericError('error: mpinit#1(nobd)');				x := at.h;				y := at.v;			end;		gPhase := kSml;		gFromMed := kBig;	end;	procedure setLastDir (newDir: integer);	begin		gMurphy.lastDir := newDir;	end;	procedure SetLoc (x2, y2: integer);	begin		gMurphy.x := x2;		gMurphy.y := y2;	end;	procedure GetLoc (var x2, y2: integer);	begin		x2 := gMurphy.x;		y2 := gMurphy.y;	end;	procedure gotRedDisk;	begin		gMurphy.numBombs := gMurphy.numBombs + 1;		if gMurphy.numBombs > 99 then			GetMurphyObj.Explode(gMurphy.x, gMurphy.y);		DrawDiskStat;		PlaySound(sGotRedDisk);	end;	procedure KillMurphyMain;	begin		EndLevel;		{safely end the level.}		PlaySound(sMurphyDied);	end;	procedure WonGame;	begin		EndLevel;		TheyWonTheLevel;	end;	function NumInfosLeft: integer;	begin		numInfosLeft := gMurphy.numInfos;	end;	procedure gotInfotron;		var			dorky: rect;	begin		if gmurphy.numInfos = 1 then			begin				PlaySound(sGotLastInfo);			end		else			begin				PlaySound(sGotInfotron);			end;		if gmurphy.numInfos > 0 then			gmurphy.numInfos := gmurphy.numInfos - 1;		DrawInfoStat;	end;	function GetLastDir: integer;	begin		getLastDir := gMurphy.lastDir;	end;{AppStuff.p}	procedure ___AppStuff;	begin	end;	procedure StartNewLevel;		var			sizeX, sizeY, x, y: integer;			o: CGridPiece;			mySuicide: CSuicideChore;			myContMove: CContMoveChore;			myStat: InfoStatus;			wo: integer;			ignore: boolean;			dumbStupidUselessRect: rect;			w1, w2, w3, w4: integer;			o2: CGridPiece;			myKeys: KeyMap;			mySciMover: CScissorMover;			myQuaMover: CQuarkMover;	begin		DoKillChores;		{It _is_ safe to call DoKillChores from here!!!}		gAARDVARK_PLATYPUSS_WOMBAT := FALSE;		{Murphy isn't dying yet}		GetKeys(myKeys);		pauseKeyState := not myKeys[57];		HideMenubar(gMainWind);		ignore := LoadBoard(GetLevelName);		if not ignore then			GenericError('Error: stnwll#1');		gameState := gameState + [isplaying] - [freezeMurphy];		whatToBlank := 129;		{bad programming style. Sorry!!!}		gMurphy.numInfos := InfoCount;		HideCursor;		GetSize(sizeX, sizeY);		ClearSuicides;		Init;	{murphy!}		for x := 1 to sizeX do			for y := 1 to sizeY do				begin					fallingInfo^[x, y] := GetData(x, y) = 129;					fallChores^[x, y] := FALSE;					o := GetGridObj(x, y);					wo := GetData(x, y);					if (o.CanFall) then						begin							w1 := GetData(x, y + 1);							if w1 = 129 then								begin									new(mySuicide);									mySuicide.ISuicideChore(x, y);		{death chore.}									FudADD(mySuicide);								end							else								begin									o2 := GetGridObj(x, y + 1);									if o2.IsRounded then										begin											w1 := GetData(x - 1, y);											w2 := GetData(x - 1, y + 1);											w3 := GetData(x + 1, y);											w4 := GetData(x + 1, y + 1);											if ((w1 = 129) and (w2 = 129)) or ((w3 = 129) and (w4 = 129)) then												begin													new(mySuicide);													mySuicide.ISuicideChore(x, y);		{death chore.}													FudADD(mySuicide);												end;										end;								end;						end					else if (wo >= 300) and (wo <= 304) then						begin							CBug(o).Make(x, y);							SetData(x, y, 128);						end					else if (wo >= 550) and (wo <= 561) then						CTerminal(o).Make(x, y)					else if o.CanMove then						if CMoves(o).IAmA = quark then							begin								new(myQuaMover);								myQuaMover.IQuarkMover(x, y);		{make a new chore}								FudADD(myQuaMover);							end						else							begin								new(mySciMover);								mySciMover.IScissorMover(x, y);		{make a new chore}								FudADD(mySciMover);							end;				end;		DrawStatus;	end;	procedure ClearSuicides;	{clear the hasSuicides array}		var			x, y: integer;			xs, ys: integer;	begin		spaceBarWasDown := FALSE;		whatToBlank := 129;		diskDropSndPlayed := false;		lastWasPortal := FALSE;		lastFacingLR := kRight;		isSleeping := FALSE;		lastMoved := tickCount;		if not (isPlaying in GameState) then			begin				ShowMenuBar(gMainWind);				ShowCursor;			end;	end;	procedure DoKillChores;	{actually kill the chores. NEVER call this!!!}		var									{Because you might be doing so from WITHIN a chore!!!!}			myObj: CObject;			count: integer;	begin		ClearSuicides;		gAARDVARK_PLATYPUSS_WOMBAT := FALSE;		shouldKillChores := FALSE;		for count := 1 to iuLen do			if infoUrgents[count] <> nil then				begin					DisposeHandle(Handle(infoUrgents[count]));					infoUrgents[count] := nil;				end;		for count := 1 to tbaLen do			if toBeAdded[count] <> nil then				begin					DisposeHandle(Handle(toBeAdded[count]));					toBeAdded[count] := nil;				end;		for count := 1 to tbrLen do			if toBeRidded[count] <> nil then				begin					DisposeHandle(Handle(toBeRidded[count]));					toBeRidded[count] := nil;				end;		iuLen := 0;		tbrLen := 0;		tbaLen := 0;	end;	procedure InitChoreLists;		var			count: integer;	begin		for count := 1 to maxList do			begin				infoUrgents[count] := nil;				toBeAdded[count] := nil;				toBeRidded[count] := nil;			end;		tbaLen := 0;		tbrLen := 0;		iuLen := 0;	end;	procedure MakeGObjs;		var			c: integer;	begin		New(CPortal(gos[1]));		New(CExit(gos[2]));		New(CBug(gos[3]));		New(CTerminal(gos[4]));		New(CBlank(gos[5]));		New(CCircut(gos[6]));		New(CChip(gos[7]));		New(CHardware(gos[8]));		New(CScissor(gos[9]));		New(CQuark(gos[10]));		New(CRedDisk(gos[11]));		New(CYellowDisk(gos[12]));		New(CGreenDisk(gos[13]));		New(CZonk(gos[14]));		New(CInfotron(gos[15]));		New(CMurphyObj(gos[16]));		New(CGridPiece(gos[17]));		for c := 1 to 17 do			begin				MoveHHi(handle(gos[c]));				HLock(handle(gos[c]));				gos[c].InitPiece;			end;	end;	function GetGridObj (x, y: integer): CGridPiece;		var			what: integer;			mo: CGridPiece;	begin		what := GetData(x, y);		mo := gos[17];		if what = 128 then			mo := gos[grCircut]		else if what = 129 then			mo := gos[grBlank]		else if (what >= 700) and (what <= 707) then			mo := gos[grZonk]		else if ((what >= 850) and (what <= 853)) then			mo := gos[grInfotron]		else if (what = 131) or ((what >= 1100) and (what <= 1106)) then			mo := gos[grChip]		else if ((what >= 750) and (what <= 757)) or ((what >= 1050) and (what <= 1057)) then			mo := gos[grHardware]		else if (((what >= 998) and (what <= 1009)) or ((what >= 1148) and (what <= 1160))) then			mo := gos[grScissor]		else if (what >= 650) and (what <= 666) then	{santa}			mo := gos[grQuark]		else if (what >= 300) and (What <= 305) then			mo := gos[grBug]		else if (what = 132) or ((what >= 900) and (what <= 952)) then			mo := gos[grPortal]		else if what = 133 then			mo := gos[grGreen]		else if what = 135 then			mo := gos[grRed]		else if what = 134 then			mo := gos[grYellow]		else if (what >= 550) and (what <= 561) then			mo := gos[grTerminal]		else if what = 130 then			mo := gos[grExit]		else if ((what >= 499) and (what <= 511)) or ((what >= 139) and (what <= 214)) or ((what >= 1200) and (what <= 1210)) then			mo := gos[grMurphyObj];		GetGridObj := mo;	end;	function GetNextRollDir: integer;	begin		GetNextRollDir := nextRollDir;	end;	function GetInfoStatus: InfoStatus;	begin		GetInfoStatus := gameState;	end;	procedure SetInfoStatus (s: InfoStatus);	begin		gameState := s;	end;	procedure KillChores;	begin		shouldKillChores := TRUE;	end;	procedure ToggleRollDir;	begin		if random > 0 then			nextRollDir := kRight		else			nextRollDir := kLeft;	end;	function ARandom (upper: integer): integer;	begin		if upper > 0 then			aRandom := abs(random) mod upper + 1		else			aRandom := 1;	end;	function LocFromDir (x, y, d: integer): point;		var			mtx, mty: integer;	begin		case d of			kNoMove: 				begin					mtx := x;					mty := y;				end;			kUp: 				begin					mtx := x;					mty := y - 1;				end;			kRight: 				begin					mtx := x + 1;					mty := y;				end;			kDown: 				begin					mtx := x;					mty := y + 1;				end;			kLeft: 				begin					mtx := x - 1;					mty := y;				end;			kUpRight: 				begin					mtx := x + 1;					mty := y - 1;				end;			kUpLeft: 				begin					mtx := x - 1;					mty := y - 1;				end;			kDownRight: 				begin					mtx := x + 1;					mty := y + 1;				end;			kDownLeft: 				begin					mtx := x - 1;					mty := y + 1;				end;		end;		LocFromDir.h := mtx;		LocFromDir.v := mty;	end;end.
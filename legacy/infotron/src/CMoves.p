unit CMoves;interface	uses		TCL, GridPieceIntf;implementation	function CMoves.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := TRUE;		CInfoAPp(gapplication).GetMurphyObj.KillMurphy;	end;	procedure CMoves.DoMove (oldx, oldy, newx, newy, olddir, newdir: integer; callingChore: CContMoveChore);		var			myChore: CMoveReplyChore;	begin		New(myChore);		myChore.IMoveReplyChore(callingChore, newDir, olddir, IAmA, oldX, oldY);		CInfoApp(CInfoApp(gApplication)).FudADD(myChore);	end;	procedure CMoves.FigureFacing (x, y: integer);		var			whic: integer;	begin		case IAmA of			scissor: 				begin					whic := CInfoApp(CInfoApp(gApplication)).GetGPane.GetBoard.WhichScissor(x, y);					facing := CInfoApp(CInfoApp(gApplication)).GetGPane.GetBoard.ScissorDir(whic);				end;			quark: 				begin					whic := CInfoApp(CInfoApp(gApplication)).GetGPane.GetBoard.WhichQuark(x, y);					facing := CInfoApp(CInfoApp(gApplication)).GetGPane.GetBoard.QuarkDir(whic);				end;		end;	end;	procedure CMoves.Move (x, y: integer; callingChore: CContMoveChore);		var			newFacing: integer;			dirLeft, dirRight: integer;			locS, locL, locR: point;			whatS, whatL, whatR: integer;	begin		FigureFacing(x, y);		dirLeft := (facing + 6) mod 8;		dirRight := (facing + 2) mod 8;		locS := CInfoApp(gApplication).LocFromDir(x, y, facing);		locL := CInfoApp(gApplication).LocFromDir(x, y, dirLeft);		locR := CInfoApp(gApplication).LocFromDir(x, y, dirRight);		whatS := CInfoApp(gApplication).GetGPane.GetBoard.GetData(locS.h, locS.v);		whatL := CInfoApp(gApplication).GetGPane.GetBoard.GetData(locL.h, locL.v);		whatR := CInfoApp(gApplication).GetGPane.GetBoard.GetData(locR.h, locR.v);		if ((whatL >= 499) and (whatL <= 511)) or ((whatL >= 139) and (whatL <= 214)) or ((whatL >= 1200) and (whatL <= 1210)) then			CInfoAPp(gapplication).GetMurphyObj.Explode(locL.h, locL.v)		else if whatL = 129 then			DoMove(x, y, locL.h, locL.v, facing, dirLeft, callingChore)		else if ((whatS >= 499) and (whatS <= 511)) or ((whatS >= 139) and (whatS <= 214)) or ((whatS >= 1200) and (whatS <= 1210)) then			CInfoAPp(gapplication).GetMurphyObj.Explode(locS.h, locS.v)		else if whatS = 129 then			DoMove(x, y, locS.h, locS.v, facing, facing, callingChore)		else if ((whatR >= 499) and (whatR <= 511)) or ((whatR >= 139) and (whatR <= 214)) or ((whatR >= 1200) and (whatR <= 1210)) then			CInfoAPp(gapplication).GetMurphyObj.Explode(locR.h, locR.v)		else if whatR = 129 then			DoMove(x, y, locR.h, locR.v, facing, dirRight, callingChore)		else			DoMove(x, y, x, y, facing, kNoMove, callingChore);	end;	procedure CMoves.InitPiece;	begin		inherited InitPiece;		moves := true;	end;end.
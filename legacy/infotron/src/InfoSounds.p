unit QIST;interface{This is a hybrid of QIST - for the music, and PSST - for the speed}{THIS IS NOT QIST. I was just lazy and didn't want to change the unit name!}	uses		sound;	const		kHearingRange = 20;	procedure HaltSounds;	procedure Close_QIST;									{call when application is going to exit}	procedure CleanSounds;	procedure Init_QIST;	procedure SoundState (state: boolean);	function FreeChan (var cn: integer): boolean;	procedure PlaySound (id: integer);	function ContSound (id: integer): integer;	procedure ContSoundStop (ignore: integer);	procedure PlaySoundDist (id: integer; p1x, p1y, p2x, p2y: integer);	procedure PlaySoundDistRange (id: integer; p1x, p1y, p2x, p2y: integer; range: integer);implementation	var		soundsOn: boolean;		channels: array[1..5] of SndChannelPtr;		{4 is reserved for continuous sounds}		usage: array[1..5] of boolean;		contSndHand: handle;		err: OSErr;{$PUSH}{$D-}{$N-}{$V-}{$R-}	procedure I_MainPlayCont (chan: SndChannelPtr; afive: longint);		var			cmod: SndCommand;	begin		with cmod do			begin				cmd := CallBackCmd;				param1 := 0;	{obsolete}				param2 := afive;			end;		err := SndPlay(chan, contSndHand, TRUE);		if err = noErr then			err := SndDoCommand(chan, cmod, FALSE);	end;	procedure CB_Standard (chan: SndChannelPtr; cmd: SndCommand);{standard callback; simply disposes of channel}		var			oldA5, old2A5: longint;	begin		oldA5 := SetA5(cmd.param2);		usage[cmd.param1] := FALSE;		old2A5 := SetA5(oldA5);	end;	procedure CB_Cont (chan: SndChannelPtr; cmd: SndCommand);{this one continues to play the sound, again and again}		var			oldA5, old2A5: longint;			slotNum: integer;	begin		oldA5 := SetA5(cmd.param2);		I_MainPlayCont(chan, cmd.param2);		old2A5 := SetA5(oldA5);	end;{$POP}	procedure I_AsyncPlayCons (var sndHand: handle; slotNum: integer; theVol: integer);		var			cbackcmd, ampcmde, freqcmde, sndcmde: SndCommand;			itsRefID: integer;	begin		cbackcmd.cmd := callBackCmd;		cbackcmd.param1 := slotNum;		cbackcmd.param2 := SetCurrentA5;		ampcmde.cmd := ampCmd;		ampcmde.param1 := theVol;		ampcmde.param2 := 0;		freqcmde.cmd := freqDurationCmd;		freqcmde.param1 := 3200;		freqcmde.param2 := 60;		sndcmde.cmd := soundCmd;		sndcmde.param1 := 0;		sndcmde.param2 := longint(sndHand^) + 20;		err := SndDoCommand(channels[slotNum], sndcmde, false);		err := SndDoCommand(channels[slotNum], ampcmde, false);		err := SndDoCommand(channels[slotNum], freqcmde, false);		err := SndDoCommand(channels[slotNum], cbackcmd, false);	end;	procedure HaltSounds;		var			qcmd: SndCommand;			cnt: integer;	begin		for cnt := 1 to 4 do			if channels[cnt] <> nil then				begin					qcmd.cmd := quietCmd;					qcmd.param1 := 0;					qcmd.param2 := 0;					if usage[cnt] then						err := SndDoImmediate(channels[cnt], qcmd);					usage[cnt] := FALSE;				end;		ContSoundStop(1);	end;	procedure Close_QIST;									{call when application is going to exit}		var			cnt: integer;	begin		for cnt := 1 to 5 do			err := SndDisposeChannel(channels[cnt], TRUE);	end;	procedure CleanSounds;	begin	{do nothing, for now}	end;	procedure Init_QIST;		var			cnt: integer;			val: real;	begin		soundsOn := true;		for cnt := 1 to 4 do			err := SndNewChannel(channels[cnt], sampledSynth, initMono, @CB_Standard);		channels[5] := nil;		for cnt := 1 to 5 do			usage[cnt] := FALSE;		contSndHand := nil;	end;	procedure SoundState (state: boolean);	begin		soundsOn := state;	end;	function FreeChan (var cn: integer): boolean;		var			cnt: integer;	begin		cn := -1;		for cnt := 4 downto 1 do			if not usage[cnt] then				cn := cnt;		FreeChan := cn <> -1;	end;	procedure PlaySound (id: integer);		var			sndHand: handle;			chanNum: integer;			cmod: SndCommand;	begin		if soundsOn then			if FreeChan(chanNum) then				begin					sndHand := GetResource('snd ', id);					MoveHHi(sndHand);					HLock(sndHand);					if sndHand <> nil then						begin							with cmod do								begin									cmd := ampCmd;									param1 := 255;									param2 := 0;								end;							err := SndDoCommand(channels[chanNum], cmod, FALSE);							with cmod do								begin									cmd := CallBackCmd;									param1 := chanNum;									param2 := SetCurrentA5;								end;							usage[chanNum] := TRUE;							err := SndPlay(channels[chanNum], sndHand, TRUE);							if err = noErr then								err := SndDoCommand(channels[chanNum], cmod, FALSE);						end;				end;	end;	function ContSound (id: integer): integer;	begin		ContSound := 1;		{not really important}		ContSoundStop(1);		err := SndNewChannel(channels[5], sampledSynth, initMono, @CB_Cont);		if err = noErr then			begin				usage[5] := TRUE;				contSndHand := GetResource('snd ', id);				if contSndHand <> nil then					begin						MoveHHi(contSndHand);						HLock(contSndHand);						I_MainPlayCont(channels[5], SetCurrentA5);					end;			end;	end;	procedure ContSoundStop (ignore: integer);	begin		if channels[5] <> nil then			begin				err := SndDisposeChannel(channels[5], TRUE);				channels[5] := nil;			end;	end;	procedure PlaySoundDist (id: integer; p1x, p1y, p2x, p2y: integer);		var			dist: integer;			calcVol: integer;			chanNum: integer;			sndHand: handle;	begin		if soundsOn then			if FreeChan(chanNum) then				begin					dist := abs(p2y - p1y) + abs(p2x - p1x);					if dist < kHearingRange then	{you can hear it}						begin							calcVol := trunc((kHearingRange - dist) * (255 / kHearingRange));		{0 - lowest vol - farthest away; 255 - highest vol - closest}							sndHand := GetResource('snd ', id);							if sndHand <> nil then								begin									I_AsyncPlayCons(sndHand, chanNum, calcVol);									usage[chanNum] := TRUE;								end;						end;				end;	end;	procedure PlaySoundDistRange (id: integer; p1x, p1y, p2x, p2y: integer; range: integer);		var			dist: integer;			calcVol: integer;			chanNum: integer;			sndHand: handle;	begin		if soundsOn then			if FreeChan(chanNum) then				begin					dist := abs(p2y - p1y) + abs(p2x - p1x);					if dist < range then	{you can hear it}						begin							calcVol := trunc((range - dist) * (255 / range));		{0 - lowest vol - farthest away; 255 - highest vol - closest}							sndHand := GetResource('snd ', id);							if sndHand <> nil then								begin									I_AsyncPlayCons(sndHand, chanNum, calcVol);									usage[chanNum] := TRUE;								end;						end;				end;	end;end.
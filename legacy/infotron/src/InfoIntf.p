unit InfoIntf;interface	uses		TCL, QuickDrawProcs,								{}		QDOffscreen, ColorOffScreen, 						{}		myRGBColors, CDlogDirector, InfoWindows,		{}		gammaPasLibIntf, MenuBars, PSST;	type		AnimArray = array[1..20] of integer;		MovingThingy = (murphy, scissor, quark, boulder, infotron);		NCPtr = ^NCArray;		NCArray = array[1..120, 1..120] of byte;	const		kResourceID = 129;	const{directions}		kNoMove = 8;		kUp = 0;		kUpRight = 1;		kRight = 2;		kDownRight = 3;		kDown = 4;		kDownLeft = 5;		kLeft = 6;		kUpLeft = 7;		kInfoChore = 1;		kAnimChore = 2;		kContMoveChore = 3;		kFallChore = 4;		kSuicideChore = 5;		kWaitInsChore = 6;		kContAnimChore = 7;		kExplChore = 8;		kFallExplChore = 9;		kMoveReplyChore = 10;		kMoveChore = 11;		kKillGameChore = 12;		kWaitTimeChore = 13;		sGotInfotron = 128;		{the sounds}		sThud = 129;		sOHit = 130;		sExplode = 131;		sQuarkExp = 132;		sGotRedDisk = 133;		sRedDiskReady = 134;		sGotLastInfo = 135;		sAboutBox = 136;		sMurphyDied = 137;		sPause = 138;		sUnpause = 139;		sBugZap = 140;	const{file menu commands}		iCmdNew = 2000;		iCmdOpen = 2001;		iCmdRename = 2002;		iCmdDelete = 2003;		iCmdQuit = 1;{game menu commands}		iCmdLevel = 3000;		iCmdKeys = 3001;		iCmdStart = 3003;		iCmdPause = 3004;		iCmdSoundFX = 3006;		iCmdSoundEffects = iCmdSoundFX;		iCmdMusic = 3007;		iCmdHelp = 3009;	const		grPortal = 1;		grExit = 2;		grBug = 3;		grTerminal = 4;		grBlank = 5;		grCircut = 6;		grChip = 7;		grHardware = 8;		grScissor = 9;		grQuark = 10;		grRed = 11;		grYellow = 12;		grGreen = 13;		grZonk = 14;		grInfotron = 15;		grMurphyObj = 16;	const		kMaxThings = 110;		kCurrentDir = -42;	type		boardArray = array[1..150, 1..150] of integer;		ThingArray = array[1..kMaxThings] of integer;		twoZeroArray = array[1..120, 1..120] of integer;		oneZeroArray = array[0..0] of integer;		MovingThing = record				x, y, dir: integer;			end;		MovingArray = array[1..kMaxThings] of MovingThing;		bcp = ^bcpp;		bcpp = ^CompressedBoard;		CompressedBoard = record				name: str255;				sizeX, sizeY: integer;									{How far right and down does the level extend?}				murphy, term: integer;											{where does murphy start}				numScissors: integer;				numQuarks: integer;				numInfotrons: integer;				numBugs: integer;				numComp: integer;			{how many run-length compression thingys did we use up?}				theBoard: oneZeroArray;			end;		bap = ^bapp;		bapp = ^LevelRecord;		LevelRecord = record				name: str255;				sizeX, sizeY: integer;									{How far right and down does the level extend?}				murphy, term: integer;											{where does murphy start}				numScissors: integer;				numQuarks: integer;				numInfotrons: integer;				numBugs: integer;				scissors, quarks, bugs: ThingArray;				theBoard: twoZeroArray;			end;	const		kBackgroundWidth = 20;		kBackgroundHeight = 20;		KWindowProcID = 2;	type		CInfoDir = object(CDirector)				itsMainPane: CGamePane;				procedure IInfoDir (aSuperviser: CDirectorOwner);				procedure Deactivate;				override;				procedure Activate;				override;				procedure Free;				override;				procedure DoCommand (theCommand: longint);				override;			end;	type		CMurphy = object(CObject)				x, y: integer;				lastMove: longint;				time: longint;				lastDir: integer;				numBombs: integer;				numInfos: integer;				function CMurphy.UseRedDisk: boolean;		{TRUE if I had one}				procedure getLoc (var locx, locy: integer);				procedure setLoc (locx, locy: integer);				procedure init;				procedure killMurphy;				procedure WonGame;				procedure GotInfotron;				procedure GotRedDisk;				function NumInfosLeft: integer;				function getLastDir: integer;				procedure setLastDir (newDir: integer);			end;	type		CGridPiece = object(CObject)				destructable: boolean;				rounded: boolean;				explodes: boolean;				falls: boolean;				moves: boolean;				explAnim: AnimArray;				procedure InitPiece;			{Call this after creating the CGridPiece}				function IsDestructable: boolean;				function IsRounded: boolean;				function CanExplode: boolean;				function CanFall: boolean;				function CanMove: boolean;				procedure Destroy (x, y: integer);				procedure Explode (x, y: integer);				function WalkOnto (x, y: integer): boolean;  {TRUE if murphy could come here}				procedure Fall (x, y: integer);			{Don't call this; call CheckFall instead}				procedure Roll (x, y, dir: integer);		{Don't call this; call CheckRoll instead}				procedure Move (x, y: integer; callingChore: CContMoveChore);				function Push (x, y: integer): boolean;	{WalkOnto might call this, but you shouldn't. TRUE if can be pushed.}				procedure CheckFall (x, y: integer);				function CheckRoll (x, y, dir: integer): boolean;			end;	type		gridPieceArray = array[1..20] of CGridPiece;		CBlank = object(CGridPiece)				procedure InitPiece;				override;			end;		CExplodes = object(CGridPiece)				procedure InitPiece;				override;				procedure Explode (x, y: integer);				override;				function WalkOnto (x, y: integer): boolean;				Override;			end;		CMurphyObj = object(CExplodes)	{To handle murphy's death}				procedure Destroy (x, y: integer);				override;				procedure Explode (x, y: integer);				override;				procedure KillMurphy;			end;		CGreenDisk = object(CExplodes)				procedure InitPiece;				override;				procedure Fall (x, y: integer);				override;				function WalkOnto (x, y: integer): boolean;				override;				function Push (x, y: integer): boolean;				override;			end;		CYellowDisk = object(CExplodes)				function WalkOnto (x, y: integer): boolean;				override;				function Push (x, y: integer): boolean;				override;				procedure CYellowDisk.InitPiece;				override;			end;		CCircut = object(CGridPIece)				procedure InitPiece;				override;			end;		CRedDisk = object(CExplodes)				procedure InitPiece;				override;				function WalkOnto (x, y: integer): boolean;				override;			end;		CMoves = object(CExplodes)				IAmA: MovingThingy;				facing: integer;				function WalkOnto (x, y: integer): boolean;				override;			{Must Start an explosion}				procedure CMoves.Move (x, y: integer; callingChore: CContMoveChore);				override;				procedure InitPiece;				override;				procedure FigureFacing (x, y: integer);				procedure CMoves.DoMove (oldx, oldy, newx, newy, olddir, newdir: integer; callingChore: CContMoveChore);			end;		CScissor = object(CMoves)				procedure InitPiece;				override;			end;		CQuark = object(CMoves)				qExplAnim: AnimArray;				procedure InitPiece;				override;				procedure Explode (x, y: integer);				override;			end;		CBug = object(CGridPiece)				bugAnim: AnimArray;				procedure InitPiece;				override;				procedure Make (x, y: integer);				function WalkOnto (x, y: integer): boolean;				override;			end;		CExit = object(CGridPiece)				procedure InitPiece;				override;				function WalkOnto (x, y: integer): boolean;				override;			end;		CPortal = object(CGridPiece)				function WalkOnto (x, y: integer): boolean;				override;				procedure InitPiece;				override;			end;		CTerminal = object(CGridPiece)				termAnim: AnimArray;				procedure Make (x, y: integer);				procedure InitPiece;				override;				function WalkOnto (x, y: integer): boolean;				override;			end;		CHardware = object(CGridPiece)				function WalkOnto (x, y: integer): boolean;				override;			end;		CChip = object(CGridPiece)				procedure InitPiece;				override;				function CChip.WalkOnto (x, y: integer): boolean;				override;			end;		CFalls = object(CGridPiece)				procedure InitPiece;				override;		{must fall}				procedure Fall (x, y: integer);				override;			end;		CZonk = object(CFalls)				procedure InitPiece;				override;				procedure Roll (x, y, dir: integer);				override;				function WalkOnto (x, y: integer): boolean;				override;				function Push (x, y: integer): boolean;	{WalkOnto might call this, but you shouldn't. TRUE if can be pushed.}				override;			end;		CInfotron = object(CFalls)				procedure InitPiece;				override;				procedure Roll (x, y, dir: integer);				override;				function WalkOnto (x, y: integer): boolean;				override;			end;		CBoard = object(CObject)				boardData: bap;			{all the data is stored in this handle}				boardBounds: point;		{not in pixels, rather it is in ICONS}				quarkData, scissorData: MovingArray;				function LoadBoard (name: Str255): boolean;		{FALSE if it failed}				procedure KillData;			{get rid of the current handle, if any}				function GetData (x, y: integer): integer;				procedure SetData (x, y, what: integer);		{directly set the data}				procedure GetSize (var hSize, vSize: integer);				procedure FixSize;				procedure MakeSciStuff;				function ScissorCount: integer;			{get info about the board}				function QuarkCount: integer;				function InfoCount: integer;				function BugCount: integer;				function MurphyStart: point;				function TermLocation: point;				function CBoard.GetName: Str255;				procedure MovedScissor (which: integer; direction: integer);			{move scissor # in specified direction}																					{use kCurrentDir for same direction}				procedure MovedQuark (which: integer; direction: integer);				function ScissorLoc (which: integer): point;							{where is scissor #x}				function QuarkLoc (which: integer): point;							{where is quark #x}				function BugLoc (which: integer): point;				function WhichScissor (whereX, whereY: integer): integer;		{what # scissor is here?}				function WhichQuark (whereX, whereY: integer): integer;				function WhichBug (whereX, whereY: integer): integer;				function ScissorDir (which: integer): integer;				function QuarkDir (which: integer): integer;				function PtToInt (x, y: integer): integer;							{transfer a point to an integer}				function IntToPt (i: integer): point;									{vv}				procedure Free;				override;			end;		CCompBoard = object(CObject)				compData: bcp;				function LoadBoard (name: Str255): boolean;								{FALSE if it failed}				function CCompBoard.DecompressBoard (var b: bap): boolean;				procedure KillData;				procedure Free;				override;			end;	type		infoState = (hasPlayer, hasLevel, isPlaying, isPaused, hasMusic, hasSound, fadeFromB, freezeMurphy);		infoStatus = set of infoState;	type		CInfoApp = object(CApplication)				gos: GridPieceArray;			{the grid pieces}				gameState: infoStatus;				gAboutDial, gNewDial, gRenDial, gKeysDial, gHelpDial: CInfoDialog;				gLevelDial, gOpenDial, gDeleteDial: CInfoScrollDialog;				toBeAdded, toBeRidded: CList;				infoUrgents: CList;				{the urgent chores dealing with the game.}											{these need to be handled differently than the TCL chores which}											{are urgent ones.}				hasSuicide: array[1..120, 1..120] of boolean;		{where the suicide chores are}				numChores: NCPtr;				nextRollDir: integer;				shouldKillChores: boolean;				whatToBlank: integer;				spaceBarWasDown: boolean;		{TRUE if the space bar was down during the LAST cycle}				whenWentDown: longint;			{when the space bar went down}				diskDropSndPlayed: boolean;	{TRUE if the disk-ready-to-drop sound signal was played}				loadNextLevel: boolean;				lastWasPortal: BOOLEAN;				myOldKeys: KeyMap;				lastFacingLR: integer;				isSleeping: boolean;				lastMoved: longint;				sleepPhase: integer;		{the icon}				scratchLongint: longint;	{a scratch longint}				scratchInteger: integer;	{a scratch integer}				scratchBoolean: boolean;{a scratch boolean}				procedure CInfoApp.TheyWonTheLevel;				procedure CInfoApp.ClearSuicides;	{clear the hasSuicides array}				procedure CInfoApp.DoKillChores;	{actually kill the chores. NEVER call this!!!}				function CInfoApp.Quit: Boolean;				override;{neato burrito}				function CInfoApp.GetNextRollDir: integer;				procedure CInfoApp.ToggleRollDir;				procedure CInfoApp.Process1Event;				override;{HAHAHAHA WE OVERRODE THE EVENT HANDLER AND WE HAD FUN AND IT IS 3 IN THE MORNING!}				procedure CInfoApp.FudADD (chore: CChore);		{add some chores here}				procedure CInfoApp.FudRID (chore: CChore);		{rid some chores here}				procedure CInfoApp.SetInfoStatus (gs: InfoStatus);				function CInfoApp.GetInfoStatus: InfoStatus;				procedure CInfoApp.Idle (macEvent: EventRecord);				override;				function CInfoApp.ARandom (u: integer): integer;				function CInfoApp.GetMurphyObj: CMurphyObj;		{What's this?}				function CInfoApp.GetMurphy: CMurphy;			{But that's not all...}				function CInfoApp.GetGPane: CGamePane;				function CInfoApp.LocFromDir (x, y, d: integer): point;				procedure CInfoApp.MakeGObjs;				function CInfoApp.GetGridObj (x, y: integer): CGridPiece;				procedure CInfoApp.KillChores;				procedure CInfoApp.CreateCGameDirector;				procedure CInfoApp.IInfoApp;				procedure CInfoApp.SetUpFileParameters;				override;				procedure CInfoApp.SetUpMenus;				override;				procedure CInfoApp.NewPlayer;				procedure CInfoApp.DoCommand (theCommand: longint);				override;				procedure CInfoApp.UpdateMenus;				override;				procedure CInfoApp.ExitApp;				override;				procedure CInfoApp.CreateDocument;				override;				procedure CInfoApp.OpenDocument (macSFReply: SFReply);				override;			end;		CInfoChore = object(CChore)		{Abstract class!}				xq, yq: integer;				myIdent: integer;				procedure CInfoChore.GetChoreLoc (var cx, cy: integer);				function CInfoChore.Identify: integer;				procedure CInfoChore.FreeMemory;		{do nothing here; other objects might want to free themselves??}				function CInfoChore.ShouldRemove: boolean;				procedure IInfoChore (xe, ye: integer);				procedure CInfoChore.Remove;				procedure Free;				override;			end;		CFallChore = object(CInfoChore)				ix, iy: integer;				procedure IFallChore (x, y: integer);				procedure DoOneFall;				procedure HitBottom;				procedure Perform (var maxSleep: longint);				override;			end;		CWaitInsChore = object(CInfoChore)				toBeInstalled: CChore;				countDown: integer;				HaveInstalled: BOOLEAN;				procedure CWaitInsChore.FreeMemory;				override;				procedure Perform (var maxSleep: longint);				override;				procedure IWaitInsChore (someChore: CChore; theCount: integer);			end;		CWaitTimeChore = object(CWaitInsChore)				installedWhen: longint;				procedure IWaitTimeChore (someChore: CChore; numSecs: integer);				procedure Perform (var maxSleep: longint);				override;			end;		CKillGameChore = object(CInfoChore)				procedure IKillGameChore;				procedure Perform (var maxSleep: longint);				override;			end;		CFallExplChore = object(CFallChore)				procedure IFallExplChore (x, y: integer);				procedure HitBottom;				override;			end;		CAnimChore = object(CInfoChore)				animSequence: AnimArray;				animAt: integer;				finalAnim: integer;			{after everything is done}				delayBetween: longint;		{minimum delay between FRAMES}				lastTime: longint;				procedure DrawAt;				procedure IAnimChore (as: AnimArray; fa: integer; db: longint; x, y: integer);				procedure DoOneFrame;				procedure CAnimChore.SequenceDone;				procedure CAnimChore.FrameDone;				procedure Perform (var maxSleep: longint);				override;			end;	type		CExplChore = object(CAnimChore)			{this handles chain reaction explosions.}				procedure IExplChore (x, y: integer; aas: AnimArray; fa: integer);				procedure FrameDone;				override;			end;		CContAnimChore = object(CAnimChore)				cycleDelay: longint;		{or else}				inCycle: boolean;				betweenStart: longint;				procedure IContAnimChore (cd: longint; as: AnimArray; fa: integer; db: longint; x, y: integer);				procedure SequenceDone;				override;				procedure Perform (var maxSleep: longint);				override;			end;	type		CContMoveChore = object(CInfoChore)				removeOnRespond: BOOLEAN;				procedure SubsidiaryDone (x, y: integer);				procedure IContMoveChore (x, y: integer);	{who cares what I am?}				procedure Perform (var maxSleep: longint);				override;			end;		CMoveChore = object(CAnimChore)				direction, oldDir: integer;				numPixels: integer;				notSoAnim: AnimArray;				itIsA: MovingThingy;				moveThereAtFram: integer;				mtx, mty: integer;				procedure CMoveChore.SequenceDone;				override;				procedure MakeArray;				procedure FrameDone;				override;				procedure CMoveChore.IMoveChore (d: integer; oldD: integer; whatIsIt: MovingThingy; x, y: integer);				procedure Perform (var maxSleep: longint);				override;			end;	type		CMoveReplyChore = object(CMoveChore)				myReplyTo: CContMoveChore;				procedure CMoveReplyChore.Remove;				override;				procedure DoOneFrame;				override;				procedure SequenceDone;				override;				procedure IMoveReplyChore (whoTo: CContMoveChore; d: integer; oldD: integer; whatIsIt: MovingThingy; x, y: integer);			end;	type		CSuicideChore = object(CInfoChore)				uselessCount: integer;		{this is an absolutely useless counter.}				procedure ISuicideChore (x, y: integer);				procedure Perform (var maxSleep: Longint);				override;			end;	type		CBoardPane = object(CPane)				UpperLeft: point;				LowerRight: point;				OffRect: rect;				myOff: GWorldPtr;				procedure CBoardPane.DrawOffScreen;				procedure CBoardPane.GotNewBoard;				procedure IBoardPane (anEnclosure: CView; aSupervisor: CBureaucrat; aWidth, aHeight: integer; aHEncl, aVEncl: integer; aHSizing, aVSizing: SizingOption);				procedure Free;				override;				procedure MoveDown;				procedure MoveUp;				procedure MoveLeft;				procedure MoveRight;				procedure Draw1 (x, y: integer);				procedure DrawOne (x, y: integer);				procedure SetUpOffScreen;				procedure Draw (var area: rect);				override;			end;	type		CGamePane = object(CPane)				itsPlayer: CPlayer;				itsBoard: CBoard;				itsMurphy: CMurphy;				function CGamePane.GetBPane: CBoardPane;				procedure CGamePane.setTheBoxes;				procedure CGamePane.startNewLevel;				procedure CGamePane.doCommand (theCommand: longint);				override;				procedure CGamePane.EndLevel;		{safely end a level}				procedure CGamePane.draw (var area: rect);				override;				procedure CGamePane.setUpSubviews;				procedure IGamePane (anEnclosure: CView; aSupervisor: CBureaucrat);				function getPlayer: CPlayer;				function getBoard: CBoard;				function getMurphy: CMurphy;				function IsPlayerLoaded: boolean;				function isGamePlaying: boolean;				function effectsOn: boolean;				procedure free;				override;			end;	type		CInfoNewDir = object(CDLOGDirector)				err, done: boolean;				procedure IInfoNewDir;				procedure DoCommand (theCommand: longint);				override;				function getData: str255;				function GetNewCharacter (name: str255): boolean;			end;	type		CInfoIntPane = object(CPane)				itsValue: integer;				numDigits: integer;				itsColor: RGBColor;				procedure CInfoIntPane.IInfoIntPane (anEnclosure: CView; aSupervisor: CBureaucrat; aWidth: Integer; aHeight: Integer; aHEncl: Integer; aVEncl: Integer; aHSizing: SizingOption; aVSizing: SizingOption);				procedure CInfoIntPane.setNumDigits (aNum: integer);				function CInfoIntPane.getNumDigits: integer;				procedure CInfoIntPane.setValue (aValue: integer);				function CInfoIntPane.getValue: integer;				procedure CInfoIntPane.setColor (aColor: RGBColor);				function CInfoIntPane.getColor: RGBColor;				procedure CInfoIntPane.draw (var area: rect);				override;			end;	type		CInfoTextPane = object(CPane)				itsText: str255;				itsColor: RGBColor;				procedure CInfoTextPane.IInfoTextPane (anEnclosure: CView; aSupervisor: CBureaucrat; aWidth: Integer; aHeight: Integer; aHEncl: Integer; aVEncl: Integer; aHSizing: SizingOption; aVSizing: SizingOption);				procedure CInfoTextPane.setText (aString: str255);				function CInfoTextPane.getText: str255;				procedure CInfoTextPane.setColor (aColor: RGBColor);				function CInfoTextPane.getColor: RGBColor;				procedure CInfoTextPane.Draw (var area: Rect);				override;			end;	type		CPlayer = object(CObject)				skippedLev: skipSet;				highLev, current, numskipped: integer;				name, level: str255;				time: longint;				procedure CPlayer.ChooseLevel;				procedure CPlayer.RenamePlayer;				procedure CPlayer.INewPlayer (aName: str255);				procedure CPlayer.openPlayer;				procedure CPlayer.savePlayer;				procedure CPlayer.setName (n: str255);				function CPlayer.getName: str255;				procedure CPlayer.setLevelName (n: str255);				function CPlayer.getLevelName: str255;				procedure CPlayer.setLevelNum (n: integer);				function CPlayer.getLevelNum: integer;			end;implementationend.
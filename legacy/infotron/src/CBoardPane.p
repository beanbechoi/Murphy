unit CBoardPane;interface	uses		TCL, InfoIntf;implementation	function PlotIconID (TheRect: Rect; Align: integer; Transform: integer; TheResID: INTEGER): OSErr;	inline		$303C, $0500, $ABC9;	procedure CBoardPane.IBoardPane (anEnclosure: CView; aSupervisor: CBureaucrat; aWidth, aHeight: integer; aHEncl, aVEncl: integer; aHSizing, aVSizing: SizingOption);	begin		IPane(anEnclosure, aSupervisor, aWidth, aHeight, aHEncl, aVEncl, aHSizing, aVSizing);		setUpOffScreen;	end;	procedure CBoardPane.GotNewBoard;		var			MurphLoc: point;			temprect: rect;			appState: InfoStatus;	begin		CGamePane(itsEnclosure).getBoard.getSize(LowerRight.h, LowerRight.v);		MurphLoc := CGamePane(itsEnclosure).getBoard.murphyStart;		CInfoAPp(gapplication).GetMurphy.SetLoc(murphLoc.h, murphLoc.v);		UpperLeft.v := MurphLoc.v - 5;		UpperLeft.h := MurphLoc.h - 7;		if (LowerRight.h - MurphLoc.h) < 6 then			UpperLeft.h := LowerRight.h - 14;		if (LowerRIght.v - MurphLoc.v) < 4 then			UpperLeft.v := LowerRight.v - 10;		if UpperLeft.h < 1 then			UpperLeft.h := 1;		if UpperLeft.v < 1 then			UpperLeft.v := 1;		DrawOffScreen;	end;	procedure CBoardPane.Free;	begin		DestroyGWorld(myOff);		inherited Free;	end;	procedure CBoardPane.MoveDown;		var			row, col: integer;			err: oserr;			temprect: rect;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;			icnID: integer;			uninitalizedRectangle: rect;	begin		getGWorld(oldGW, oldGD);		ignore := lockPixels(myOff^.portPixMap);		setGWorld(myOff, nil);		ForeColor(blackColor);		BackColor(whiteColor);		CopyBits(grafptr(myOff)^.portbits, grafptr(myOff)^.portbits, myOff^.portRect, pOffSetRect(myOff^.portRect, 0, -32), srcCopy, nil);		tempRect.bottom := 35 + 320 + 16;		tempRect.top := 35 + 320 - 16;		tempRect.left := 95 - 16;		tempRect.right := 95 + 16;		row := upperLeft.v + 11;		for col := 0 to 14 do			begin				icnID := CGamePane(itsEnclosure).itsBoard.getData(Upperleft.h + col, row);				err := PlotIconID(tempRect, 0, 0, icnID);				offsetRect(tempRect, 32, 0);			end;		UpperLeft.v := UpperLeft.v + 1;		setGWorld(oldGW, oldGD);		UnlockPixels(myOff^.PortPixMap);		draw(uninitalizedRectangle);	end;	procedure CBoardPane.MoveUp;		var			row, col: integer;			err: oserr;			temprect: rect;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;			icnID: integer;			uninitalizedRectangle: rect;	begin		getGWorld(oldGW, oldGD);		ignore := lockPixels(myOff^.portPixMap);		setGWorld(myOff, nil);		CopyBits(grafptr(myOff)^.portbits, grafptr(myOff)^.portbits, myOff^.portRect, pOffSetRect(myOff^.portRect, 0, 32), srcCopy, nil);		tempRect.top := 35 - 16;		tempRect.bottom := 35 + 16;		tempRect.left := 95 - 16;		tempRect.right := 95 + 16;		row := upperLeft.v - 1;		for col := 0 to 14 do			begin				icnID := CGamePane(itsEnclosure).itsBoard.getData(Upperleft.h + col, row);				err := PlotIconID(tempRect, 0, 0, icnID);				offsetRect(tempRect, 32, 0);			end;		UpperLeft.v := UpperLeft.v - 1;		setGWorld(oldGW, oldGD);		UnlockPixels(myOff^.PortPixMap);		draw(uninitalizedRectangle);	end;	procedure CBoardPane.MoveRight;		var			row, col: integer;			err: oserr;			temprect: rect;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;			icnID: integer;			uninitalizedRectangle: rect;	begin		getGWorld(oldGW, oldGD);		ignore := lockPixels(myOff^.portPixMap);		setGWorld(myOff, nil);		CopyBits(grafptr(myOff)^.portbits, grafptr(myOff)^.portbits, myOff^.portRect, pOffSetRect(myOff^.portRect, -32, 0), srcCopy, nil);		tempRect.top := 35 - 16;		tempRect.bottom := 35 + 16;		tempRect.left := 95 + 448 - 16;		tempRect.right := 95 + 448 + 16;		col := upperLeft.h + 15;		for row := 0 to 10 do			begin				icnID := CGamePane(itsEnclosure).itsBoard.getData(col, row + upperLeft.v);				err := PlotIconID(tempRect, 0, 0, icnID);				offsetRect(tempRect, 0, 32);			end;		UpperLeft.h := UpperLeft.h + 1;		setGWorld(oldGW, oldGD);		UnlockPixels(myOff^.PortPixMap);		draw(uninitalizedRectangle);	end;	procedure CBoardPane.MoveLeft;		var			row, col: integer;			err: oserr;			temprect: rect;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;			icnID: integer;			uninitalizedRectangle: rect;	begin		getGWorld(oldGW, oldGD);		ignore := lockPixels(myOff^.portPixMap);		setGWorld(myOff, nil);		CopyBits(grafptr(myOff)^.portbits, grafptr(myOff)^.portbits, myOff^.portRect, pOffSetRect(myOff^.portRect, 32, 0), srcCopy, nil);		tempRect.top := 35 - 16;		tempRect.bottom := 35 + 16;		tempRect.left := 95 - 16;		tempRect.right := 95 + 16;		col := upperLeft.h - 1;		for row := 0 to 10 do			begin				icnID := CGamePane(itsEnclosure).itsBoard.getData(col, row + upperLeft.v);				err := PlotIconID(tempRect, 0, 0, icnID);				offsetRect(tempRect, 0, 32);			end;		UpperLeft.h := UpperLeft.h - 1;		setGWorld(oldGW, oldGD);		UnlockPixels(myOff^.PortPixMap);		draw(uninitalizedRectangle);	end;	procedure CBoardPane.Draw1 (x, y: integer);{Plots an icon to the offscreen bitmap but does not draw the bitmap to the screen}		var			err: oserr;			icnID: integer;			tempRect: rect;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;	begin		if (x >= upperLeft.h) and (y >= upperLeft.v) and (x <= upperLeft.h + 14) and (y <= upperLeft.v + 10) then			begin				getGWorld(oldGW, oldGD);				ignore := lockPixels(myOff^.portPixMap);				setGWorld(myOff, nil);				icnID := CGamePane(itsEnclosure).getBoard.getData(x, y);				x := x - upperleft.h;				y := y - upperleft.v;				temprect.top := y * 32 + (35 - 16);				temprect.left := x * 32 + (95 - 16);				temprect.right := tempRect.left + 32;				temprect.bottom := tempRect.top + 32;{offsetRect(tempRect, hEncl, vEncl);}				err := PlotIconID(temprect, 0, 0, icnID);				setGWorld(oldGW, oldGD);				UnlockPixels(myOff^.PortPixMap);			end;	end;	procedure CBoardPane.DrawOne (x, y: integer);{Plots an icon to the offscreen bitmap and draws it to the screen automatically}		var			somethin_for_nutin_when_you_call_dominoes_because_nobody_knows_like_dominoes_how_you_like_pizza_at_home: rect;	begin		draw1(x, y);		draw(somethin_for_nutin_when_you_call_dominoes_because_nobody_knows_like_dominoes_how_you_like_pizza_at_home);	end;	procedure CBoardPane.DrawOffScreen;		var			x, y, icnID: integer;			oldGW: GWorldPtr;			oldGD: GDHandle;			ignore: boolean;			tempRect: rect;			err: OSErr;			r: rect;	begin		prepare;		getGWorld(oldGW, oldGD);		ignore := lockPixels(myOff^.portPixMap);		setGWorld(myOff, nil);		tempRect.top := 35 - 16;		tempRect.bottom := 35 - 16 + 32;		for y := 0 to 10 do			begin				tempRect.left := 95 - 16;				tempRect.right := 95 - 16 + 32;				for x := 0 to 14 do					begin						icnID := CGamePane(itsEnclosure).getBoard.getData(x + upperLeft.h, y + upperLeft.v);						if icnID = 300 then							icnId := 128;						err := PlotIconID(tempRect, 0, 0, icnID);						offsetRect(tempRect, 32, 0);					end;				offsetRect(tempRect, 0, 32);			end;		setGWorld(oldGW, oldGD);		UnlockPixels(myOff^.PortPixMap);		r.top := 35;		r.bottom := r.top + 320;		r.left := 95;		r.right := r.left + 448;		foreColor(blackcolor);		backColor(whitecolor);		copyWorldBits2(myOff, CView(itsSupervisor).macPort, r, POffsetRect(r, -95, -35));	end;	procedure CBoardPane.SetUpOffScreen;	begin		OffRect.top := 35 - 35;		OffRect.left := 95 - 35;		OffRect.bottom := 35 + 320 + 35;		OffRect.right := 96 + 448 + 35;		myOff := MakeGWorld(OffRect);	end;	procedure CBoardPane.Draw (var area: rect);		var			r: rect;			appStat: InfoStatus;	begin		prepare;		if hasLevel in CInfoApp(gapplication).GetInfoStatus then			begin				r.top := 35;				r.bottom := r.top + 320;				r.left := 95;				r.right := r.left + 448;				foreColor(blackcolor);				backColor(whitecolor);				copyWorldBits2(myOff, CView(itsSupervisor).macPort, r, POffsetRect(r, -95, -35));		{EAT THIS Ms. Verona!!!! HAHAHAHAHAHAHAHAHAHAHAHHAHAHAHA}			end		else			begin				RGBForeColor(myBlackColor);	{WWHAODHUSA}				FillRect(area, black);			end;		if fadeFromB in CInfoApp(gappliCATion).GetInfoStatus then			begin				appStat := CInfoAPp(gapplication).GetInfoStatus;				CInfoApp(gappliCATion).SetInfoStatus(appStat - [fadeFromB]);				FadeFromBlack(2);			end;	end;end.
type	CQuarkMover = object(CInfoChore)			quaX, quaY: integer;			lastAnim: integer;			currentDir: integer;			procedure IQuarkMover (quarkX, quarkY: integer);			procedure Perform (var maxSleep: longint);			override;		end;	CScissorMover = object(CInfoChore)			sciX, sciY: integer;			currentDir: integer;			lastAnim: integer;		{the last base animation frame; i.e. 0,2,4,6}			afterMed: integer;		{After being medium, add: 0 or 10}			currentSize: integer;	{can be 0,10,20 (small,large,medium)}			procedure IScissorMover (scissorX, scissorY: integer);			procedure Perform (var maxSleep: longint);			override;		end;procedure CScissorMover.IScissorMover (scissorX, scissorY: integer);begin	IInfoChore(scissorX, scissorY);	currentDir := GetData(scissorX, scissorY) mod 8;	lastAnim := currentDir;	afterMed := 10;		{get the open animation number}	currentSize := 0;		{the small size}	sciX := scissorX;	sciY := scissorY;	myIdent := -2;end;procedure CScissorMover.Perform (var maxSleep: longint);	procedure DoMove (oldX, oldY, newX, newY, newDir: integer);	begin		SetData(oldX, oldY, 129);		Draw1(oldX, oldY);		SetData(newX, newY, lastAnim + currentSize + 1000);		Draw1(newX, newY);		sciX := newX;		sciY := newY;		currentDir := newDir;	end;	procedure DoMovement;		var			dirLeft, dirRight: integer;			locS, locL, locR: point;			whatS, whatL, whatR: integer;	begin		facing := currentDir;		dirLeft := (facing + 6) mod 8;		dirRight := (facing + 2) mod 8;		locS := LocFromDir(x, y, facing);		locL := LocFromDir(x, y, dirLeft);		locR := LocFromDir(x, y, dirRight);		whatS := GetData(locS.h, locS.v);		whatL := GetData(locL.h, locL.v);		whatR := GetData(locR.h, locR.v);		if ((whatL >= 499) and (whatL <= 511)) or ((whatL >= 139) and (whatL <= 214)) or ((whatL >= 1200) and (whatL <= 1210)) then			GetMurphyObj.killMurphy		else if whatL = 129 then			DoMove(x, y, locL.h, locL.v, dirLeft)		else if ((whatS >= 499) and (whatS <= 511)) or ((whatS >= 139) and (whatS <= 214)) or ((whatS >= 1200) and (whatS <= 1210)) then			GetMurphyObj.killMurphy		else if whatS = 129 then			DoMove(x, y, locS.h, locS.v, facing)		else if ((whatR >= 499) and (whatR <= 511)) or ((whatR >= 139) and (whatR <= 214)) or ((whatR >= 1200) and (whatR <= 1210)) then			GetMurphyObj.killMurphy		else if whatR = 129 then			DoMove(x, y, locR.h, locR.v, dirRight)		else			DoMove(x, y, x, y, dirLeft);		{wants to turn}	end;	var		whatThere: integer;begin	whatThere := GetData(sciX, sciY);	if (whatThere >= 1000) and (whatThere <= 1026) then		begin			if currentSize = 20 then				begin					currentSize := afterMed;		{after medium, get to the right size}					afterMed := 10 - afterMed;	{switch directions}				end			else				currentSize := 20;		{the medium size}			DoMovement;		end	else		Remove;end;procedure CQuarkMover.IQuarkMover (quarkX, quarkY: integer);begin	IInfoChore(quarkX, quarkY);	currentDir := kRight;	lastAnim := GetData(quarkX, quarkY);	quaX := quarkX;	quaY := quarkY;	myIdent := -2;end;procedure CQuarkMover.Perform (var maxSleep: longint);	procedure DoMove (oldX, oldY, newX, newY, newDir: integer);	begin		SetData(oldX, oldY, 129);		Draw1(oldX, oldY);		SetData(newX, newY, lastAnim);		Draw1(newX, newY);		quaX := newX;		quaY := newY;		currentDir := newDir;	end;	procedure DoMovement;		var			dirLeft, dirRight: integer;			locS, locL, locR: point;			whatS, whatL, whatR: integer;	begin		facing := currentDir;		dirLeft := (facing + 6) mod 8;		dirRight := (facing + 2) mod 8;		locS := LocFromDir(x, y, facing);		locL := LocFromDir(x, y, dirLeft);		locR := LocFromDir(x, y, dirRight);		whatS := GetData(locS.h, locS.v);		whatL := GetData(locL.h, locL.v);		whatR := GetData(locR.h, locR.v);		if ((whatL >= 499) and (whatL <= 511)) or ((whatL >= 139) and (whatL <= 214)) or ((whatL >= 1200) and (whatL <= 1210)) then			GetMurphyObj.killMurphy		else if whatL = 129 then			DoMove(x, y, locL.h, locL.v, dirLeft)		else if ((whatS >= 499) and (whatS <= 511)) or ((whatS >= 139) and (whatS <= 214)) or ((whatS >= 1200) and (whatS <= 1210)) then			GetMurphyObj.killMurphy		else if whatS = 129 then			DoMove(x, y, locS.h, locS.v, facing)		else if ((whatR >= 499) and (whatR <= 511)) or ((whatR >= 139) and (whatR <= 214)) or ((whatR >= 1200) and (whatR <= 1210)) then			GetMurphyObj.killMurphy		else if whatR = 129 then			DoMove(x, y, locR.h, locR.v, dirRight)		else			DoMove(x, y, x, y, dirLeft);		{wants to turn}	end;	var		whatThere: integer;begin	whatThere := GetData(quaX, quaY);	if (whatThere >= 650) and (whatThere <= 657) then		begin			lastAnim := lastAnim + 1;			if lastAnim > 657 then				lastAnim := 650;			DoMovement;		end	else		Remove;end;
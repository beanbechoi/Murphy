{infod}unit CInfoDialog;interface	uses		ObjIntf, Picker, myRGBColors, QuickDrawProcs;	const		blankID = 136;		pieceID = 135;		dragID = 138;		charHeight = 14;	type		skipSet = set of 1..150;		levSet = skipSet;		CInfoDialog = object(CObject)				wind: windowPtr;				op: grafPtr;				picID: integer;				boxes: array[1..15] of rect;				buttons: array[1..15] of boolean;				active: array[1..15] of boolean;				procedure init (windID, pic: integer);				procedure rid;				procedure setUp;				procedure setBox (box: integer; r: rect; butt: boolean);				procedure pressButton (box: rect);				procedure unPressButton (box: rect);				function boxClicked (at: point): integer;				function returnHit: integer;				function MouseDown (var changed: integer): integer;				procedure Activate (box: integer; act: boolean);				procedure Redraw;			end;		CInfoScrollDialog = object(CInfoDialog)				scrollUp, scrollDown, dragPiece, bar, blackRect: rect;				scrollMove, scrollJump, piecePos: real;				enabled, nums: boolean;				num, top, bottom, hi, sel, height: integer;				skipped: levSet;				itsType: ResType;				list: array[1..100] of str255;				procedure CInfoScrollDialog.SortNamesList;				procedure center1String (place: integer);				procedure CDlogWithScroll.init2 (windID, pic, blackwidth, aHeight: integer; up, down: rect; theType: resType; withNums: boolean);				procedure setUp2 (byID: boolean);				procedure setLevs (hiLev, sela: integer; skips: levSet);				procedure pressButton (box: rect);				override;				procedure unPressButton (box: rect);				override;				procedure drawBlack;				procedure compScroll;				procedure Scroll (upDown: integer; var cur: integer);				procedure Jump (at: point);				procedure drag;				function findSelect (at: point): integer;				function boxClicked (at: point): integer;				override;				function GoUp: integer;				function GoDown: integer;				function MouseDown (var changed: integer): integer;				override;				procedure Redraw;				override;			end;	procedure setTextColorOf (c, hiLev: integer; skipped: levSet);implementation	procedure setTextColorOf (c, hiLev: integer; skipped: levSet);	begin		if (c < hilev) and not (c in skipped) then			RGBForeColor(myGreenColor)		else if c > hilev then			RGBForeColor(myRedColor)		else if c in skipped then			RGBForeColor(myBlueColor)		else			RGBForeColor(myYellowColor);	end;	procedure CInfoDialog.init (windID, pic: integer);		var			c: integer;	begin		wind := getNewCWindow(windID, nil, windowPtr(-1));		picID := pic;		for c := 1 to 15 do			setRect(boxes[c], -10, -10, -10, -10);	end;	procedure CInfoDialog.setUp;		var			at: point;	begin		at.h := 0;		at.v := 0;		bringToFront(wind);		showWindow(wind);		getPort(op);		setPort(wind);		drawPic(picID, at);	end;	procedure CInfoDialog.setBox (box: integer; r: rect; butt: boolean);	begin		boxes[box] := r;		buttons[box] := butt;		active[box] := true;	end;	procedure CInfoDialog.rid;	begin		hideWindow(wind);		setPort(op);	end;	procedure CInfoDialog.pressButton (box: rect);		var			r: rect;			idiot: grafPtr;	begin		BackColor(whiteColor);		getPort(windowPtr(idiot));		r := box;		moveto(r.left, r.bottom);		RGBForeColor(myLightGrayColor);		lineto(r.right, r.bottom);		lineto(r.right, r.top + 1);		moveto(r.left, r.bottom - 1);		RGBForeColor(myDarkGrayColor);		lineto(r.left, r.top);		lineto(r.right, r.top);		RGBForeColor(myBlackColor);		setRect(r, r.left + 1, r.top + 1, r.right - 2, r.bottom - 2);		box := r;		offSetRect(box, 1, 1);		copyBits(idiot^.portBits, idiot^.portBits, r, box, srcCopy, nil);	end;	procedure CInfoDialog.unPressButton (box: rect);		var			idiot: grafPtr;			r: rect;	begin		getPort(windowPtr(idiot));		r := box;		moveto(r.left, r.bottom);		RGBForeColor(myDarkGrayColor);		lineto(r.right, r.bottom);		lineto(r.right, r.top + 1);		moveto(r.left, r.bottom - 1);		RGBForeColor(myLightGrayColor);		lineto(r.left, r.top);		lineto(r.right, r.top);		RGBForeColor(myBlackColor);		setRect(r, r.left + 2, r.top + 2, r.right - 1, r.bottom - 1);		box := r;		offSetRect(box, -1, -1);		copyBits(idiot^.portBits, idiot^.portBits, r, box, srcCopy, nil);	end;	function CInfoDialog.boxClicked (at: point): integer;		var			bc, c: integer;	begin		bc := 0;		c := 0;		repeat			c := c + 1;			if ptInRect(at, boxes[c]) then				bc := c;		until (bc <> 0) or (c = 15);		boxClicked := bc;	end;	function CInfoDialog.returnHit: integer;		var			count: longint;	begin		pressButton(boxes[1]);		count := tickCount;		while tickCount < count + 4 do			;		unPressButton(boxes[1]);		returnHit := 1;	end;	function CInfoDialog.MouseDown (var changed: integer): integer;		var			down: boolean;			at: point;			event, new: integer;	begin		getMouse(at);		event := boxClicked(at);		if event = 0 then			begin				MouseDown := 0;				while button do					;			end		else if active[event] then			begin				if not buttons[event] then					MouseDown := event				else					begin						PressButton(boxes[event]);						down := true;						while button do							begin								getMouse(at);								new := boxClicked(at);								if (new <> event) and down then									begin										down := false;										unPressButton(boxes[event]);									end								else if (new = event) and not down then									begin										down := true;										PressButton(boxes[event]);									end;							end;						if down then							begin								unPressButton(boxes[event]);								MouseDown := event;							end						else							MouseDown := 0;					end;			end		else			event := 0;	end;	procedure CInfoDialog.Activate (box: integer; act: boolean);		var			r: rect;	begin		active[box] := act;{r := boxes[box];}{RGBForeColor(myGrayColor);}{moveto(r.left, r.bottom);}{if act then}{RGBForeColor(myDarkGrayColor);}{lineto(r.right, r.bottom);}{lineto(r.right, r.top + 1);}{moveto(r.left, r.bottom - 1);}{if act then}{RGBForeColor(myLightGrayColor);}{lineto(r.left, r.top);}{lineto(r.right, r.top);}{RGBForeColor(myBlackColor);}	end;	procedure CInfoDialog.Redraw;		var			at: point;	begin		at.h := 0;		at.v := 0;		bringToFront(wind);		showWindow(wind);		setPort(wind);		drawPic(picID, at);	end;	procedure _______________________;	begin	end;	procedure CInfoScrollDialog.center1String (place: integer);		const			NumW = 26;		var			w, textStart: integer;			lSide, rSide, y, size: integer;			col: RGBColor;			black: boolean;	begin		size := 12;		lSide := blackRect.left + 2;		rSide := blackRect.right - 2;		getForeColor(col);		black := (col.red = 0) and (col.blue = 0) and (col.green = 0);		if not black then			if place = sel then				textFace([bold])			else				textFace([]);		y := (blackRect.top - 2) + ((place - top + 1) * charheight);		moveTo(lSide, y);		w := stringWidth(list[place]);		if nums then			begin				drawInteger(place, 3);				if (place = sel) and (not black) then					moveTo(lSide + numW + 3, y - 4)				else					moveTo(lSide + numW, y - 4);				while w > (rSide - (lSide + numW + 3)) do					begin						size := size - 1;						textSize(size);						w := stringWidth(list[place]);					end;				textStart := (((rSide - lSide) - w + numW) div 2) + lSide;			end		else			begin				while w > (rSide - (lSide + 3)) do					begin						size := size - 1;						textSize(size);						w := stringWidth(list[place]);					end;				textStart := (((rSide - lSide) - w) div 2) + lSide;				moveTo(lSide, y - 4);			end;		lineTo(textStart - 3, y - 4);		moveTo(textStart, y);		drawString(list[place]);		moveTo(textStart + w + 2, y - 4);		lineTo(rSide, y - 4);		textSize(12);	end;	procedure CInfoScrollDialog.compScroll;	begin		enabled := num > height;		if enabled then			begin				scrollMove := (scrollDown.top - scrollUp.bottom - 4) / (num - height);				PiecePos := scrollUp.bottom + 2;				if top > 1 then					begin						PiecePos := PiecePos + (scrollMove * (top - 1));						if piecePos > (scrollDown.top - 14) then							piecePos := scrollDown.top - 14;					end;				setRect(dragPiece, scrollUp.left + 1, trunc(PiecePos), scrollUp.right - 1, trunc(PiecePos + 11));				drawPic(pieceID, dragPiece.topLeft);			end;	end;	procedure CInfoScrollDialog.setLevs (hiLev, sela: integer; skips: levSet);		var			height: integer;	begin		hi := hiLev;		skipped := skips;		sel := sela;	end;	procedure CInfoScrollDialog.init2 (windID, pic, blackwidth, aHeight: integer; up, down: rect; theType: resType; withNums: boolean);		var			h: handle;			c, d: integer;	begin		nums := withNums;		wind := getNewCWindow(windID, nil, windowPtr(-1));		picID := pic;		for c := 1 to 10 do			setRect(boxes[c], -10, -10, -10, -10);		scrollUp := up;		scrollDown := down;		setRect(bar, up.left, up.bottom + 1, up.right, down.top - 1);		setRect(blackRect, up.left - blackWidth - 4, up.top + 2, up.left - 5, down.bottom - 1);		hi := 9999;		height := aHeight;		itsType := theType;	end;	procedure CInfoScrollDialog.SortNamesList;		function greater (n1, n2: str255): boolean;{returns true if n1>n2}			var				place: integer;				len1, len2: integer;				done: boolean;		begin			done := false;			greater := false;			len1 := length(n1);			len2 := length(n2);			place := 1;			while (place <= len1) and (place <= len2) and not done do				begin					if n1[place] > n2[place] then						begin							done := true;							greater := true;						end					else if n1[place] < n2[place] then						done := true					else						place := place + 1;				end;		end;		var			tempstr: str255;			place, place2, loc: integer;	begin		for place := 1 to (num - 1) do			begin				loc := place;				for place2 := (place + 1) to num do					if greater(list[loc], list[place2]) then						loc := place2;				tempstr := list[place];				list[place] := list[loc];				list[loc] := tempstr;			end;	end;	procedure CInfoScrollDialog.setUp2 (byID: boolean);		var			c, d: integer;			h: handle;			typ: resType;	begin		if byID then			begin				num := Count1Resources(itsType);				for c := 301 to (300 + num) do					begin						h := get1Resource(itsType, c);						getResInfo(h, d, typ, list[c - 300]);					end;			end		else			begin				num := Count1Resources(itsType);				for c := 1 to num do					begin						h := get1IndResource(itsType, c);						getResInfo(h, d, typ, list[c]);					end;				sortNamesList;			end;		inherited setUp;		top := sel - (height div 2);		if top < 1 then			top := 1		else if top > num - height + 1 then			top := num - height + 1;		bottom := top + height - 1;		compScroll;		drawBlack;	end;	procedure CInfoScrollDialog.pressButton (box: rect);		var			color: RGBColor;			r: rect;	begin		r := box;		moveto(r.left, r.bottom);		RGBForeColor(myLightGrayColor);		lineto(r.right, r.bottom);		lineto(r.right, r.top + 1);		moveto(r.left, r.bottom - 1);		RGBForeColor(myDarkGrayColor);		lineto(r.left, r.top);		lineto(r.right, r.top);	end;	procedure CInfoScrollDialog.unPressButton (box: rect);		var			color: RGBColor;			r: rect;	begin		r := box;		moveto(r.left, r.bottom);		RGBForeColor(myDarkGrayColor);		lineto(r.right, r.bottom);		lineto(r.right, r.top + 1);		moveto(r.left, r.bottom - 1);		RGBForeColor(myLightGrayColor);		lineto(r.left, r.top);		lineto(r.right, r.top);	end;	procedure CInfoScrollDialog.Scroll (upDown: integer; var cur: integer);		var			r: rect;			oldBox, destBox: rect;			y, new, event, posShift: integer;			down: boolean;			at: point;			idiot: GrafPtr;	begin		backColor(whiteColor);		foreColor(blackColor);		event := (23 - upDown) div 2;		if upDown < 0 then			PressButton(scrollDown)		else			PressButton(scrollup);		down := true;		repeat			getMouse(at);			new := boxClicked(at);			if (new <> event) and down then				begin					down := false;					if upDown < 0 then						unPressButton(scrollDown)					else						unPressButton(scrollup);				end			else if (new = event) and not down then				begin					down := true;					if upDown < 0 then						PressButton(scrollDown)					else						PressButton(scrollup);				end;			if new = event then				begin					if ((upDown < 0) and (bottom < num)) or ((upDown > 0) and (top > 1)) then						begin							posShift := trunc(((-1) * (scrollMove * upDown)));							piecePos := piecePos - (scrollMove * upDown);							drawPic(blankID, dragPiece.topLeft);							if piecePos > scrollDown.top - 14 then								begin									PiecePos := scrollDown.top - 14;									setRect(dragPiece, scrollDown.left + 1, trunc(piecePos), scrollDown.right - 1, trunc(piecePos) + 12);								end							else if piecePos < scrollUp.bottom + 2 then								begin									PiecePos := scrollUp.bottom + 2;									setRect(dragPiece, scrollDown.left + 1, trunc(piecePos), scrollDown.right - 1, trunc(piecePos) + 12);								end							else								offSetRect(dragPiece, 0, posShift);							drawPic(pieceID, dragPiece.topLeft);							oldBox := blackRect;							destBox := blackRect;							r := blackRect;							foreColor(blackColor);							if upDown > 0 then								begin									oldBox.bottom := oldBox.bottom - charheight;									destBox.top := destBox.top + charheight;									r.bottom := r.top + charheight;								end							else								begin									oldBox.top := oldBox.top + charheight;									oldBox.bottom := oldBox.bottom + 1;									destBox.bottom := destBox.bottom - charheight + 1;									r.top := r.bottom - charheight;								end;							getPort(idiot);							copyBits(grafPtr(idiot)^.portBits, grafPtr(idiot)^.portBits, oldBox, destBox, srcCopy, nil);							if upDown < 0 then								begin									moveTo(blackRect.left, blackRect.top);									lineTo(blackRect.right, blackRect.top);									moveTo(blackRect.left, blackRect.bottom - 1);									lineTo(blackRect.right, blackRect.bottom - 1);								end;							fillRect(r, black);							top := top - upDown;							bottom := bottom - upDown;							cur := cur - upDown;							if ((upDown < 0) and (bottom <= num)) or ((upDown > 0) and (top >= 1)) then								if upDown < 0 then									begin										SetTextColorOf(bottom, hi, skipped);										Center1String(bottom);									end								else									begin										SetTextColorOf(top, hi, skipped);										Center1String(top);									end;						end;				end;		until not button;		if (upDown < 0) then			unPressButton(scrollDown)		else			unPressButton(scrollup);	end;	procedure CInfoScrollDialog.drawBlack;		var			c: integer;	begin		RGBForeColor(myBlackColor);		fillRect(blackRect, black);		textSize(12);		for c := top to bottom do			if c <= num then				begin					setTextColorOf(c, hi, skipped);					center1String(c);				end;	end;	procedure CInfoScrollDialog.Jump (at: point);		var			height: integer;	begin		height := (bottom - top + 1);		if at.v < dragPiece.top then			begin				if top > height then					begin						bottom := bottom - height;						top := top - height;					end				else					begin						bottom := height;						top := 1;					end;			end		else			begin				if bottom < (num - height) then					begin						bottom := bottom + height;						top := top + height;					end				else					begin						bottom := num;						top := num - height + 1;					end;			end;		piecePos := ((top - 1) * scrollMove) + scrollUp.bottom + 1;		if piecePos > (scrollDown.top - 14) then			piecePos := scrollDown.top - 14		else if piecePos < (scrollUp.bottom + 2) then			piecePos := scrollUp.bottom + 2;		drawPic(blankID, dragPiece.topLeft);		dragPiece.top := trunc(PiecePos + (1 / 2));		dragPiece.bottom := dragPiece.top + 12;		drawPic(pieceID, dragPiece.topLeft);		drawBlack;	end;	procedure CInfoScrollDialog.drag;		var			oldPt, at: point;			shift, newPlace, oldT: integer;	begin		oldT := top;		oldPt.v := trunc(piecePos + (1 / 2)) + 1;		oldPt.h := scrollUp.left + 1;		drawPic(dragID, oldPt);		getMouse(oldPt);		shift := trunc((oldPt.v - piecePos) + (1 / 2));		oldPt.v := oldPt.v - shift + 1;		oldPt.h := scrollUp.left + 1;		while button do			begin				getMouse(at);				at.v := at.v - shift;				if at.v > (scrollDown.top - 14) then					at.v := scrollDown.top - 14				else if at.v < (scrollUp.bottom + 2) then					at.v := scrollUp.bottom + 2;				at.h := scrollUp.left + 1;				if (at.v <> oldPt.v) then					begin						drawPic(blankID, oldPt);						drawPic(dragID, at);					end;				oldPt := at;			end;		newPlace := trunc((at.v - scrollUp.bottom + 2) / (scrollMove));		piecePos := (newPlace * scrollMove) + scrollUp.bottom + 2;		if piecePos > (scrollDown.top - 14) then			piecePos := scrollDown.top - 14		else if piecePos < (scrollUp.bottom + 2) then			piecePos := scrollUp.bottom + 2;		if at.v = scrollDown.top - 14 then			begin				newPlace := num - (bottom - top) - 1;				piecePos := at.v;			end;		dragPiece.top := trunc(PiecePos + (1 / 2));		dragPiece.bottom := dragPiece.top + 12;		drawPic(blankID, at);		at.v := trunc(piecePos + (1 / 2));		drawPic(pieceID, at);		bottom := newPlace + bottom - top + 1;		top := newPlace + 1;		if top <> oldT then			DrawBlack;	end;	function CInfoScrollDialog.findSelect (at: point): integer;		var			oldSel, clicked: integer;			place: real;	begin		place := at.v;		place := place - blackRect.top;		place := (place / charHeight);		place := (place + top);		clicked := trunc(place);		if clicked < top then			clicked := top;		if clicked > bottom then			clicked := bottom;		if list[clicked] = '' then			begin				if (list[sel] <> '') and (sel >= top) and (sel <= bottom) then					begin						RGBforeColor(myBlackColor);						textFace([bold]);						center1String(sel);						oldSel := sel;						sel := clicked;						setTextColorOf(oldSel, hi, skipped);						center1String(oldSel);					end;				clicked := 0;			end		else if sel <> clicked then			begin				if (list[sel] <> '') and (sel >= top) and (sel <= bottom) then					begin						RGBforeColor(myBlackColor);						textFace([bold]);						center1String(sel);						oldSel := sel;						sel := clicked;						setTextColorOf(oldSel, hi, skipped);						center1String(oldSel);					end				else					sel := clicked;				RGBforeColor(myBlackColor);				center1String(sel);				setTextColorOf(sel, hi, skipped);				center1String(sel);			end;		findSelect := clicked;		while button do			;	end;	function CInfoScrollDialog.boxClicked (at: point): integer;		var			bc, c: integer;	begin		bc := 0;		c := 0;		repeat			c := c + 1;			if ptInRect(at, boxes[c]) then				bc := c;		until (bc <> 0) or (c = 10);		if ptInRect(at, scrollUp) then			bc := 11		else if ptInRect(at, scrollDown) then			bc := 12		else if ptInRect(at, dragPiece) then			bc := 13		else if ptInRect(at, bar) then			bc := 14		else if ptInRect(at, blackRect) then			bc := 15;		boxClicked := bc;	end;	function CInfoScrollDialog.GoUp: integer;		var			posShift: integer;			oldBox, destBox, r: rect;			idiot: GrafPtr;			wait: longint;	begin		if sel > 1 then			if sel in [top..bottom] then				begin					RGBForeColor(myBlackColor);					textFace([bold]);					center1String(sel);					sel := sel - 1;					SetTextColorOf(sel + 1, hi, skipped);					Center1String(sel + 1);					if sel < top then						begin							top := top - 1;							bottom := bottom - 1;							posShift := trunc((-1) * (scrollMove));							piecePos := piecePos - scrollMove;							drawPic(blankID, dragPiece.topLeft);							if piecePos < scrollUp.bottom + 2 then								begin									PiecePos := scrollUp.bottom + 2;									setRect(dragPiece, scrollDown.left + 1, trunc(piecePos), scrollDown.right - 1, trunc(piecePos) + 12);								end							else								offSetRect(dragPiece, 0, posShift);							drawPic(pieceID, dragPiece.topLeft);							oldBox := blackRect;							destBox := blackRect;							r := blackRect;							foreColor(blackColor);							backColor(whiteColor);							oldBox.bottom := oldBox.bottom - charheight;							destBox.top := destBox.top + charheight;							r.bottom := r.top + charheight;							getPort(idiot);							copyBits(grafPtr(idiot)^.portBits, grafPtr(idiot)^.portBits, oldBox, destBox, srcCopy, nil);							fillRect(r, black);							SetTextColorOf(top, hi, skipped);							Center1String(top);						end					else						begin							RGBForeColor(myBlackColor);							textFace([]);							center1String(sel);							SetTextColorOf(sel, hi, skipped);							Center1String(sel);							wait := tickCount + 7;							repeat							until wait < tickCount;						end;				end			else if sel = bottom + 1 then				begin					sel := bottom;					RGBForeColor(myBlackColor);					textFace([]);					center1String(sel);					SetTextColorOf(sel, hi, skipped);					Center1String(sel);					wait := tickCount + 7;					repeat					until wait < tickCount;				end			else				begin					sel := sel - 1;					wait := tickCount + 4;					repeat					until wait < tickCount;				end;		goUp := sel;	end;	function CInfoScrollDialog.GoDown: integer;		var			posShift: integer;			oldBox, destBox, r: rect;			idiot: GrafPtr;			wait: longint;	begin		if sel < num then			if sel in [top..bottom] then				begin					RGBForeColor(myBlackColor);					textFace([bold]);					center1String(sel);					sel := sel + 1;					SetTextColorOf(sel - 1, hi, skipped);					Center1String(sel - 1);					if sel > bottom then						begin							top := top + 1;							bottom := bottom + 1;							posShift := trunc(scrollMove);							piecePos := piecePos + scrollMove;							drawPic(blankID, dragPiece.topLeft);							if piecePos > scrollDown.top - 14 then								begin									PiecePos := scrollDown.top - 14;									setRect(dragPiece, scrollDown.left + 1, trunc(piecePos), scrollDown.right - 1, trunc(piecePos) + 12);								end							else								offSetRect(dragPiece, 0, posShift);							drawPic(pieceID, dragPiece.topLeft);							oldBox := blackRect;							destBox := blackRect;							r := blackRect;							foreColor(blackColor);							backColor(whiteColor);							oldBox.top := oldBox.top + charheight;							oldBox.bottom := oldBox.bottom + 1;							destBox.bottom := destBox.bottom - charheight + 1;							r.top := r.bottom - charheight;							getPort(idiot);							copyBits(grafPtr(idiot)^.portBits, grafPtr(idiot)^.portBits, oldBox, destBox, srcCopy, nil);							moveTo(blackRect.left, blackRect.top);							lineTo(blackRect.right, blackRect.top);							moveTo(blackRect.left, blackRect.bottom - 1);							lineTo(blackRect.right, blackRect.bottom - 1);							fillRect(r, black);							SetTextColorOf(bottom, hi, skipped);							Center1String(bottom);						end					else						begin							RGBForeColor(myBlackColor);							textFace([]);							center1String(sel);							SetTextColorOf(sel, hi, skipped);							Center1String(sel);							wait := tickCount + 7;							repeat							until wait < tickCount;						end;				end			else if sel = top - 1 then				begin					sel := top;					RGBForeColor(myBlackColor);					textFace([]);					center1String(sel);					SetTextColorOf(sel, hi, skipped);					Center1String(sel);					wait := tickCount + 7;					repeat					until wait < tickCount;				end			else				begin					sel := sel + 1;					wait := tickCount + 4;					repeat					until wait < tickCount;				end;		goDown := sel;	end;	function CInfoScrollDialog.MouseDown (var changed: integer): integer;		var			down: boolean;			at: point;			event, new: integer;	begin		getMouse(at);		event := boxClicked(at);		if event = 0 then			begin				MouseDown := 0;				while button do					;			end		else if event = 15 then			begin				changed := findSelect(at);				mouseDown := event;			end		else if enabled and (event > 10) then			begin				mouseDown := event;				if (event = 11) or (event = 12) then					scroll(23 - (event * 2), changed)				else if event = 13 then					drag				else if event = 14 then					jump(at)			end		else if active[event] then			begin				if not buttons[event] then					MouseDown := event				else if event <= 10 then					begin						inherited PressButton(boxes[event]);						down := true;						while button do							begin								getMouse(at);								new := boxClicked(at);								if (new <> event) and down then									begin										down := false;										inherited unPressButton(boxes[event]);									end								else if (new = event) and not down then									begin										down := true;										inherited PressButton(boxes[event]);									end;							end;						if Down then							inherited unPressButton(boxes[event]);						if down then							MouseDown := event						else							MouseDown := 0;					end;			end		else			event := 0;	end;	procedure CInfoScrollDialog.Redraw;	begin		inherited redraw;		if enabled then			drawPic(pieceID, dragPiece.topLeft);		drawBlack;	end;end.
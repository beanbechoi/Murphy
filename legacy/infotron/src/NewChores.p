unit NewChores;interface	type		AnimArray = array[1..20] of integer;		MovingThingy = (murphy, scissor, quark, boulder, infotron);	type		CChorePtr = ^CChore;		CChore = record{CChore}				listIndex: integer;	{for managing in the chore lists}{CInfoChore}				xq, yq: integer;				myIdent: integer;{AnimChore}				animSequence: AnimArray;				animAt: integer;				finalAnim: integer;			{after everything is done}				delayBetween: longint;		{minimum delay between FRAMES}				lastTime: longint;{ContMoveChore}				removeOnRespond: BOOLEAN;{FallChore}				ix, iy: integer;{FallRollChore}				myDir: integer;{RollAfterChore}				uselessCount: integer;		{this is an absolutely useless counter.}{SuicideChore}{WaitInsChore}				toBeInstalled: CChorePtr;				countDown: integer;				HaveInstalled: BOOLEAN;{KillGameChore}{WaitTimeChore}				installedWhen: longint;{FallExplChore}{ContAnimChore}				cycleDelay: longint;		{or else}				inCycle: boolean;				betweenStart: longint;{ExplChore}{MoveChore}				direction, oldDir: integer;				numPixels: integer;				notSoAnim: AnimArray;				itIsA: MovingThingy;				moveThereAtFram: integer;				mtx, mty: integer;{MoveReplyChore}				myReplyTo: CChorePtr;			end;implementation	procedure IInfoChore (xe, ye: integer);	begin		xq := xe;		yq := ye;		myIdent := kInfoChore;	end;end.
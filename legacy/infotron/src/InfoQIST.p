unit QIST;{MODIFIED VERSION FOR INFOTRON ONLY; COULD CAUSE _SERIOUS_ PROBLEMS WITH OTHER PROGRAMS}{QIST - The Q Incorporated Sound Tool}{Q Incorporated: the only time that Q isn't followed by U!}{This code was used to produce sounds and music for Infotronª by Q Incorporated!}{This code is FREEWARE. It is ©1994 David Peck, all rights reserved.}{Written by David Peck}{PeckSoftware    (PeckSoftware@his.com)}{Junior: Montgomery Blair High School}{Math, Sciences, and Computer Science Magnet Program}{Started 5/3/94}{Based on the old, buggy, and defunct PeckSoftwareSoundTool}{(Hopefully, I will have corrected some bugs!)}{However, you may distribute it and use it, free of charge.}{If you use it, please send e-mail to PeckSoftware@his.com, with information on how}{you are using it. (I am just curious to see who uses it for what.)}interface{The data structures}	uses		sound;			{use Apple's sound file header}	const		MusicScoreRes = 'µsik';		kMusicTempo = 150;{Define note durations}		quarter = 1;		half = 2;		whole = 4;		eighth = 0.5;		sixteenth = 0.25;		quarterDot = 1.5;		halfDot = 3;		wholeDot = 6;		eighthDot = 0.75;		sixteenthDot = 0.375;	type		Str2 = packed array[0..2] of char;		Str16 = packed array[0..16] of char;		SixteenthInfo = record			{A sixteenth quantization of the sound track}				hasNote: boolean;		{TRUE if a new note should be played}				noteOver: boolean;	{TRUE if there is a note, whether new or otherwise, covering this area.}										{THIS INCLUDES RESTS}				isRest: boolean;		{Both hasNote and isRest should be TRUE if a rest is to be played.}				insName: integer;		{The instrument sound data, an integer referring to the soundHndls array.}				oct: integer;				{the octave.}				vol: integer;				{the volume of the note. Happens to be in SMF}				duration: real;			{the duration}				selNoter: integer;		{the selNote}				noteDuration: longint;	{the duration, saved in half miliseconds. in SMF.}				noteName: integer;		{the actual value for the note name, in SMF}			end;		TrackDataPtr = ^TrackData;		TrackData = array[1..3200] of SixteenthInfo;			{=200 MEASURES of music in 4/4 time}		TrackArray = array[1..4] of TrackDataPtr;		TOneStrArray = array[1..7] of Str16;		TOneSoundArray = array[1..21] of Handle;		TOneIntArray = array[1..21] of integer;		qmh = ^qmp;		qmp = ^quantizedMusic;		quantizedMusic = record				music: TrackArray;				soundNames: TOneIntArray;	{the res ids of the sounds}				soundHndls: TOneSoundArray;	{twenty one handles to each of the seven sounds, with all octaves (c4,c5,etc.) in mem!}				soundNumUsed: TOneIntArray;		{How many times each of the sounds is used in the music}				tempo: integer;		{the music tempo}				endPoint: longint;				loopBegin: longint;				currentPoint: longint;			end;		QISTMusicHandle = qmh;{Initalizing/Closing QIST}	procedure Init_QIST (useAsync: boolean);		{call at very beginning of application}	procedure Close_QIST;									{call when application is going to exit}{Cleaning routine - call every time you go through your main loop}	procedure CleanSounds;{Getting a RefID}	function LastGeneratedID: integer;		{all sounds have an associated refID with them. This can be used to stop them later on, if necessary.}		{some routines, such as the ContSound routines, automatically return an ID. Other's dont.}{Playing Sounds - Standard}	procedure PlaySound (soundId: integer);				{play 'snd ' resoure with a given id}	procedure PlaySoundName (soundName: str255);	{play 'snd ' resource with a given id}	procedure PlaySoundHandle (h: handle);				{play 'snd ' resource handle}{Halting Sounds}	procedure HaltSounds;				{stop _all_ sounds playing, including music}	procedure SoundState (state: boolean);	{send FALSE if you don't want any more sounds; TRUE if you do}{Continuous Sounds - Standard}	function ContSound (soundId: integer): integer;					{returns an integer sound reference}	function ContSoundName (soundName: str255): integer;	function ContSoundHandle (h: handle): integer;	procedure ContSoundStop (soundRef: integer);{Setting sound constraints}	procedure Cons_SoundPitch (note: str255; octave: integer);	{call this to set a cons_play's pitch}	procedure Cons_SoundVolume (vol: integer);						{set a cons_play's volume (0..255)}	procedure Cons_SoundDuration (dur: real);						{send one of the constants above}	procedure Cons_NormalPitch;										{Call this to reset a call to Cons_SoundPitch}	procedure Cons_NormalDuration;	procedure Cons_NormalVolume;	procedure Cons_Normal;{Playing Sounds - Constrained}	procedure Cons_PlaySound (soundId: integer);			{play 'snd ' resoure with a given id with given constraints}	procedure Cons_PlaySoundName (soundName: str255);	{play 'snd ' resource with a given id with given constraints}	procedure Cons_PlaySoundHandle (h: handle);				{play 'snd ' resource handle with given constraints}{Continuous Sounds - Constrained}	function Cons_ContSound (soundId: integer): integer;					{returns an integer sound reference}	function Cons_ContSoundName (soundName: str255): integer;	function Cons_ContSoundHandle (h: handle): integer;	procedure Cons_ContSoundStop (soundRef: integer);{Four Channel Music}	function LoadQISTMusic (resourceID: integer; var musicHandle: QISTMusicHandle): boolean;	procedure CloseQISTMusic (musicHandle: QISTMusicHandle);	function PlayQISTMusic (musicHandle: QISTMusicHandle): integer;  {maxVolume: (0..255)}	function ContPlayQISTMusic (musicHandle: QISTMusicHandle): integer;			{maxVolume: (0..255)}	procedure StopQISTMusic;	const		kMaxChannels = 8;	type		ConstraintData = record				cons_noteVal: integer;				cons_volVal: integer;				cons_durationVal: integer;			end;		MusicData = record				musicLoaded: boolean;			{true if there is music in memory}				musicPlaying: boolean;			{true if there is music playing}				musicContinuous: boolean;		{true if the music should be continuous}				musicMaxVol: integer;			{the max volume. All volumes in the 'µsik' are scaled down.}				theMusic: QISTMusicHandle;	{the music data}			end;		ChanData = record				refID: integer;				soundChan: SndChannelPtr;				sndHnd: handle;				freed: boolean;			end;		ChannelList = record				channelCount: integer;				lastSlot: integer;				channels: array[1..kMaxChannels] of ChanData;				cleanChans: array[1..kMaxChannels] of boolean;			end;		QISTData = record				hasAsync: boolean;				lastID: integer;				music: MusicData;				constraints: ConstraintData;				backgroundChannels: ChannelList;			end;	var		qdata: QISTData;		sounds: boolean;		err: OSErr;implementation{Callback Routines}{require that all compile options are OFF; especially DEBUG, which relies on correct A5 worlds}	procedure _____FORWARDS_____;	begin	end;	procedure I_MainPlayCont (chan: SndChannelPtr; slotNum: integer; afive: longint);		var			cmod: SndCommand;	begin		with cmod do			begin				cmd := CallBackCmd;				param1 := slotNum;				param2 := afive;			end;		err := SndPlay(chan, qdata.backgroundChannels.channels[slotNum].sndHnd, TRUE);		if err = noErr then			err := SndDoCommand(chan, cmod, FALSE);	end;	procedure _____CALLBACKS____;	begin	end;{$PUSH}{$D-}{$N-}{$V-}{$R-}	procedure CB_Standard (chan: SndChannelPtr; cmd: SndCommand);{standard callback; simply disposes of channel}		var			oldA5, old2A5: longint;	begin		oldA5 := SetA5(cmd.param2);		qdata.backgroundChannels.channels[cmd.param1].refID := 0;		qdata.backgroundChannels.cleanChans[cmd.param1] := TRUE;		old2A5 := SetA5(oldA5);	end;	procedure CB_Cont (chan: SndChannelPtr; cmd: SndCommand);{this one continues to play the sound, again and again}		var			oldA5, old2A5: longint;			slotNum: integer;	begin		oldA5 := SetA5(cmd.param2);{qdata.backgroundChannels.channels[cmd.param1].refID := 0;}{qdata.backgroundChannels.cleanChans[cmd.param1] := TRUE;}		I_MainPlayCont(chan, cmd.param1, cmd.param2);		old2A5 := SetA5(oldA5);	end;{$POP}{Internal QIST Routines}	procedure _____INTERNAL_____;	begin	end;	procedure I_MakeNote (name: str255; oct: integer; var noteVal: integer);		procedure Lower (var n: str255);			var				cnt: integer;		begin			for cnt := 1 to length(n) do				if (n[cnt] >= 'A') and (n[cnt] <= 'Z') then					n[cnt] := char(ord(n[cnt]) + 32);		end;		function vfn (n: str255): integer;		{vfn - Value From Name}		begin			if n = 'c' then				vfn := 0			else if (n = 'c+') or (n = 'd-') then				vfn := 1			else if n = 'd' then				vfn := 2			else if (n = 'd+') or (n = 'e-') then				vfn := 3			else if n = 'e' then				vfn := 4			else if n = 'f' then				vfn := 5			else if (n = 'f+') or (n = 'g-') then				vfn := 6			else if n = 'g' then				vfn := 7			else if (n = 'g+') or (n = 'a-') then				vfn := 8			else if n = 'a' then				vfn := 9			else if (n = 'a+') or (n = 'b-') then				vfn := 10			else if n = 'b' then				vfn := 11;		end;	begin		Lower(name);		noteVal := 60 + (12 * (oct - 4)) + vfn(name);{Extract out the note 'name' in snd manager format}														{In this format, 60=middle C, and each 12 numbers}														{is an octave.}	end;	function I_MakeRefID: integer;	begin		if qdata.lastID = maxint then			qdata.lastID := 1		else			qdata.lastID := qdata.lastID + 1;		I_MakeRefID := qdata.lastID	end;	procedure I_FindFreeSlot (var slotNum: integer);		var			findCount: integer;	begin		if qdata.backgroundChannels.channelCount >= kMaxChannels then			slotNum := -1		else			begin				findCount := 1;				while (findCount <= kMaxChannels) & (qdata.backgroundChannels.channels[findCount].soundChan <> nil) do					findCount := findCount + 1;				if findCount > kMaxChannels then					findCount := -1;				slotNum := findCount;			end;		qdata.backgroundChannels.lastSlot := slotNum;	end;	procedure I_FindFreeSlot2 (var slotNum: integer);		var			findCount: integer;	begin		findCount := 1;		while (findCount <= 4) & (not qdata.backgroundChannels.channels[findCount].freed) do			findCount := findCount + 1;		if findCount > 4 then			findCount := -1;		slotNum := findCount;		qdata.backgroundChannels.lastSlot := slotNum;	end;	procedure I_StopChan (var chan: SndChannelPtr);	begin		err := SndDisposeChannel(chan, TRUE);		chan := nil;	end;	procedure I_StopChanSlot (slotNum: integer);	begin		if qdata.backgroundChannels.channels[slotNum].soundChan <> nil then			begin				if slotNum > 4 then					I_StopChan(qdata.backgroundChannels.channels[slotNum].soundChan);				qdata.backgroundChannels.channels[slotNum].sndHnd := nil;				qdata.backgroundChannels.cleanChans[slotNum] := FALSE;				qdata.backgroundChannels.channels[slotNum].freed := TRUE;			end;	end;	procedure I_StopChanSlot2 (slotNum: integer);	begin		if qdata.backgroundChannels.channels[slotNum].soundChan <> nil then			begin				I_StopChan(qdata.backgroundChannels.channels[slotNum].soundChan);				qdata.backgroundChannels.channels[slotNum].sndHnd := nil;				qdata.backgroundChannels.cleanChans[slotNum] := FALSE;				qdata.backgroundChannels.channels[slotNum].freed := TRUE;			end;	end;	procedure I_SyncPlay (var sndHand: handle);	begin		err := SndPlay(nil, sndHand, false);	end;	procedure I_AsyncPlay (var sndHand: handle);		var			cmod: SndCommand;			slotNum: integer;			itsRefID: integer;	begin		I_FindFreeSlot2(slotNum);		if slotNum <> -1 then			begin				MoveHHi(sndHand);				HLock(sndHand);{    qdata.backgroundChannels.channels[slotNum].refID := I_MakeRefID;}				qdata.backgroundChannels.channels[slotNum].freed := FALSE;{    if (err = noErr) then}{    begin}				with cmod do					begin						cmd := CallBackCmd;						param1 := slotNum;						param2 := SetCurrentA5;					end;				err := SndPlay(qdata.backgroundChannels.channels[slotNum].soundChan, sndHand, TRUE);				if err = noErr then					err := SndDoCommand(qdata.backgroundChannels.channels[slotNum].soundChan, cmod, FALSE);{    end;}			end;	end;	procedure I_PlayHand (var sndHand: handle);	begin		if sounds then			if qdata.hasAsync then				I_AsyncPlay(sndHand)			else				I_SyncPlay(sndHand);	end;	procedure I_AsyncPlayCont (var sndHand: handle);		var			cmod: SndCommand;			slotNum: integer;			itsRefID: integer;	begin		I_FindFreeSlot(slotNum);		if slotNum <> -1 then			begin				MoveHHi(sndHand);				HLock(sndHand);				qdata.backgroundChannels.channels[slotNum].refID := I_MakeRefID;				err := SndNewChannel(qdata.backgroundChannels.channels[slotNum].soundChan, sampledSynth, initMono, @CB_Cont);				if (err = noErr) then					begin						qdata.backgroundChannels.channels[slotNum].sndHnd := sndHand;						I_MainPlayCont(qdata.backgroundChannels.channels[slotNum].soundChan, slotNum, SetCurrentA5);					end;			end;	end;	procedure I_PlayHandCont (var sndHand: handle);	begin		if sounds then			if qdata.hasAsync then				I_AsyncPlayCont(sndHand);	end;	procedure I_AsyncPlayCons (var sndHand: handle);		var			cbackcmd, ampcmde, freqcmde, sndcmde: SndCommand;			slotNum: integer;			itsRefID: integer;	begin		I_FindFreeSlot(slotNum);		if slotNum <> -1 then			begin				MoveHHi(sndHand);				HLock(sndHand);				qdata.backgroundChannels.channels[slotNum].refID := I_MakeRefID;				err := SndNewChannel(qdata.backgroundChannels.channels[slotNum].soundChan, sampledSynth, initMono, @CB_Standard);				if (err = noErr) then					begin						cbackcmd.cmd := callBackCmd;						cbackcmd.param1 := slotNum;						cbackcmd.param2 := SetCurrentA5;						ampcmde.cmd := ampCmd;						ampcmde.param1 := qdata.constraints.cons_volVal;						ampcmde.param2 := 0;						freqcmde.cmd := freqDurationCmd;						freqcmde.param1 := qdata.constraints.cons_durationVal;						freqcmde.param2 := qdata.constraints.cons_noteVal;						sndcmde.cmd := soundCmd;						sndcmde.param1 := 0;						sndcmde.param2 := longint(sndHand^) + 20;						err := SndDoCommand(qdata.backgroundChannels.channels[slotNum].soundChan, sndcmde, false);						err := SndDoCommand(qdata.backgroundChannels.channels[slotNum].soundChan, ampcmde, false);						err := SndDoCommand(qdata.backgroundChannels.channels[slotNum].soundChan, freqcmde, false);						err := SndDoCommand(qdata.backgroundChannels.channels[slotNum].soundChan, cbackcmd, false);					end;			end;	end;	procedure I_PlayConsHand (var sndHand: handle);	begin		if sounds then			if qdata.hasAsync then				I_AsyncPlayCons(sndHand);	end;	procedure HaltSounds2;				{stop _all_ sounds playing, including music}		var			haltCount: integer;	begin		StopQISTMusic;		for haltCount := 1 to kMaxChannels do			I_StopChanSlot2(haltCount);	end;	procedure _____PUBLIC_______;	begin	end;{Initalizing/Closing QIST}	procedure Init_QIST (useAsync: boolean);		{call at very beginning of application}		var			clearCount: integer;	begin		with qdata do			begin				hasAsync := useAsync;				lastID := 0;				with music do					begin						musicLoaded := FALSE;						musicPlaying := FALSE;						musicContinuous := FALSE;						musicMaxVol := 255;						theMusic := nil;					end;				Cons_Normal;				with backgroundChannels do					begin						channelCount := 0;						lastSlot := 0;						for clearCount := 1 to kMaxChannels do							begin								cleanChans[clearCount] := FALSE;								with channels[clearCount] do									begin										refID := 0;										err := SndNewChannel(soundChan, sampledSynth, initMono, @CB_Standard);										freed := TRUE;									end;							end;					end;			end;	end;	procedure Close_QIST;									{call when application is going to exit}	begin		HaltSounds2;{handle music; these check to see if they are really necessary}		StopQISTMusic;		CloseQISTMusic(qdata.music.theMusic);	end;{Cleaning routine - call every time you go through your main loop}	procedure CleanSounds;		var			chanCount: integer;	begin		for chanCount := 5 to kMaxChannels do			if qdata.backgroundChannels.cleanChans[chanCount] then				begin					if qdata.backgroundChannels.channels[chanCount].soundChan <> nil then						begin							err := SndDisposeChannel(qdata.backgroundChannels.channels[chanCount].soundChan, TRUE);							qdata.backgroundChannels.channels[chanCount].soundChan := nil;							qdata.backgroundChannels.channels[chanCount].freed := TRUE;						end;					qdata.backgroundChannels.cleanChans[chanCount] := FALSE;				end;	end;{Getting a RefID}	function LastGeneratedID: integer;	begin		LastGeneratedID := qdata.backgroundChannels.lastSlot;	end;{Playing Sounds - Standard}	procedure PlaySound (soundId: integer);				{play 'snd ' resoure with a given id}		var			sndHand: handle;	begin		sndHand := GetResource('snd ', soundId);		if sndHand <> nil then			I_PlayHand(sndHand);	end;	procedure PlaySoundName (soundName: str255);		{play 'snd ' resource with a given id}		var			sndHand: handle;	begin		sndHand := GetNamedResource('snd ', soundName);		if sndHand <> nil then			I_PlayHand(sndHand);	end;	procedure PlaySoundHandle (h: handle);				{play 'snd ' resource handle}	begin		if h <> nil then			I_PlayHand(h);	end;{Halting sounds}	procedure HaltSounds;				{stop _all_ sounds playing, including music}		var			haltCount: integer;	begin		StopQISTMusic;		for haltCount := 1 to kMaxChannels do			I_StopChanSlot(haltCount);	end;	procedure SoundState (state: boolean);	{send FALSE if you don't want any more sounds; TRUE if you do}	begin		if (sounds) and (not state) then			HaltSounds;		sounds := state;	end;{Continuous Sounds - Standard}	function ContSound (soundId: integer): integer;					{returns an integer sound reference}		var			sndHand: handle;	begin		sndHand := GetResource('snd ', soundId);		if sndHand <> nil then			I_PlayHandCont(sndHand);		ContSound := qdata.backgroundChannels.lastSlot;	end;	function ContSoundName (soundName: str255): integer;		var			sndHand: handle;	begin		sndHand := GetNamedResource('snd ', soundName);		if sndHand <> nil then			I_PlayHandCont(sndHand);		ContSoundName := qdata.backgroundChannels.lastSlot;	end;	function ContSoundHandle (h: handle): integer;	begin		if h <> nil then			I_PlayHandCont(h);		ContSoundHandle := qdata.backgroundChannels.lastSlot;	end;	procedure ContSoundStop (soundRef: integer);	begin		I_StopChanSlot(soundRef);	end;{Setting sound constraints}	procedure Cons_SoundPitch (note: str255; octave: integer);		{call this to set a cons_play's pitch}	begin		I_MakeNote(note, octave, qdata.constraints.cons_noteVal);	end;	procedure Cons_SoundVolume (vol: integer);			{set a cons_play's volume (0..255)}	begin		qdata.constraints.cons_volVal := vol;	end;	procedure Cons_SoundDuration (dur: real);	begin		qdata.constraints.cons_durationVal := trunc(dur * (60 / kMusicTempo) * 2000);	end;	procedure Cons_NormalPitch;									{Call this to reset a call to Cons_SoundPitch}	begin		qdata.constraints.cons_noteVal := 60;	end;	procedure Cons_NormalDuration;	begin		Cons_SoundDuration(whole);	end;	procedure Cons_NormalVolume;	begin		Cons_SoundVolume(255);	end;	procedure Cons_Normal;	begin		Cons_NormalPitch;		Cons_NormalDuration;		Cons_NormalVolume;	end;{Playing Sounds - Constrained}	procedure Cons_PlaySound (soundId: integer);			{play 'snd ' resoure with a given id with given constraints}		var			sndHand: handle;	begin		sndHand := GetResource('snd ', soundId);		if sndHand <> nil then			I_PlayConsHand(sndHand);	end;	procedure Cons_PlaySoundName (soundName: str255);	{play 'snd ' resource with a given id with given constraints}		var			sndHand: handle;	begin		sndHand := GetNamedResource('snd ', soundName);		if sndHand <> nil then			I_PlayConsHand(sndHand);	end;	procedure Cons_PlaySoundHandle (h: handle);				{play 'snd ' resource handle with given constraints}	begin		if h <> nil then			I_PlayConsHand(h);	end;{Continuous Sounds - Constrained}	function Cons_ContSound (soundId: integer): integer;					{returns an integer sound reference}	begin	end;	function Cons_ContSoundName (soundName: str255): integer;	begin	end;	function Cons_ContSoundHandle (h: handle): integer;	begin	end;	procedure Cons_ContSoundStop (soundRef: integer);	begin	end;{Four Channel Music}	function LoadQISTMusic (resourceID: integer; var musicHandle: QISTMusicHandle): boolean;	begin	end;	procedure CloseQISTMusic (musicHandle: QISTMusicHandle);	begin	end;	function PlayQISTMusic (musicHandle: QISTMusicHandle): integer;	begin	end;	function ContPlayQISTMusic (musicHandle: QISTMusicHandle): integer;	begin	end;	procedure StopQISTMusic;	begin	end;end.
unit CGreenDisk;interface	uses		TCL, GridPieceIntf;implementation	procedure CGreenDisk.InitPiece;	begin		inherited InitPiece;		falls := true;	end;	procedure CGreenDisk.Fall (x, y: integer);		var			myChore: CFallExplChore;	begin		new(myChore);		myChore.IFallExplChore(x, y);		CInfoApp(gApplication).FudADD(myChore);	end;	function CGreenDisk.Push (x, y: integer): BOOLEAN;		var			murGT, murCF: integer;			whereTo: point;			iAm: integer;			myChore: CMoveChore;			whatAt: integer;			pushedTo: point;			whatBelow: integer;	begin		murGT := CInfoApp(gApplication).GetMurphy.GetLastDir;		murCF := 8 - murGT;		whereTo := CInfoApp(gApplication).LocFromDir(x, y, murGT);		whatAt := CInfoApp(gApplication).GetGPane.GetBoard.GetData(whereTo.h, whereTo.v);{whatBelow := CINfoapp(gapplication).GetGPane.GetBoard.GetData(x, y + 1);}		iAm := CInfoApp(gApplication).GetGPane.GetBoard.GetData(x, y);		Push := FALSE;		if whatAt = 129 then			begin				pUsH := true;				whatAt := CInfoApp(gApplication).GetGPane.GetBoard.GetData(x, y);				CInfoApp(gapplication).GetGPane.GetBoard.SetData(whereTo.h, whereTo.v, whatAt);				CInfoApp(gapplication).GetGPane.GetBoard.boardData^^.theBoard[x, y] := 129;				CInfoAPp(gapplication).GetGPane.GetBPane.Draw1(x, y);				CInfoApp(gapplication).GetGPane.GetBPane.Draw1(whereTo.h, whereTo.v);				self.CheckFall(whereTo.h, whereTo.v);			end;	end;	function CGreenDisk.WalkOnto (x, y: integer): BOOLEAN;	begin		WalkOnto := false;		if (CInfoApp(gApplication).GetMurphy.GetLastDir = kRight) or (CInfoApp(CInfoApp(gApplication)).GetMurphy.GetLastDir = kLeft) then			WalkOnto := Push(x, y);	end;end.
unit CFallChore;			{For things that fall DOWN. Do NOT ROLL with this!}interface	uses		TCL, BackChoresIntf;implementation	procedure CFallChore.IFallChore (x, y: integer);	begin		IInfoChore(x, y);		ix := x;		iy := y;		myIdent := kFallChore;	end;	procedure CFallChore.DoOneFall;		var			belowWhat: integer;			myBelow: CGridPiece;			what: integer;	begin		belowWhat := CInfoApp(gApplication).GetGPane.GetBoard.GetData(xq, yq + 1);		myBelow := CInfoApp(gapplication).GetGridObj(xq, yq + 1);		if myBelow.canExplode then			begin				myBelow.explode(xq, yq + 1);				remove;			end		else if (belowWhat <> 129) then			HitBottom		else			begin				what := CInfoApp(gApplication).GetGPane.GetBoard.GetData(xq, yq);				CInfoApp(gApplication).GetGPane.GetBoard.SetData(xq, yq, 129);				CInfoApp(gApplication).GetGPane.GetBPane.Draw1(xq, yq);				yq := yq + 1;				CInfoApp(gApplication).GetGPane.GetBoard.SetData(xq, yq, what);				CInfoApp(gApplication).GetGPane.GetBPane.Draw1(xq, yq);			end;	end;	procedure CFallChore.HitBottom;		var			whatHere: integer;			o: CGridPiece;			theDir: integer;			mySuicide: CSuicideChore;	begin		o := CInfoApp(gapplication).GetGridObj(xq, yq);		theDir := CInfoApp(gapplication).GetNextRollDir;{    if not o.CheckRoll(xq, yq, theDir) then}{    if not o.CheckRoll(xq, yq, 8 - theDir) then}{    begin		{well, since I can't roll, i better have a suicide chore for myself!}		new(mySuicide);		mySuicide.ISuicideChore(xq, yq);		CInfoApp(gapplication).FudADD(mySuicide);{    end;}{    CInfoApp(gapplication).ToggleRollDir;}		PlaySound(sThud);		remove;	end;	procedure CFallChore.Perform (var maxSleep: longint);		var			what: integer;	begin		what := CInfoApp(gapplication).GetGPane.GetBoard.GetData(xq, yq);		if shouldRemove then			remove		else if ((what >= 499) and (what <= 511)) or ((what >= 139) and (what <= 214)) or ((what >= 1200) and (what <= 1210)) then			CInfoApp(gapplication).GetMurphyObj.Explode(xq, yq)		else			DoOneFall;	end;end.
unit TheChores;{NO OOP}interface	uses		ObjIntf, QDOffscreen, sound, gammapasLibIntf, {}		coloroffscreen, myRGBColors, CInfoDialog, ColorOffScreen, {}		QIST, menubars, QuickDrawProcs, InfoWindows, {}		dataIntf, everything;implementation	procedure CAnimChore.IAnimChore (as: AnimArray; fa: integer; db: longint; x, y: integer);	begin		IInfoChore(x, y);		animSequence := as;		animAt := 1;		finalAnim := fa;		delayBetween := db;		lastTime := 0;		myIdent := kAnimChore;	end;	procedure CAnimChore.DrawAt;	begin		SetData(xq, yq, animSequence[animAt]);		Draw1(xq, yq);	end;	procedure CAnimChore.SequenceDone;	begin		remove;	end;	procedure CAnimChore.FrameDone;	begin	end;	procedure CAnimChore.DoOneFrame;	begin		if tickCount - lastTime > delayBetween then			begin		{do one animate frame}				if animSequence[1] = 358 then					if (GetData(xq, yq) > 599) and (GetData(xq, yq) < 611) then						remove;{    if animSequence[1] = 600 then}{    if (GetData(xq, yq) > 349) and (GetData(xq, yq) < 359) then}{    remove;}				DrawAt;				lastTime := tickCount;				FrameDone;				animAt := animAt + 1;			end;		if animAt > finalAnim then			SequenceDone;	end;	procedure CAnimChore.Perform (var maxSleep: longint);	begin		DoOneFrame;		if animAt > finalAnim then			remove;	end;	procedure CContAnimChore.SequenceDone;	begin		inCycle := false;		betweenStart := tickCount;	end;	procedure CContAnimChore.IContAnimChore (cd: longint; as: AnimArray; fa: integer; db: longint; x, y: integer);	begin		cycleDelay := cd;		inCycle := true;		IAnimChore(as, fa, db, x, y);		myIdent := kContAnimChore;	end;	procedure CContAnimChore.Perform (var maxSleep: longint);		var			whatThere: integer;			mx, my: integer;	begin		whatThere := GetData(xq, yq);		if ShouldRemove then			Remove		else if not ((whatthere = 128) or ((whatThere >= 300) and (whatThere <= 305)) or ((whatThere >= 550) and (whatThere <= 561))) then			Remove		else if inCycle then			DoOneFrame		else if tickCount - betweenStart > cycleDelay then			begin				if animSequence[1] = 300 then					begin						GetLoc(mx, my);						PlaySoundDistRange(sBugZap, mx, my, xq, yq, kBugRange);	{murphy in proximity}					end;				IAnimChore(animSequence, finalAnim, delayBetween, xq, yq);				inCycle := true;			end;	end;	procedure CExplChore.IExplChore (x, y: integer; aas: AnimArray; fa: integer);	begin		IAnimChore(aas, fa, 0, x, y);		myIdent := kExplChore;	end;	procedure CExplChore.FrameDone;		var			xloc, yloc: integer;			whatIsWhereIAm: integer;	begin		if animAt = 1 then			if not gAARDVARK_PLATYPUSS_WOMBAT then				begin					GetLoc(xloc, yloc);					if (xloc = xq) and (yloc = yq) then						GetMurphyObj.KillMurphy;				end;		if animAt = 3 then			begin				PlaySound(sExplode);				for xloc := xq - 1 to xq + 1 do					for yloc := yq - 1 to yq + 1 do						if (xloc <> xq) or (yloc <> yq) then							begin								if GetGridObj(xloc, yloc).CanExplode then									GetGridObj(xloc, yloc).Explode(xloc, yloc)								else									GetGridObj(xloc, yloc).Destroy(xloc, yloc);							end;			end;	end;{----}	procedure CFallRollChore.IFallChore (x, y: integer; theDir: integer);	begin		IInfoChore(x, y);		ix := x;		iy := y;		myDir := theDir;		myIdent := kFallChore;	end;	procedure CFallRollChore.DoOneFall;		var			belowWhat: integer;			myBelow: CGridPiece;			what: integer;	begin		belowWhat := GetData(xq, yq + 1);		myBelow := GetGridObj(xq, yq + 1);		if myBelow.canExplode then			begin				myBelow.explode(xq, yq + 1);				remove;			end		else if not MoveInfo(xq, yq + 1) then			{belowWhat<>129}			begin				SetData(xq, yq, 700);				Draw1(xq, yq);				HitBottom;			end		else			begin	{THE FOLLOWING ROUTINES WERE CHANGED}				what := GetData(xq, yq);				if (what > 700) and (what <= 703) then					begin						if myDir = kRight then							begin								what := what + 1;								if what = 704 then									what := 700;							end						else							begin								what := what - 1;								if what = 699 then									what := 703;							end;					end;				SetData(xq, yq + 1, what);		{set the new data}				Draw1(xq, yq + 1);{    MoveThere(xq, yq + 1, TRUE);}				fallChores^[xq, yq + 1] := TRUE;				SetData(xq, yq, 129);			{set the old data}				Draw1(xq, yq);				fallChores^[xq, yq] := FALSE;				yq := yq + 1;						{now move}			end;	end;	procedure CFallRollChore.HitBottom;		var			whatHere: integer;			o: CGridPiece;			theDir: integer;	begin		o := GetGridObj(xq, yq);		theDir := GetNextRollDir;		remove;		fallChores^[xq, yq] := FALSE;		if not o.CheckRoll(xq, yq, theDir) then			if not o.CheckRoll(xq, yq, 8 - theDir) then				;		PlaySound(sThud);	end;	procedure CFallRollChore.Perform (var maxSleep: longint);		var			what: integer;	begin		what := GetData(xq, yq);		if shouldRemove then			begin				remove;				fallChores^[xq, yq] := FALSE;			end		else if ((what >= 499) and (what <= 511)) or ((what >= 139) and (what <= 214)) or ((what >= 1200) and (what <= 1210)) then			GetMurphyObj.Explode(xq, yq)		else			DoOneFall;	end;{----}	procedure CFallChore.IFallChore (x, y: integer);	begin		IInfoChore(x, y);		ix := x;		iy := y;		myIdent := kFallChore;	end;	procedure CFallChore.DoOneFall;		var			belowWhat: integer;			myBelow: CGridPiece;			what: integer;	begin		belowWhat := GetData(xq, yq + 1);		myBelow := GetGridObj(xq, yq + 1);		what := GetData(xq, yq);		if (what > 349) and (what < 359) then			remove		else if myBelow.canExplode then			begin				myBelow.explode(xq, yq + 1);				remove;			end		else if not MoveInfo(xq, yq + 1) then			{belowWhat<>129}			HitBottom		else			begin	{THE FOLLOWING ROUTINES WERE CHANGED}				what := GetData(xq, yq);				SetData(xq, yq + 1, what);		{set the new data}				Draw1(xq, yq + 1);{    MoveThere(xq, yq + 1, TRUE);}				fallChores^[xq, yq + 1] := TRUE;				SetData(xq, yq, 129);			{set the old data}				Draw1(xq, yq);				fallChores^[xq, yq] := FALSE;				yq := yq + 1;						{now move}			end;	end;	procedure CFallChore.HitBottom;		var			whatHere: integer;			o: CGridPiece;			theDir: integer;	begin		o := GetGridObj(xq, yq);		theDir := GetNextRollDir;		remove;		fallChores^[xq, yq] := FALSE;		if o.explodes then			o.explode(xq, yq)		else if not o.CheckRoll(xq, yq, theDir) then			if not o.CheckRoll(xq, yq, 8 - theDir) then				;		PlaySound(sThud);	end;	procedure CFallChore.Perform (var maxSleep: longint);		var			what: integer;	begin		what := GetData(xq, yq);		if shouldRemove then			begin				remove;				fallChores^[xq, yq] := FALSE;			end		else if ((what >= 499) and (what <= 511)) or ((what >= 139) and (what <= 214)) or ((what >= 1200) and (what <= 1210)) then			GetMurphyObj.Explode(xq, yq)		else			DoOneFall;	end;	procedure CFallExplChore.IFallExplChore (x, y: integer);	begin		IFallChore(x, y);	end;	procedure CFallExplChore.HitBottom;	begin		GetGridObj(xq, yq).explode(xq, yq);		remove;	end;	procedure CInfoChore.IInfoChore (xe, ye: integer);	begin		xq := xe;		yq := ye;		myIdent := kInfoChore;	end;	procedure CInfoChore.GetChoreLoc (var cx, cy: integer);	begin		cx := xq;		cy := yq;	end;	function CInfoChore.Identify: integer;	begin		identify := myIdent mod 1000;	end;	function CInfoChore.ShouldRemove: boolean;		var			dat: integer;	begin		dat := getdata(xq, yq);		ShouldRemove := (dat >= 600) and (dat <= 610);	end;	procedure CInfoChore.Remove;	begin		if myIdent < 1000 then			begin				if (myIdent = kFallChore) or (myIdent = kMoveChore) then					fallChores^[xq, yq] := FALSE;				FudRID(self);				myIdent := 1000 + myIdent;			end;	end;	procedure CInfoChore.FreeMemory;		{do nothing here; other objects might want to free themselves??}	begin	end;	procedure CInfoChore.Free;	begin		remove;	end;	procedure CKillGameChore.IKillGameChore;	begin		IInfoChore(1, 1);	{doesn't matter}		myIdent := kKillGameChore;	end;	procedure CKillGameChore.Perform (var maxSleep: longint);		var			appStat: InfoStatus;	begin		appStat := GetInfoStatus;		SetInfoStatus(appStat - [isPlaying]);		ShowCursor;		AddToTime(getGameTime);		KillChores;{remove;}	end;	procedure CMoveChore.MakeArray;		procedure MakeMurMove;		begin			case direction of				kUp, kRight: 					begin						animSequence[1] := 205;						animSequence[2] := 203;						animSequence[3] := 201;						animSequence[4] := 203;						animSequence[5] := 205;						finalAnim := 5;						moveThereAtFram := 3;					end;				kDown, kLeft: 					begin						animSequence[1] := 206;						animSequence[2] := 204;						animSequence[3] := 202;						animSequence[4] := 204;						animSequence[5] := 206;						finalAnim := 5;						moveThereAtFram := 3;					end;			end;		end;		procedure MakeSciMove;			var				c: integer;				di: integer;		begin			di := direction;			if di = kNoMove then				di := (oldDir + 2) mod 8;			if oldDir = di then				begin					animSequence[1] := 1000 + di;					animSequence[2] := 1150 + di;					animSequence[3] := 1000 + di;					finalAnim := 3;					moveThereAtFram := 2;				end			else if ((oldDir - di) + 8) mod 8 = 2 then		{truning left}				begin					animSequence[1] := 1000 + oldDir;					animSequence[2] := 999 + oldDir;					animSequence[3] := 998 + oldDir;					animSequence[4] := 1148 + oldDir;					animSequence[5] := 998 + oldDir;					finalAnim := 5;					moveThereAtFram := 3;					for c := 1 to 5 do						if c <> 4 then							begin								if animSequence[c] < 1000 then									animSequence[c] := animSequence[c] + 8;								if animSequence[c] > 1007 then									animSequence[c] := animSequence[c] - 8;							end						else if animSequence[4] < 1150 then							animSequence[4] := animSequence[4] + 8						else if animSequence[4] > 1157 then							animSequence[4] := animSequence[4] - 8;				end			else				begin					animSequence[1] := 1000 + oldDir;					animSequence[2] := 1001 + oldDir;					animSequence[3] := 1002 + oldDir;					animSequence[4] := 1152 + oldDir;					animSequence[5] := 1002 + oldDir;					for c := 1 to 5 do						if c <> 4 then							begin								if animSequence[c] < 1000 then									animSequence[c] := animSequence[c] + 8;								if animSequence[c] > 1007 then									animSequence[c] := animSequence[c] - 8;							end						else if animSequence[4] < 1150 then							animSequence[4] := animSequence[4] + 8						else if animSequence[4] > 1157 then							animSequence[4] := animSequence[4] - 8;					finalAnim := 5;					moveThereAtFram := 3;				end;		end;		procedure MakeQuaMove;			var				startAt: integer;				count: integer;		begin			startAt := GetData(xq, yq);			for count := 0 to 3 do				begin					animSequence[count + 1] := startAt + count;					if animSequence[count + 1] > 657 then						animSequence[count + 1] := animSequence[count + 1] - 8;				end;			finalAnim := 4;			moveThereAtFram := 2;		end;		procedure MakeBolMove;		begin			if direction = kDown then				begin					animSequence[1] := 700;					animSequence[2] := 700;					finalAnim := 2;					moveThereAtFram := 1;				end			else if direction > kDown then				begin					animSequence[1] := 700;					animSequence[2] := 703;					animSequence[3] := 702;					animSequence[4] := 701;					animSequence[5] := 700;					finalAnim := 5;					moveThereAtFram := 3;				end			else if direction < kDown then				begin					animSequence[1] := 700;					animSequence[2] := 701;					animSequence[3] := 702;					animSequence[4] := 703;					animSequence[5] := 700;					finalAnim := 5;					moveThereAtFram := 3;				end;		end;		procedure MakeInfMove;		begin			animSequence[1] := 850;			animSequence[2] := 851;			animSequence[3] := 852;			animSequence[4] := 853;			animSequence[5] := 850;			finalAnim := 5;			moveThereAtFram := 3;		end;	begin		case itIsA of			murphy: 				MakeMurMove;			scissor: 				MakeSciMove;			quark: 				MakeQuaMove;			boulder: 				MakeBolMove;			infotron: 				MakeInfMove;		end;	end;	procedure CMoveChore.FrameDone;		var			whichSci, whichQua: integer;			dd: integer;			o: CGridPiece;	begin{    if (itIsA = boulder) or (itIsA = infotron) then}{    begin}{    dd := CInfoApp(gapplication).GetGPane.GetBoard.GetData(xq, yq + 1);}{o := CInfoApp(gapplication).GetGridObj(xq, yq);}{    if (dd = 129) then}{    begin}{    o.Fall(xq, yq);}{    remove;}{    Exit(frameDone);	{no more!}{    end;}{    end;}		if animAt = moveThereAtFram then			begin				dd := GetData(mtx, mty);				if (dd = 129) then					begin						SetData(xq, yq, 129);						Draw1(xq, yq);						if itIsA = scissor then							begin								whichSci := WhichScissor(xq, yq);								if whichSci <> -1 then									MovedScissor(whichSci, direction);							end;						if itIsA = quark then							begin								whichQua := WhichQuark(xq, yq);								if whichQua <> -1 then									MovedQuark(whichQua, direction);							end;						fallChores^[xq, yq] := FALSE;						fallChores^[mtx, mty] := TRUE;						xq := mtx;						yq := mty;					end				else					begin						if itIsA = scissor then							begin								whichSci := WhichScissor(xq, yq);								if whichSci <> -1 then									MovedScissor(whichSci, 8);							end						else if itIsA = quark then							begin								whichQua := WhichQuark(xq, yq);								if whichQua <> -1 then									MovedQuark(whichQua, 8);							end						else							begin								fallingInfo^[mtx, mty] := TRUE;								fallingInfo^[mtx, mty + 1] := TRUE;							end;					end;				SetData(xq, yq, animSequence[animAt]);				Draw1(xq, yq);			end;	end;	procedure CMoveChore.IMoveChore (d: integer; oldD: integer; whatIsIt: MovingThingy; x, y: integer);	begin		IAnimChore(animSequence, finalAnim, 0, x, y);		myIdent := kMoveChore;		direction := d;		oldDir := oldD;		itIsA := whatIsIt;		case d of			kNoMove: 				begin					mtx := x;					mty := y;				end;			kUp: 				begin					mtx := x;					mty := y - 1;				end;			kRight: 				begin					mtx := x + 1;					mty := y;				end;			kDown: 				begin					mtx := x;					mty := y + 1;				end;			kLeft: 				begin					mtx := x - 1;					mty := y;				end;			kUpRight: 				begin					mtx := x + 1;					mty := y - 1;				end;			kUpLeft: 				begin					mtx := x - 1;					mty := y - 1;				end;			kDownRight: 				begin					mtx := x + 1;					mty := y + 1;				end;			kDownLeft: 				begin					mtx := x - 1;					mty := y + 1;				end;		end;		MakeArray;	end;	procedure CMoveChore.SequenceDone;		var			whatHere: integer;			o: CGridPiece;			theDir: integer;	begin		inherited SequenceDone;		if (itIsA = boulder) or (itIsA = infotron) then			begin				o := GetGridObj(xq, yq);				theDir := GetNextRollDir;				whatHere := GetData(xq, yq + 1);				if whatHere = 129 then					begin						o.Fall(xq, yq);						MoveThere(xq, yq + 1, TRUE);					end			{? is this ok}				else if ((whatHere >= 139) and (whatHere <= 214)) or ((whatHere >= 499) and (whatHere <= 511)) then					begin						GetMurphyObj.killMurphy;					end				else if not o.CheckRoll(xq, yq, theDir) then					if not o.CheckRoll(xq, yq, 8 - theDir) then						;				ToggleRollDir;			end;	end;	procedure CMoveChore.Perform (var maxSleep: longint);		var			what: integer;	begin		what := GetData(xq, yq);		if (shouldRemove) or ((what >= 350) and (what <= 358)) then			begin				Remove;				fallChores^[xq, yq] := FALSE;		{Damn you straight to hell!}			end		else if (itIsA = infotron) and (((what >= 499) and (what <= 511)) or ((what >= 139) and (what <= 214)) or ((what >= 1200) and (what <= 1210))) then			GetMurphyObj.KillMurphy		else			DoOneFrame;	end;	procedure CScissorMover.IScissorMover (scissorX, scissorY: integer);	begin		IInfoChore(scissorX, scissorY);		currentDir := GetData(scissorX, scissorY) mod 8;		lastAnim := currentDir;		afterMed := 10;		{get the open animation number}		currentSize := 0;		{the small size}		sciX := scissorX;		sciY := scissorY;		myIdent := -2;		forceNextMove := FALSE;		shouldMove := TRUE;		goingValue := 1;	end;	procedure CScissorMover.Perform (var maxSleep: longint);		procedure DoMove (oldX, oldY, newX, newY, newDir: integer);			var				myGraphic: integer;		begin			SetData(oldX, oldY, 129);			Draw1(oldX, oldY);			forceNextMove := FALSE;			if (newDir = currentDir) then				begin					SetData(newX, newY, lastAnim + currentSize + 1000);					Draw1(newX, newY);				end			else if (oldX = newX) and (oldY = newY) and not turnAround then				begin					myGraphic := currentDir + 1000 + goingValue;					if myGraphic = 999 then						myGraphic := 1007;					SetData(newX, newY, myGraphic);					Draw1(newX, newY);					currentSize := 0;					afterMed := 10;{newDir := currentDir;}					turnAround := TRUE;				end			else if turnAround then				begin					SetData(newX, newY, newDir + 1000);					Draw1(newX, newY);					currentSize := 0;					afterMed := 10;					turnAround := FALSE;				end			else				begin					newX := oldX;					newY := oldY;					myGraphic := currentDir + 1000 + goingValue;					if myGraphic = 999 then						myGraphic := 1007;					SetData(newX, newY, myGraphic);					Draw1(newX, newY);					currentSize := 0;					afterMed := 10;					forceNextMove := TRUE;				end;			sciX := newX;			sciY := newY;			currentDir := newDir;			lastAnim := newDir;		end;		procedure DoMovement;			var				dirLeft, dirRight: integer;				locS, locL, locR: point;				whatS, whatL, whatR: integer;				facing: integer;				x, y: integer;		begin			facing := currentDir;			x := sciX;			y := sciY;			dirLeft := (facing + 6) mod 8;			dirRight := (facing + 2) mod 8;			locS := LocFromDir(x, y, facing);			locL := LocFromDir(x, y, dirLeft);			locR := LocFromDir(x, y, dirRight);			whatS := GetData(locS.h, locS.v);			whatL := GetData(locL.h, locL.v);			whatR := GetData(locR.h, locR.v);			if turnAround then				DoMove(x, y, x, y, dirLeft)			else if forceNextMove then				DoMove(x, y, locS.h, locS.v, facing)			else if ((whatL >= 499) and (whatL <= 511)) or ((whatL >= 139) and (whatL <= 214)) or ((whatL >= 1200) and (whatL <= 1210)) then				GetMurphyObj.killMurphy			else if whatL = 129 then				begin					goingValue := -1;					DoMove(x, y, locL.h, locL.v, dirLeft);				end			else if ((whatS >= 499) and (whatS <= 511)) or ((whatS >= 139) and (whatS <= 214)) or ((whatS >= 1200) and (whatS <= 1210)) then				GetMurphyObj.killMurphy			else if whatS = 129 then				DoMove(x, y, locS.h, locS.v, facing)			else if ((whatR >= 499) and (whatR <= 511)) or ((whatR >= 139) and (whatR <= 214)) or ((whatR >= 1200) and (whatR <= 1210)) then				GetMurphyObj.killMurphy			else if whatR = 129 then				begin					goingValue := 1;					DoMove(x, y, locR.h, locR.v, dirRight);				end			else				begin					goingValue := -1;					DoMove(x, y, x, y, dirLeft);				end;	{wants to turn}		end;		var			whatThere: integer;			o: CGridPiece;	begin		whatThere := GetData(sciX, sciY);		if (whatThere >= 1000) and (whatThere <= 1026) then			begin				if ShouldMove then					begin						if currentSize = 20 then							begin								currentSize := afterMed;		{after medium, get to the right size}								afterMed := 10 - afterMed;		{switch directions}							end						else							currentSize := 20;		{the medium size}						DoMovement;						ShouldMove := FALSE;					end				else					begin						if currentSize = 20 then							begin								currentSize := afterMed;		{after medium, get to the right size}								afterMed := 10 - afterMed;		{switch directions}							end						else							currentSize := 20;		{the medium size}						ShouldMove := TRUE;						SetData(sciX, sciY, currentSize + lastAnim + 1000);						Draw1(sciX, sciY);					end;			end		else if (whatThere >= 600) and (whatThere <= 610) then			begin				o := GetGridObj(sciX, sciY);				CScissor(o).Explode(sciX, sciY);			end		else			Remove;	end;	procedure CQuarkMover.IQuarkMover (quarkX, quarkY: integer);	begin		IInfoChore(quarkX, quarkY);		currentDir := kRight;		lastAnim := GetData(quarkX, quarkY);		quaX := quarkX;		quaY := quarkY;		shouldMove := TRUE;		myIdent := -2;	end;	procedure CQuarkMover.Perform (var maxSleep: longint);		procedure DoMove (oldX, oldY, newX, newY, newDir: integer);		begin			SetData(oldX, oldY, 129);			Draw1(oldX, oldY);			SetData(newX, newY, lastAnim);			Draw1(newX, newY);			quaX := newX;			quaY := newY;			currentDir := newDir;		end;		procedure DoMovement;			var				dirLeft, dirRight: integer;				locS, locL, locR: point;				whatS, whatL, whatR: integer;				facing: integer;				x, y: integer;		begin			facing := currentDir;			x := quaX;			y := quaY;			dirLeft := (facing + 6) mod 8;			dirRight := (facing + 2) mod 8;			locS := LocFromDir(x, y, facing);			locL := LocFromDir(x, y, dirLeft);			locR := LocFromDir(x, y, dirRight);			whatS := GetData(locS.h, locS.v);			whatL := GetData(locL.h, locL.v);			whatR := GetData(locR.h, locR.v);			if ((whatL >= 499) and (whatL <= 511)) or ((whatL >= 139) and (whatL <= 214)) or ((whatL >= 1200) and (whatL <= 1210)) then				GetMurphyObj.killMurphy			else if whatL = 129 then				DoMove(x, y, locL.h, locL.v, dirLeft)			else if ((whatS >= 499) and (whatS <= 511)) or ((whatS >= 139) and (whatS <= 214)) or ((whatS >= 1200) and (whatS <= 1210)) then				GetMurphyObj.killMurphy			else if whatS = 129 then				DoMove(x, y, locS.h, locS.v, facing)			else if ((whatR >= 499) and (whatR <= 511)) or ((whatR >= 139) and (whatR <= 214)) or ((whatR >= 1200) and (whatR <= 1210)) then				GetMurphyObj.killMurphy			else if whatR = 129 then				DoMove(x, y, locR.h, locR.v, dirRight)			else				DoMove(x, y, x, y, dirLeft);		{wants to turn}		end;		var			whatThere: integer;	begin		whatThere := GetData(quaX, quaY);		if (whatThere >= 650) and (whatThere <= 657) then			begin				lastAnim := lastAnim + 1;				if lastAnim > 657 then					lastAnim := 650;				if shouldMove then					begin						DoMovement;						shouldMove := FALSE;					end				else					begin						DoMove(quaX, quaY, quaX, quaY, currentDir);						shouldMove := TRUE;					end;			end		else			Remove;	end;	procedure CRollAfterChore.IRollAfterChore (x, y: integer; theDir: integer);	begin		IInfoChore(x, y);		uselessCount := 0;		myIdent := kRollAfterChore;		myDir := theDir;	end;	procedure CRollAfterChore.Perform (var maxSleep: Longint);		var			whatBelow: integer;			o: CGridPiece;			theDir: integer;			dat: integer;			sr: boolean;	begin		whatBelow := GetData(xq, yq);		if (whatBelow > 700) and (whatBelow <= 703) then			begin				if myDir = kRight then					begin						whatBelow := whatBelow + 1;						if whatBelow = 704 then							whatBelow := 700;					end				else					begin						whatBelow := whatBelow - 1;						if whatBelow = 699 then							whatBelow := 703;					end;				SetData(xq, yq, whatBelow);				Draw1(xq, yq);			{We can explain to you if you wish.}			end		else			begin				o := GetGridObj(xq, yq);				if not o.CanFall then					remove				else					begin						whatBelow := GetData(xq, yq + 1);{o := GetGridObj(xq, yq);}						theDir := GetNextRollDir;						if MoveInfo(xq, yq + 1) then							begin								o.CheckFall(xq, yq);								remove;							end						else if o.CheckRoll(xq, yq, theDir) then							remove						else if o.CheckRoll(xq, yq, 8 - theDir) then							remove						else							uselessCount := uselessCount + 1;						ToggleRollDir;					end;			end;		if (uselessCount > 30) then			remove;	end;	procedure CSuicideChore.ISuicideChore (x, y: integer);	begin		IInfoChore(x, y);		uselessCount := 0;		myIdent := kSuicideChore;	end;	procedure CSuicideChore.Perform (var maxSleep: Longint);		var			whatBelow: integer;			o: CGridPiece;			theDir: integer;			dat: integer;			sr: boolean;	begin		o := GetGridObj(xq, yq);		if (not o.CanFall) then			remove		else			begin				whatBelow := GetData(xq, yq + 1);{o := GetGridObj(xq, yq);}				theDir := GetNextRollDir;				if MoveInfo(xq, yq + 1) then					begin						fallChores^[xq, yq] := FALSE;{    remove;}						o.CheckFall(xq, yq);					end				else if o.CheckRoll(xq, yq, theDir) then					remove				else if o.CheckRoll(xq, yq, 8 - theDir) then					remove				else					begin						uselessCount := uselessCount + 1;					end;				ToggleRollDir;			end;		if (uselessCount > 30) then			remove;	end;	procedure CWaitInsChore.FreeMemory;		var			myTBI: CChore;	begin		myTBI := toBeInstalled;		if myTBI <> nil then			if not HaveInstalled then				DisposeHandle(handle(myTBI));		{Get rid of it}	end;	procedure CWaitInsChore.Perform (var maxSleep: longint);		var			myTBI: CChore;	begin		if not HaveInstalled then			begin				countDown := countDown - 1;				if countDown < 1 then					begin						myTBI := toBeInstalled;						if myTBI <> nil then							FudADD(myTBI);						HaveInstalled := TRUE;						remove;	{myself.}					end;			end;	end;	procedure CWaitInsChore.IWaitInsChore (someChore: CChore; theCount: integer);	begin		MoveHHi(handle(self));		HLock(handle(self));		IInfoChore(1, 1);		{doesn't matter where!}		toBeInstalled := nil;{?}		toBeInstalled := someChore;		countDown := theCount;		HaveInstalled := FALSE;		myIdent := kWaitInsChore;	end;	procedure CWaitTimeChore.IWaitTimeChore (someChore: CChore; numSecs: integer);	begin		MoveHHi(handle(self));		HLock(handle(self));		IInfoChore(1, 1);		{doesn't matter where!}		toBeInstalled := someChore;		countDown := numSecs;		HaveInstalled := FALSE;		myIdent := kWaitTimeChore;		installedWhen := tickCount;	end;	procedure CWaitTimeChore.Perform (var maxSleep: longint);		var			myTBI: CChore;	begin		if not HaveInstalled then			if tickCount > installedWhen + (countDown * 60) then				begin					myTBI := toBeInstalled;					if myTBI <> nil then						FudADD(myTBI);					HaveInstalled := TRUE;					remove;	{myself.}				end;	end;end.
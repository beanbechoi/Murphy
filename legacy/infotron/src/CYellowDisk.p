unit CYellowDisk;{Note: There is no distinction between an Explodes and a}{Yellow disk, save the DoNothing procedure, which does}{nothing. Don't attempt to understand our twisted and}{backwards logic, because you will get a headache.}interface	uses		TCL, GridPieceIntf;implementation	procedure CYellowDisk.InitPiece;	begin		inherited InitPiece;		explodes := FALSE;	end;	function CYellowDisk.WalkOnto (x, y: integer): boolean;	begin		WalkOnto := Push(x, y);	end;	function CYellowDisk.Push (x, y: integer): boolean;		var			murphyGoingTo: integer;			mx, my: integer;			afterX, afterY: integer;			whatThere: integer;			whatMe: integer;	begin		murphyGoingTo := CInfoApp(gapplication).GetMurphy.GetLastDir;		CInfoApp(gapplication).GetMurphy.GetLoc(mx, my);		afterX := CInfoApp(gapplication).LocFromDir(x, y, murphyGoingTo).h;		afterY := CInfoApp(gapplication).LocFromDir(x, y, murphyGoingTo).v;		whatThere := CInfoApp(gapplication).GetGPane.GetBoard.GetData(afterX, afterY);		whatMe := CInfoApp(gapplication).GetGPane.GetBoard.GetData(x, y);		Push := FALSE;		if whatThere = 129 then			begin				Push := TRUE;				CInfoApp(gapplication).GetGPane.GetBoard.SetData(x, y, 129);				CInfoApp(gapplication).GetGPane.GetBoard.SetData(afterX, afterY, whatMe);				CInfoApp(gapplication).GetGPane.GetBPane.Draw1(x, y);				CInfoApp(gapplication).GetGPane.GetBPane.Draw1(afterX, afterY);			end;	end;end.
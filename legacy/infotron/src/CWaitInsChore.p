unit CWaitInsChore;{Waits to install another chore :> }interface	uses		TCL, InfoIntf;implementation	procedure CWaitInsChore.FreeMemory;		var			myTBI: CChore;	begin		myTBI := toBeInstalled;		if myTBI <> nil then			if not HaveInstalled then				DisposeHandle(handle(myTBI));		{Get rid of it}	end;	procedure CWaitInsChore.Perform (var maxSleep: longint);		var			myTBI: CChore;	begin		if not HaveInstalled then			begin				countDown := countDown - 1;				if countDown < 1 then					begin						myTBI := toBeInstalled;						if myTBI <> nil then							CInfoApp(gapplication).FudADD(myTBI);						HaveInstalled := TRUE;						remove;	{myself.}					end;			end;	end;	procedure CWaitInsChore.IWaitInsChore (someChore: CChore; theCount: integer);	begin		MoveHHi(handle(self));		HLock(handle(self));		IInfoChore(1, 1);		{doesn't matter where!}		toBeInstalled := nil;{?}		toBeInstalled := someChore;		countDown := theCount;		HaveInstalled := FALSE;		myIdent := kWaitInsChore;	end;end.
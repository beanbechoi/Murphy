unit CContMoveChore;{handles continuous moving of the scissors and quarks}interface	uses		TCL, backChoresIntf;implementation	procedure CContMoveChore.SubsidiaryDone (x, y: integer);		var			o: CGridPiece;	begin		if not removeOnRespond then			begin				xq := x;				yq := y;		{the thing I am moving finally finished its animation.}					{So move it again if it is still movable. (I.E. didn't explode)}				o := CInfoApp(gapplication).GetGridObj(x, y);				if o.CanMove then					o.Move(x, y, SELF){else}{    Remove;		{oops I'm no longer needed}			end		else			remove;	end;	procedure CContMoveChore.IContMoveChore (x, y: integer);	{who cares what I am?}	begin		IInfoChore(x, y);		removeOnRespond := FALSE;		SubsidiaryDone(x, y);		myIdent := kContMoveChore;	end;	procedure CContMoveChore.Perform (var maxSleep: longint);		var			what: integer;	begin{    what := CInfoApp(gapplication).GetGPane.GetBoard.GetData(xq, yq);}{if ((what >= 850) and (what <= 853)) or ((what >= 350) and (what <= 358)) then}{    removeOnRespond := TRUE;}	end;end.
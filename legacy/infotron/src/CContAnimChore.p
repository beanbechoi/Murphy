unit CContAnimChore;interface	uses		TCL, BackChoresIntf;implementation	procedure CContAnimChore.SequenceDone;	begin		inCycle := false;		betweenStart := tickCount;	end;	procedure CContAnimChore.IContAnimChore (cd: longint; as: AnimArray; fa: integer; db: longint; x, y: integer);	begin		cycleDelay := cd;		inCycle := true;		IAnimChore(as, fa, db, x, y);		myIdent := kContAnimChore;	end;	procedure CContAnimChore.Perform (var maxSleep: longint);		var			whatThere: integer;			mx, my: integer;	begin		whatThere := CInfoApp(gapplication).GetGPane.GetBoard.GetData(xq, yq);		if ShouldRemove then			Remove		else if not ((whatthere = 128) or ((whatThere >= 300) and (whatThere <= 305)) or ((whatThere >= 550) and (whatThere <= 561))) then			Remove		else if inCycle then			DoOneFrame		else if tickCount - betweenStart > cycleDelay then			begin				if animSequence[1] = 301 then					begin						CInfoApp(gapplication).GetMurphy.GetLoc(mx, my);						if abs(mx - xq) + abs(my - yq) <= 2 then							PlaySound(sBugZap);	{murphy in proximity}					end;				IAnimChore(animSequence, finalAnim, delayBetween, xq, yq);				inCycle := true;			end;	end;end.
unit CAnimChore;interface	uses		TCL, BackChoresIntf;implementation	procedure CAnimChore.IAnimChore (as: AnimArray; fa: integer; db: longint; x, y: integer);	begin		IInfoChore(x, y);		animSequence := as;		animAt := 1;		finalAnim := fa;		delayBetween := db;		lastTime := 0;		myIdent := kAnimChore;	end;	procedure CAnimChore.DrawAt;	begin		CInfoApp(CInfoApp(gApplication)).GetGPane.GetBoard.SetData(xq, yq, animSequence[animAt]);		CInfoApp(CInfoApp(gApplication)).GetGPane.GetBPane.Draw1(xq, yq);	end;	procedure CAnimChore.SequenceDone;	begin		remove;	end;	procedure CAnimChore.FrameDone;	begin	end;	procedure CAnimChore.DoOneFrame;	begin		if tickCount - lastTime > delayBetween then			begin		{do one animate frame}				DrawAt;				lastTime := tickCount;				FrameDone;				animAt := animAt + 1;			end;		if animAt > finalAnim then			SequenceDone;	end;	procedure CAnimChore.Perform (var maxSleep: longint);	begin		DoOneFrame;		if animAt > finalAnim then			remove;	end;end.
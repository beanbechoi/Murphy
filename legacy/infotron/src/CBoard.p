unit CBoard;interface	uses		TCL, InfoIntf;		{so there.}implementation	function CBoard.LoadBoard (name: Str255): boolean;		{FALSE if it failed}		var			tempComp: CCompBoard;			worked: boolean;			appStat: InfoStatus;			someData: bap;			myTP: CInfoTextPane;			dorky: rect;	begin{    KillData;}{CInfoApp(gapplication).KillChores;}		New(tempComp);		{create the compressed board}		worked := tempComp.LoadBoard(name);		CInfoAPp(gapplication).GetMurphy.SetLoc(murphyStart.h, murphyStart.v);		if worked then			begin				worked := tempComp.DecompressBoard(someData);				MoveHHi(handle(someData));				HLock(handle(someData));				boardData := someData;				FixSize;				MakeSciStuff;				myTP := CInfoTextPane(CInfoApp(gapplication).GetGPane.itsSubviews.nthItem(2));				myTP.SetText(boardData^^.name);				myTP.Draw(dorky);				appStat := CInfoApp(gapplication).GetInfoStatus;				CInfoApp(gapplication).SetInfoStatus(appStat + [hasLevel]);			end;		CInfoApp(gapplication).GetMurphy.SetLoc(murphyStart.h, murphyStart.v);		LoadBoard := worked;		tempComp.free;	end;	procedure CBoard.Free;	begin		KillData;		inherited Free;	end;	procedure CBoard.KillData;			{get rid of the current handle, if any}		var			appStat: InfoStatus;	begin		if boardData <> nil then			begin				CInfoApp(gapplication).KillChores;				HUnlock(handle(boardData));				DisposeHandle(handle(boardData));				appStat := CInfoApp(gapplication).GetInfoStatus;				CInfoApp(gapplication).SetInfoStatus(appStat - [hasLevel]);				boardData := nil;			end;	end;	function CBoard.GetData (x, y: integer): integer;	begin		if boardData <> nil then			GetData := boardData^^.theBoard[x, y];	end;	procedure CBoard.SetData (x, y, what: integer);		procedure Checking (xe, ye: integer);			var				o: CGridPiece;				rd: integer;				whatUnder: integer;				mySuicide: CSuicideChore;		begin			o := CInfoApp(gapplication).GetGridObj(xe, ye);			if o.CanFall then				if CInfoApp(gapplication).NumChores^[xe, ye] = 0 then					begin						new(mysuicide);						mySuicide.ISuicideChore(xe, ye);						CInfoApp(gapplication).FudADD(mysuicide);					end;		end;	begin		if boardData <> nil then			begin				boardData^^.theBoard[x, y] := what;				if what = 129 then					begin						Checking(x, y - 1);						Checking(x - 1, y - 1);						Checking(x + 1, y - 1);						Checking(x - 1, y);						Checking(x + 1, y);					end;			end;	end;	procedure DumbProc;		var			what: integer;			o: CGridPiece;			mySuicide: CSuicideChore;			x, y: integer;	begin		if what = 129 then			begin		{create suicide chores}				o := CInfoApp(gapplication).GetGridObj(x, y - 1);				if o.CanFall then					begin						New(mySuicide);						mySuicide.ISuicideChore(x, y - 1);						CInfoApp(gapplication).FudADD(mySuicide);					end;				o := CInfoApp(gapplication).GetGridObj(x - 1, y);				if o.CanFall then					begin						New(mySuicide);						mySuicide.ISuicideChore(x - 1, y);						CInfoApp(gapplication).FudADD(mySuicide);					end;				o := CInfoApp(gapplication).GetGridObj(x + 1, y);				if o.CanFall then					begin						New(mySuicide);						mySuicide.ISuicideChore(x + 1, y);						CInfoApp(gapplication).FudADD(mySuicide);					end;				o := CInfoApp(gapplication).GetGridObj(x - 1, y - 1);				if o.CanFall then					begin						New(mySuicide);						mySuicide.ISuicideChore(x - 1, y - 1);						CInfoApp(gapplication).FudADD(mySuicide);					end;				o := CInfoApp(gapplication).GetGridObj(x + 1, y - 1);				if o.CanFall then					begin						New(mySuicide);						mySuicide.ISuicideChore(x + 1, y - 1);						CInfoApp(gapplication).FudADD(mySuicide);					end;			end;	end;	procedure CBoard.GetSize (var hSize, vSize: integer);	begin		hSize := boardBounds.h;		vSize := boardBounds.v;	end;	procedure CBoard.FixSize;		var			c: integer;	begin		c := boardData^^.sizeX;		while boardData^^.theBoard[c, 2] = 128 do			c := c - 1;		boardData^^.sizeX := c;		c := boardData^^.sizeY;		while boardData^^.theBoard[2, c] = 128 do			c := c - 1;		boardData^^.sizeY := c;		boardBounds.h := boardData^^.sizeX;		boardBounds.v := boardData^^.sizeY;	end;	function CBoard.ScissorCount: integer;			{get info about the board}	begin		ScissorCount := boardData^^.numScissors;	end;	function CBoard.QuarkCount: integer;	begin		QuarkCount := boardData^^.numQuarks;	end;	function CBoard.InfoCount: integer;	begin		InfoCount := boardData^^.numInfotrons;	end;	function CBoard.BugCount: integer;	begin		BugCount := boardData^^.numBugs;	end;	function CBoard.MurphyStart: point;	begin		MurphyStart := IntToPt(boardData^^.murphy);	end;	function CBoard.TermLocation: point;	begin		TermLocation := IntToPt(boardData^^.term);	end;	function CBoard.GetName: Str255;	begin		GetName := boardData^^.name;	end;	procedure CBoard.MakeSciStuff;		var			count1, count2: integer;			myX, myY: integer;			what: integer;	begin		count1 := 0;		count2 := 0;		for myX := 1 to boardBounds.h do			for myY := 1 to boardBounds.v do				begin					what := GetData(myX, myY);					if (((what >= 998) and (what <= 1009)) or ((what >= 1148) and (what <= 1160))) then						begin							count1 := count1 + 1;							scissorData[count1].x := myX;							scissorData[count1].y := myY;							scissorData[count1].dir := GetData(myX, myY) mod 8;						end					else if (what >= 650) and (what <= 666) then						begin							count2 := count2 + 1;							quarkData[count2].x := myX;							quarkData[count2].y := myY;							quarkData[count2].dir := kRight						end;				end;	end;	procedure CBoard.MovedScissor (which: integer; direction: integer);			{call when you moved scissor # in specified direction}		var			ix, iy: integer;			nx, ny: integer;	begin		if direction <> 8 then			begin				ix := scissorData[which].x;				iy := scissorData[which].y;				nx := CInfoApp(CInfoApp(gApplication)).LocFromDir(ix, iy, direction).h;				ny := CInfoApp(CInfoApp(gApplication)).LocFromDir(ix, iy, direction).v;				scissorData[which].x := nx;				scissorData[which].y := ny;				scissorData[which].dir := direction;			end		else			scissorData[which].dir := (scissorData[which].dir + 2) mod 8;	end;																					{use kCurrentDir for same direction}	procedure CBoard.MovedQuark (which: integer; direction: integer);		var			ix, iy: integer;			nx, ny: integer;	begin		if direction <> 8 then			begin				ix := quarkData[which].x;				iy := quarkData[which].y;				nx := CInfoApp(CInfoApp(gApplication)).LocFromDir(ix, iy, direction).h;				ny := CInfoApp(CInfoApp(gApplication)).LocFromDir(ix, iy, direction).v;				quarkData[which].x := nx;				quarkData[which].y := ny;				quarkData[which].dir := direction;			end		else			quarkData[which].dir := (quarkData[which].dir + 2) mod 8;	end;	function CBoard.ScissorDir (which: integer): integer;	begin		scissorDir := scissorData[which].dir;	end;	function CBoard.QuarkDir (which: integer): integer;	begin		QuarkDir := quarkData[which].dir;	end;	function CBoard.ScissorLoc (which: integer): point;							{where is scissor #x}	begin		ScissorLoc.h := scissorData[which].x;		ScissorLoc.v := scissorData[which].y;	end;	function CBoard.QuarkLoc (which: integer): point;							{where is quark #x}	begin		QuarkLoc.h := quarkData[which].x;		QuarkLoc.v := quarkData[which].y;	end;	function CBoard.BugLoc (which: integer): point;	begin		BugLoc := IntToPt(boardData^^.bugs[which]);	end;	function CBoard.WhichScissor (whereX, whereY: integer): integer;		{what # scissor is here?}		var			sc: integer;			done: boolean;			count: integer;			result: integer;			sloc: point;	begin		result := -1;		done := false;		sc := ScissorCount;		count := 0;		while not done and (count < sc) do			begin				count := count + 1;				sloc := ScissorLoc(count);				done := (sloc.h = whereX) and (sloc.v = whereY);			end;		if done then			result := count;		WhichScissor := result;	end;	function CBoard.WhichQuark (whereX, whereY: integer): integer;		var			sc: integer;			done: boolean;			count: integer;			result: integer;			sloc: point;	begin		result := -1;		done := false;		sc := QuarkCount;		count := 0;		while not done and (count < sc) do			begin				count := count + 1;				sloc := QuarkLoc(count);				done := (sloc.h = whereX) and (sloc.v = whereY);			end;		if done then			result := count;		WhichQuark := result;	end;	function CBoard.WhichBug (whereX, whereY: integer): integer;		var			sc: integer;			done: boolean;			count: integer;			result: integer;			sloc: point;	begin		result := -1;		done := false;		sc := BugCount;		count := 0;		while not done and (count < sc) do			begin				count := count + 1;				sloc := BugLoc(count);				done := (sloc.h = whereX) and (sloc.v = whereY);			end;		if done then			result := count;		WhichBug := result;	end;	function CBoard.PtToInt (x, y: integer): integer;							{transfer a point to an integer}	begin		PtToInt := integer((x * 256) + y);	end;	function CBoard.IntToPt (i: integer): point;									{vv}	begin		IntToPt.h := i div 256;		IntToPt.v := i mod 256;	end;end.
unit CQuark;interface	uses		TCL, GridPieceIntf;implementation	procedure CQuark.InitPiece;		var			count: integer;	begin		inherited InitPiece;		IAmA := quark;		for count := 358 downto 351 do			qExplAnim[359 - count] := count;		qExplAnim[9] := 850;	end;	procedure CQuark.Explode (x, y: integer);		var			myAnim: CAnimChore;			mySuicide: CSuicideChore;			myWaitChore: CWaitInsChore;			myArray: AnimArray;			xc, yc: integer;			what: integer;			myObj: CGridPiece;	begin		PlaySound(sQuarkExp);		for xc := x - 1 to x + 1 do			for yc := y - 1 to y + 1 do				begin					what := CInfoApp(gapplication).GetGPane.GetBoard.GetData(xc, yc);					if not (((what >= 750) and (what <= 757)) or ((what >= 1050) and (what <= 1057))) then						begin							if (xc <> x) or (yc <> y) then								begin									myObj := CInfoAPp(gapplication).GetGridObj(xc, yc);									myObj.explode(xc, yc);								end;							new(myAnim);							myArray := qExplAnim;							myAnim.IAnimChore(myArray, 9, 0, xc, yc);							CInfoApp(gapplication).FudADD(myAnim);							if (xc <> x) or (yc <> y) then								begin									new(myWaitChore);									new(mySuicide);									mySuicide.ISuicideChore(xc, yc);									myWaitChore.IWaitInsChore(mySuicide, 7);									CInfoApp(gapplication).FudADD(myWaitChore);								end;						end;				end;	end;end.
unit infoWindows;interface	uses		ObjIntf, QDOffscreen, sound, coloroffscreen, myRGBColors, CInfoDialog, ColorOffScreen, psst, QuickDrawProcs;	const		mid = 82;		space = 14;		playerResType = 'blŸG';		levelResType = 'lŸVl';	type		keyArr = array[1..5] of integer;		PlayerHandle = ^PlayerPtr;		PlayerPtr = ^PlayerType;		PlayerType = record				skippedLev: skipSet;				highLev, current, numSkipped: integer;				name, Level: str255;				time: longint;				keySet: keyArr;			end;	var		statWind: windowPtr;	procedure doHelp (help: CInfoDialog);	procedure doAbout (aboutDial: CInfoDialog);	procedure drawKey (ch: char; difNums: boolean);	procedure doError (str: str255);	function CheckSure: boolean;	function levelChoice (var aLevel: str255; var skippedLev: skipSet; var aHighLev, aCurrent, aNumSkipped: integer; lvlDial: CInfoScrollDialog): boolean;	function openChoice (var name: str255; openDial: CInfoScrollDialog): boolean;	function deleteChoice (var name: str255; delDial: CInfoScrollDialog): boolean;	function getWinName (var theName: str255; Dial: CInfoDialog): boolean;	function doSetKey (var player: PlayerType; keysDial: CInfoDialog): boolean;	function doReg (var name: str255; regDial: CInfoDialog): boolean;	procedure SetUpDials (var RegDial, AboutDial, newDial, renDial, keysDial, help: CInfoDialog; var lvlDial, openDial, delDial: CInfoScrollDialog);implementation{$s DorkySegment1}	procedure drawKey (ch: char; difNums: boolean);		var			w: integer;			col: RGBColor;			r: rect;			at: point;	begin		getForeColor(col);		RGBForeColor(myBlackColor);		w := stringWidth('Ù');		getPen(at);		setRect(r, at.h, at.v - 10, at.h + w, at.v + 2);		fillRect(r, black);		RGBForeColor(col);		if (ch in ['a'..'z']) and difNums then			drawInteger((ord(ch) - ord('a')), 1)		else			drawChar(ch);	end;	procedure doError (str: str255);		const			maxLen = 320;		var			idiot: grafPtr;			color: RGBColor;			tempStr: str255;			at: point;			w, c: integer;			errwind: WindowPtr;	begin		errWind := getNewCWindow(137, nil, windowPtr(-1));		textFace([bold]);		textSize(14);		w := stringWidth(str);		if w < 2 * maxLen then			begin				BackColor(whiteColor);				if w > maxLen then					begin						c := length(str);						repeat							while (str[c] <> ' ') and (c > 0) do								c := c - 1;							c := c - 1;							tempStr := copy(str, 1, c);						until stringWidth(tempStr) <= maxLen;						tempStr := copy(str, c + 2, length(str));						str := copy(str, 1, c);					end;				getPort(idiot);				at.h := 0;				at.v := 0;				setPort(errWind);				sysBeep(1);				showWindow(errWind);				bringToFront(errWind);				drawPic(137, at);				moveTo(67, 26);				textFace([bold]);				textSize(14);				RGBForeColor(myDarkGrayColor);				drawString(str);				moveTo(66, 25);				RGBForeColor(myYellowColor);				drawString(str);				if w > maxLen then					begin						moveto(67, 46);						RGBForeColor(myDarkGrayColor);						drawString(tempStr);						moveTo(66, 45);						RGBForeColor(myYellowColor);						drawString(tempStr);					end;				while not button do					;				disposeWindow(errwind);				setPort(idiot);				textSize(12);				textFace([]);			end;		textSize(12);		textFace([]);	end;	function CheckSure: boolean;		var			sureDial: CInfoDialog;			keys: keyMap;			event, dummy: integer;			r: rect;	begin		new(CInfoDialog(sureDial));		sureDial.init(146, 146);		setRect(r, 141, 12, 214, 31);		sureDial.setBox(1, r, true);				{yes}		setRect(r, 141, 40, 214, 59);		sureDial.setBox(2, r, true);				{no}		sureDial.setUp;		repeat			while not button and not keys[36] do				getKeys(keys);			if keys[36] then				event := sureDial.returnHit			else				event := sureDial.mouseDown(dummy);		until event in [1, 2];		checkSure := (event = 1);		sureDial.rid;	end;	function levelChoice (var aLevel: str255; var skippedLev: skipSet; var aHighLev, aCurrent, aNumSkipped: integer; lvlDial: CInfoScrollDialog): boolean;		var			c, oldSel, numSkipped, sel, hiLev, event: integer;			keys: keyMap;			lastTime: longint;			skipped: skipSet;	begin		oldSel := 0;		lastTime := 0;		skipped := skippedLev;		numskipped := aNumSkipped;		hiLev := aHighLev;		sel := aCurrent;		lvlDial.setLevs(hiLev, sel, skipped);		lvlDial.setUp2(true);		repeat			event := 0;			getKeys(keys);			while not button and not keys[36] and not keys[126] and not keys[125] and not keys[53] do				getKeys(keys);			if keys[36] then				event := lvlDial.returnHit			else if keys[125] then				sel := lvlDial.goDown			else if keys[126] then				sel := lvlDial.goUp			else if keys[53] then				event := 3			else				event := LvlDial.mouseDown(sel);			if event = 2 then				begin					if (numskipped < 3) and (sel = hilev) then						begin							if sel <> hiLev then								begin									skipped := skipped + [sel];									numskipped := numskipped + 1;									RGBforeColor(myBlackColor);									textFace([bold]);									lvlDial.center1String(sel);									setTextColorOf(sel, hiLev, skipped);									lvlDial.setLevs(hiLev, sel, skipped);									lvlDial.center1String(sel);								end							else								begin									skipped := skipped + [sel];									numskipped := numskipped + 1;									RGBforeColor(myBlackColor);									textFace([bold]);									lvlDial.center1String(sel);									setTextColorOf(sel, hiLev, skipped);									sel := sel + 1;									lvlDial.setLevs(hiLev, sel, skipped);									lvlDial.center1String(sel - 1);									hilev := hilev + 1;									lvlDial.setLevs(hiLev, sel, skipped);									foreColor(blackColor);									lvlDial.center1String(hiLev);									setTextColorOf(hiLev, hiLev, skipped);									lvlDial.center1String(hiLev);								end;						end					else						begin							if sel > hiLev then								doError('You cannot skip levels that you have not reached.')							else if sel in skipped then								doError('Do you really want to skip that level twice?  It seems redundant.')							else if sel < hiLev then								doError('Why do you want to skip a level that you have already passed?')							else								doError('You may only have three skipped levels at one time.');							lvlDial.redraw;						end;				end			else if event = 15 then				begin					if (oldSel = sel) then						if ((tickCount - lastTime) <= (getDblTime)) then							event := 1;					oldSel := sel;					lastTime := tickCount;				end;			if (event = 1) and (sel > hiLev) then				begin					event := 4;					doError('You may only play the levels marked in green, blue, or yellow.');					lvlDial.redraw;				end;		until (event = 3) or (event = 1);		levelChoice := event = 1;		if event = 1 then			begin				aCurrent := sel;				aHighLev := hiLev;				aLevel := lvlDial.list[sel];				skippedLev := skipped;				aNumSkipped := numSkipped;			end;		lvlDial.rid;	end;	function PlotIconID (TheRect: Rect; Align: integer; Transform: integer; TheResID: INTEGER): OSErr;	inline		$303C, $0500, $ABC9;	const {ipated}		TutorialResType = 'I i ';		maxSlides = 14;	type		TutorialText = record				numStrings: integer;				strings: array[1..6] of str255;			end;		TutorialBoard = array[1..10, 1..7] of integer;		TutorialChange = record				newIconNum: integer;				x, y: integer;			end;		TutorialCArray = array[1..10] of TutorialChange;		TutorialStep = record				numChanges: integer;				theChanges: TutorialCArray;				soundID: integer;				timeDelay: longint;			end;		TutorialSArray = array[0..75] of TutorialStep;		tdh = ^tdp;		tdp = ^tutorialData;		TutorialData = record				theText: TutorialText;				initialBoard: TutorialBoard;				numSteps: integer;				theSteps: TutorialSArray;			end;	procedure DisposeTutorial (var t: tdh);	begin		HUnlock(handle(t));		DisposeHandle(handle(t));		t := nil;	end;	function LoadTutRes (id: integer): tdh;		var			h: handle;	begin		LoadTutRes := nil;		h := Get1Resource(tutorialResType, id);		if (h <> nil) and (resError = noErr) then			begin				DetachResource(h);				MoveHHi(h);				HLock(h);				LoadTutRes := tdh(h);			end;	end;	function myDarkDarkGrayColor: RGBColor;		var			c: RGBColor;	begin		c.red := 10000;		c.blue := 10000;		c.green := 10000;		myDarkDarkGrayColor := c;	end;	procedure DoPlot (x, y: integer; id: integer);		var			r: rect;			e: OSErr;	begin		r.top := ((y - 1) * 32) + 54;		r.left := ((x - 1) * 32) + 78;		r.bottom := r.top + 32;		r.right := r.left + 32;		e := PlotIconID(r, 0, 0, id);	end;	procedure DrawInitial2 (t: tdh);		var			cx, cy: integer;	begin		for cx := 1 to 10 do			for cy := 1 to 7 do				DoPlot(cx, cy, t^^.initialBoard[cx, cy]);	end;	procedure centerString2 (s: str255; y, lSide, rSide: integer);		var			w, textStart: integer;	begin		w := stringWidth(s);		textStart := (((rSide - lSide) - w) div 2) + lSide;		moveTo(textStart, y);		drawString(s);	end;	procedure writeTheText (t: tdh);		var			c: integer;	begin		RGBForeColor(myGrayColor);		fillRect(324, 25, 401, 451, black);		RGBForeColor(myDarkDarkGrayColor);		textSize(12);		textFace([bold]);		centerString(t^^.theText.strings[1], 335, 27, 448);		textSize(9);		textFace([]);		for c := 2 to t^^.theText.numStrings do			centerString2(t^^.theText.strings[c], 348 + (12 * (c - 2)), 27, 448);		foreColor(blackColor);	end;	procedure doHelp (help: CInfoDialog);		const			wait = 230;		var			tc: TutorialChange;			err: QDErr;			er: boolean;			r: rect;			done, yawned, mad, asleep: boolean;			old, c, d, event: integer;			l, time: longint;			oldEvent: integer;			specialRect: rect;			at: point;			myGW: GWorldPtr;			oldGW: GWorldPtr;			oldGD: GDHandle;			t: Tdh;			sc, cc: integer;			slide: integer;			aardvark: boolean;			readyTime: longint;		procedure Yawn;			var				c, d: integer;		begin			setRect(r, 34, 55, 66, 87);				{murph}			for c := 500 to 510 do				begin					err := PlotIconID(r, 0, 0, c);					for d := 1 to wait * 2 do						l := 5 * (trunc(tickcount + 27));				end;			err := PlotIconID(r, 0, 0, 499);			for d := 1 to wait do				l := 5 * (trunc(tickcount + 27));			err := PlotIconID(r, 0, 0, 214);			yawned := true;			time := tickCount;		end;		procedure getMad;		begin			setRect(r, 34, 55, 66, 87);				{murph}			err := PlotIconID(r, 0, 0, 142);			mad := true;			time := tickCount;		end;		procedure fallAsleep;			var				d: integer;		begin			setRect(r, 34, 55, 66, 87);				{murph}			err := PlotIconID(r, 0, 0, 143);			for d := 1 to wait * 6 do				l := 5 * (trunc(tickcount + 27));			setRect(r, 34, 55, 66, 87);				{murph}			err := PlotIconID(r, 0, 0, 144);			asleep := true;		end;	begin		help.setUp;		time := tickCount;		done := false;		yawned := false;		mad := false;		asleep := false;		oldEvent := 0;		textSize(9);		textFace([]);		repeat			while not button do				if ((time + 1200) < tickCount) and not yawned then					yawn				else if ((time + 210) < tickCount) and yawned and not mad then					getMad				else if ((time + 100) < tickCount) and mad and not asleep then					fallAsleep;			event := help.mouseDown(c);			case event of				1: 					begin						if event <> oldevent then							begin								rgbForeColor(myGrayColor);								setRect(r, 10, 390, 470, 415);								fillRect(r, black);								RGBForeColor(myDarkDarkGrayColor);								moveTo(12, 400);								drawString('This is Murphy.  Murphy is you.  You can eat circuits, red disks, and infotrons, and also bugs when');								moveTo(12, 410);								drawString('they are off.  Try to get all the infotrons you can, and dodge zonks, scissors and quarks.');								rgbForeColor(myBlackColor);								oldEvent := event;								time := tickCount;								yawned := false;								mad := false;								asleep := false;							end;						setRect(r, 34, 55, 66, 87);				{murph}						for c := 500 to 510 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to wait * 2 do									l := 5 * (trunc(tickcount + 27));							end;						err := PlotIconID(r, 0, 0, 500);						for d := 1 to wait do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 198);					end;				2: 					begin						if event <> oldevent then							begin								rgbForeColor(myGrayColor);								setRect(r, 10, 390, 470, 415);								fillRect(r, black);								RGBForeColor(myDarkDarkGrayColor);								moveTo(12, 400);								drawString('Be careful around quarks.  If you touch them, they will explode and kill you.  But if you kill them, you');								moveTo(12, 410);								drawString('can get up to nine infotrons from their explosion.');								rgbForeColor(myBlackColor);								oldEvent := event;							end;						setRect(r, 34, 122, 66, 154);			{quark}						for event := 1 to 3 do							begin								for c := 650 to 657 do									begin										err := PlotIconID(r, 0, 0, c);										for d := 1 to wait do											l := 5 * (trunc(tickcount + 27));									end;								err := PlotIconID(r, 0, 0, 650);							end;					end;				3: 					begin						if event <> oldevent then							begin								rgbForeColor(myGrayColor);								setRect(r, 10, 390, 470, 415);								fillRect(r, black);								RGBForeColor(myDarkDarkGrayColor);								moveTo(12, 400);								drawString('Infotrons are the challenge in the game.  You must collect a specified amount, (indicated on your');								moveTo(12, 410);								drawString('statistical board) and then find the exit and use it.');								rgbForeColor(myBlackColor);								oldEvent := event;							end;						setRect(r, 177, 55, 209, 87);			{info}						for c := 350 to 358 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to wait do									l := 5 * (trunc(tickcount + 27));							end;						for c := 358 downto 350 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to wait do									l := 5 * (trunc(tickcount + 27));							end;						err := PlotIconID(r, 0, 0, 850);					end;				4: 					begin						if event <> oldevent then							begin								rgbForeColor(myGrayColor);								setRect(r, 10, 390, 460, 415);								fillRect(r, black);								RGBForeColor(myDarkDarkGrayColor);								moveTo(12, 400);								drawString('Terminals are very useful for breaking into places when you do not have the key. Use it, and all the');								moveTo(12, 410);								drawString('yellow disks explode.');								rgbForeColor(myBlackColor);								oldEvent := event;							end;						setRect(r, 338, 55, 370, 87);			{term}						for c := 550 to 561 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to trunc(wait * 1.5) do									l := 5 * (trunc(tickcount + 27));							end;						for c := 550 to 558 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to wait do									l := 5 * (trunc(tickcount + 27));							end;					end;				5: 					begin						if event <> oldevent then							begin								rgbForeColor(myGrayColor);								setRect(r, 10, 390, 470, 415);								fillRect(r, black);								RGBForeColor(myDarkDarkGrayColor);								moveTo(12, 400);								drawString('Like all programs nowadays, Infotronª has lots of bugs.  When they are on, they will zap Murphy if');								moveTo(12, 410);								drawString('he tries to eat them.  When off, they are absolutely harmless.');								rgbForeColor(myBlackColor);								oldEvent := event;							end;						setRect(r, 338, 122, 370, 154);		{bug}						err := PlotIconID(r, 0, 0, 302);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 303);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 304);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 303);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 302);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 303);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 302);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 301);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 302);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 303);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 304);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 303);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 302);					end;				6: 					begin						if event <> oldevent then							begin								rgbForeColor(myGrayColor);								setRect(r, 10, 390, 470, 415);								fillRect(r, black);								RGBForeColor(myDarkDarkGrayColor);								moveTo(12, 400);								drawString('These buggers are a pain in the patootie.  It seems like they follow you around, but they are actually');								moveTo(12, 410);								drawString('quite stupid and can be dodged or trapped if you are smart.');								rgbForeColor(myBlackColor);								oldEvent := event;							end;						setRect(r, 177, 187, 211, 219);		{snik}						err := PlotIconID(r, 0, 0, 1002);						for d := 1 to wait * 3 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 1152);						for d := 1 to wait * 3 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 1002);						for d := 1 to wait * 3 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 1152);						for d := 1 to wait * 3 do							l := 5 * (trunc(tickcount + 27));						for c := 1002 to 1006 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to wait * 2 do									l := 5 * (trunc(tickcount + 27));							end;						err := PlotIconID(r, 0, 0, 1156);						for d := 1 to wait * 3 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 1006);						for d := 1 to wait * 3 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 1156);						for d := 1 to wait * 3 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 1006);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 1007);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 1000);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 1001);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 1002);						for d := 1 to wait * 2 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 1152);						for d := 1 to wait * 3 do							l := 5 * (trunc(tickcount + 27));					end;				7: 					begin						if event <> oldevent then							begin								rgbForeColor(myGrayColor);								setRect(r, 10, 390, 470, 415);								fillRect(r, black);								RGBForeColor(myDarkDarkGrayColor);								moveTo(12, 400);								drawString('Zonks are like boulders.  We just call them zonks because we wanted to have a word with a Z in it.');								moveTo(12, 410);								drawString('They will fall, roll, and can be pushed.  Do not stand under them while they are falling!');								rgbForeColor(myBlackColor);								oldEvent := event;							end;						setRect(r, 338, 187, 370, 219);		{zonk}						for c := 700 to 707 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to wait do									l := 5 * (trunc(tickcount + 27));							end;						err := PlotIconID(r, 0, 0, 700);					end;				8: 					begin						if event <> oldevent then							begin								rgbForeColor(myGrayColor);								setRect(r, 10, 390, 470, 415);								fillRect(r, black);								RGBForeColor(myDarkDarkGrayColor);								moveTo(12, 400);								drawString('Disks are like bombs.  Murphy can gobble up red disks and spit them out later using the special key.');								moveTo(12, 410);								drawString('Green disks will fall and explode.  Yellow disks can be positioned and then detonated later.');								rgbForeColor(myBlackColor);								oldEvent := event;							end;						setRect(r, 69, 252, 101, 284);		{disk}						for c := 400 to 407 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to wait do									l := 5 * (trunc(tickcount + 27));							end;						for c := 407 downto 400 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to wait do									l := 5 * (trunc(tickcount + 27));							end;						err := PlotIconID(r, 0, 0, 135);					end;				9: 					begin						if event <> oldevent then							begin								rgbForeColor(myGrayColor);								setRect(r, 10, 390, 470, 415);								fillRect(r, black);								RGBForeColor(myDarkDarkGrayColor);								moveTo(12, 400);								drawString('Circuits are very boring.  They do not do anything of any importance whatsoever.  The only reason');								moveTo(12, 410);								drawString('that they are even in this game at all is to hold up other things and look nice.');								rgbForeColor(myBlackColor);								oldEvent := event;							end;						setRect(r, 34, 187, 66, 219);			{circuit}						for c := 450 to 457 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to wait do									l := 5 * (trunc(tickcount + 27));							end;						for c := 457 downto 450 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to wait do									l := 5 * (trunc(tickcount + 27));							end;						err := PlotIconID(r, 0, 0, 128);					end;				10: 					if event <> oldevent then						{exit}						begin							rgbForeColor(myGrayColor);							setRect(r, 10, 390, 470, 415);							fillRect(r, black);							RGBForeColor(myDarkDarkGrayColor);							moveTo(12, 400);							drawString('Once you have collected all the necessary infotrons, you can exit a level by using, yup, you guessed');							moveTo(12, 410);							drawString('it, the exit!!!');							rgbForeColor(myBlackColor);							oldEvent := event;						end;				11: 					if event <> oldevent then						begin													{ports}							rgbForeColor(myGrayColor);							setRect(r, 10, 390, 470, 415);							fillRect(r, black);							RGBForeColor(myDarkDarkGrayColor);							moveTo(12, 400);							drawString('Ports are a little like doors.  Some are one-way, some are two-way, and some are four-way.  There');							moveTo(12, 410);							drawString('must be a blank space on the other side of a port for you to use it.');							rgbForeColor(myBlackColor);							oldEvent := event;						end;				12: 					if event <> oldevent then						begin													{chips}							rgbForeColor(myGrayColor);							setRect(r, 10, 390, 470, 415);							fillRect(r, black);							RGBForeColor(myDarkDarkGrayColor);							moveTo(12, 400);							drawString('Many of the walls in Infotronª are made of chips. They are destroyed in explosions, and are rounded');							moveTo(12, 410);							drawString('on the edges, so other stuff can roll off of them.');							rgbForeColor(myBlackColor);							oldEvent := event;						end;				13: 					if event <> oldevent then						begin													{hardware}							rgbForeColor(myGrayColor);							setRect(r, 10, 390, 470, 415);							fillRect(r, black);							RGBForeColor(myDarkDarkGrayColor);							moveTo(12, 400);							drawString('The other walls are hardware.  They are absolutely indestructable, which means that Murphy cannot');							moveTo(12, 410);							drawString('walk through them unless there is a ginormous glitch in our programming somewhere.');							rgbForeColor(myBlackColor);							oldEvent := event;						end;				15: 					done := true;				otherwise					;			end;		until done;		at.h := 0;		at.v := 0;		setPort(help.wind);		drawPic(144, at);		setRect(r, 77, 284, 154, 308);		help.setBox(1, r, true);			{skip back}		setRect(r, 158, 284, 235, 308);		help.setBox(2, r, true);			{play}		setRect(r, 239, 284, 317, 308);		help.setBox(3, r, true);			{pause}		setRect(r, 321, 284, 398, 308);		help.setBox(4, r, true);			{skip next}		for d := 5 to 14 do			setRect(help.boxes[d], -10, -10, -10, -10);		setRect(specialRect, 78, 54, 398, 278);		myGW := makeGWorld(specialRect);		slide := 1;		event := 0;		t := LoadTutRes(500 + slide);		old := 3;		GetGWorld(oldGW, oldGD);		SetGWorld(myGW, nil);		DrawInitial2(t);		SetGWorld(oldGW, oldGD);		CopyWorldBits(myGW, help.wind, myGW^.portRect);		writetheText(t);		help.pressButton(help.boxes[old]);		aardvark := false;		sc := 1;		repeat			if button then				begin					help.unpressButton(help.boxes[old]);					event := help.mouseDown(c);					aardvark := true;				end;			if (event = 2) then				begin					if old = 3 then						readyTime := tickCount + t^^.theSteps[sc].timeDelay;					old := 2;					event := 0;				end			else if (event = 3) then				begin					old := 3;					event := 0;				end;			if sc > t^^.numSteps then				begin					if slide = 14 then						slide := 13;					help.unpressButton(help.boxes[old]);					aardvark := true;					event := 4;				end;			if ((event = 1) and (slide > 1)) or ((event = 4) and (slide < maxSlides)) then				begin					if event = 1 then						slide := slide - 1					else						slide := slide + 1;					disposeTutorial(t);					t := LoadTutRes(500 + slide);					GetGWorld(oldGW, oldGD);					SetGWorld(myGW, nil);					DrawInitial2(t);					SetGWorld(oldGW, oldGD);					CopyWorldBits(myGW, help.wind, myGW^.portRect);					writetheText(t);					event := 0;					sc := 1;					old := 3;				end;			if aardvark then				help.pressButton(help.boxes[old]);			aardvark := false;			if (old = 2) and (tickCount > readyTime) then				begin					GetGWorld(oldGW, oldGD);					SetGWorld(myGW, nil);					er := LockPixels(myGW^.portPixMap);					for cc := 1 to t^^.theSteps[sc].numChanges do						begin							tc := t^^.theSteps[sc].theChanges[cc];							DoPlot(tc.x, tc.y, tc.newIconNum);						end;					UnlockPixels(myGW^.portPixMap);					SetGWorld(oldGW, oldGD);					if t^^.theSteps[sc].soundID <> 0 then						PlaySound(t^^.theSteps[sc].soundID);					CopyWorldBits(myGW, help.wind, myGW^.portRect);					readyTime := tickCount + t^^.theSteps[sc].timeDelay;					sc := sc + 1;				end;		until event = 15;		help.rid;		setRect(r, 32, 53, 70, 91);				{murph}		help.setBox(1, r, false);		setRect(r, 32, 120, 70, 158);			{quark}		help.setBox(2, r, false);		setRect(r, 175, 53, 213, 91);			{info}		help.setBox(3, r, false);		setRect(r, 336, 53, 374, 91);			{term}		help.setBox(4, r, false);		setRect(r, 336, 120, 374, 158);		{bug}		help.setBox(5, r, false);		setRect(r, 175, 185, 213, 223);		{snik}		help.setBox(6, r, false);		setRect(r, 336, 185, 374, 223);		{zonk}		help.setBox(7, r, false);		setRect(r, 32, 250, 141, 288);		{disks}		help.setBox(8, r, false);		setRect(r, 32, 185, 70, 223);			{circuit}		help.setBox(9, r, false);		setRect(r, 175, 120, 213, 158);		{exit}		help.setBox(10, r, false);		setRect(r, 293, 250, 400, 288);		{ports}		help.setBox(11, r, false);		setRect(r, 32, 332, 141, 370);		{chips}		help.setBox(12, r, false);		setRect(r, 177, 332, 439, 370);		{hardware}		help.setBox(13, r, false);	end;	function doSetKey (var player: PlayerType; keysDial: CInfoDialog): boolean;		type			blah = array[1..5] of char;		var			c, event, oldEvent, num: integer;			ch: char;			at, at2: point;			thekeys: keyArr;			setKeys: blah;			keys: keyMap;			dummy: boolean;		procedure drawKeys (setKeys: blah);		begin			RGBForeColor(myRedColor);			textFace([]);			moveTo(92, 26);			drawKey(setKeys[1], true);			moveTo(39, 74);			drawKey(setKeys[2], true);			moveTo(144, 74);			drawKey(setKeys[3], true);			moveTo(92, 122);			drawKey(setKeys[4], true);			moveTo(145, 149);			drawKey(setKeys[5], true);		end;		function changeKey2 (num: integer): char;		begin			case num of				0: 					changeKey2 := 'A';				11: 					changeKey2 := 'B';				8: 					changeKey2 := 'C';				2: 					changeKey2 := 'D';				14: 					changeKey2 := 'E';				3: 					changeKey2 := 'F';				5: 					changeKey2 := 'G';				4: 					changeKey2 := 'H';				34: 					changeKey2 := 'I';				38: 					changeKey2 := 'J';				40: 					changeKey2 := 'K';				37: 					changeKey2 := 'L';				46: 					changeKey2 := 'M';				45: 					changeKey2 := 'N';				31: 					changeKey2 := 'O';				35: 					changeKey2 := 'P';				12: 					changeKey2 := 'Q';				15: 					changeKey2 := 'R';				1: 					changeKey2 := 'S';				17: 					changeKey2 := 'T';				32: 					changeKey2 := 'U';				9: 					changeKey2 := 'V';				13: 					changeKey2 := 'W';				7: 					changeKey2 := 'X';				16: 					changeKey2 := 'Y';				6: 					changeKey2 := 'Z';				18: 					changeKey2 := '1';				19: 					changeKey2 := '2';				20: 					changeKey2 := '3';				21: 					changeKey2 := '4';				23: 					changeKey2 := '5';				22: 					changeKey2 := '6';				26: 					changeKey2 := '7';				28: 					changeKey2 := '8';				25: 					changeKey2 := '9';				29: 					changeKey2 := '0';				27: 					changeKey2 := '-';				24: 					changeKey2 := '=';				51: 					changeKey2 := '~';				50: 					changeKey2 := '`';				49: 					changeKey2 := '_';				42: 					changeKey2 := '\';				30: 					changeKey2 := ']';				33: 					changeKey2 := '[';				39: 					changeKey2 := '"';				41: 					changeKey2 := ';';				44: 					changeKey2 := '/';				47: 					changeKey2 := '.';				43: 					changeKey2 := ',';				82: 					changeKey2 := 'a';				83: 					changeKey2 := 'b';				84: 					changeKey2 := 'c';				85: 					changeKey2 := 'd';				86: 					changeKey2 := 'e';				87: 					changeKey2 := 'f';				88: 					changeKey2 := 'g';				89: 					changeKey2 := 'h';				91: 					changeKey2 := 'i';				92: 					changeKey2 := 'j';				71: 					changeKey2 := 'Ù';				otherwise					changeKey2 := '+';			end;		end;		procedure cqrd;			var				changeKey2: char;				q: integer;		begin			case q of				18: 					changeKey2 := '!';				19: 					changeKey2 := '@';				20: 					changeKey2 := '#';				21: 					changeKey2 := '$';				23: 					changeKey2 := '%';				22: 					changeKey2 := '^';				26: 					changeKey2 := '&';				28: 					changeKey2 := '*';				25: 					changeKey2 := '(';				29: 					changeKey2 := ')';				49: 					changeKey2 := '_';				42: 					changeKey2 := '|';				30: 					changeKey2 := '}';				33: 					changeKey2 := '{';				39: 					changeKey2 := '"';				41: 					changeKey2 := ':';				44: 					changeKey2 := '?';				47: 					changeKey2 := '>';				43: 					changeKey2 := '<';			end;		end;	begin		keysDial.setUp;		at.h := 80;		at.v := 54;		theKeys := player.keySet;		for c := 1 to 5 do			begin				keys[theKeys[c]] := true;				setKeys[c] := changeKey2(theKeys[c]);			end;		drawKeys(setKeys);		oldEvent := 999;		repeat			getKeys(keys);			while not button and not keys[36] and not keys[53] do				getKeys(keys);			if keys[53] then				event := 2			else if not keys[36] then				event := keysDial.mouseDown(c)			else				event := keysDial.returnHit;			RGBForeColor(myRedColor);			if (event <> oldEvent) and (oldEvent in [3..7]) then				begin					moveTo(at2.h, at2.v);					textFace([]);					drawKey(setKeys[oldEvent - 2], true);				end;			if (event in [3..7]) then				begin					drawPic(300 + event, at);					if event = 3 then						setPt(at2, 92, 26)					else if event = 4 then						setPt(at2, 39, 74)					else if event = 5 then						setPt(at2, 144, 74)					else if event = 6 then						setPt(at2, 92, 122)					else						setPt(at2, 145, 149);					moveTo(at2.h, at2.v);					textFace([bold]);					drawKey(setKeys[event - 2], true);					textFace([]);					moveTo(at2.h, at2.v);					repeat						getKeys(keys);						ch := changeKey(keys, dummy, num);					until not (ch in ['+', '~']) or button or keys[36];					if not button then						begin							if keys[36] then								event := keysDial.returnHit							else if not (ch in ([setKeys[1], setKeys[2], setKeys[3], setKeys[4], setKeys[5]] - [setKeys[event - 2]])) then								begin									drawKey(ch, true);									setKeys[event - 2] := ch;									theKeys[event - 2] := num;									event := 8;								end							else								begin									moveTo(at2.h, at2.v);									textFace([]);									drawKey(setKeys[event - 2], true);									doError('You have already used that key!  Please choose again.');									keysDial.redraw;									drawKeys(setKeys);									event := 8;								end;						end;					oldEvent := event;				end;			if not (event in [1, 3..7]) then				drawPic(308, at);		until (event = 1) or (event = 2);		if event = 1 then			player.keySet := theKeys;		doSetKey := (event = 1);		keysDial.rid;	end;	function openChoice (var name: str255; openDial: CInfoScrollDialog): boolean;		var			keys: keyMap;			up, down, r: rect;			event, sel, oldSel: integer;			lastTime: longint;	begin		sel := 1;		oldSel := 0;		openDial.sel := 1;		openDial.setUp2(false);		lastTime := 0;		repeat			event := 0;			getKeys(keys);			while not button and not keys[36] and not keys[126] and not keys[125] and not keys[53] do				getKeys(keys);			if keys[36] then				event := openDial.returnHit			else if keys[125] then				sel := openDial.goDown			else if keys[126] then				sel := openDial.goUp			else if keys[53] then				event := 2			else				event := openDial.mouseDown(sel);			if event = 15 then				begin					if (oldSel = sel) then						if ((tickCount - lastTime) <= (getDblTime)) and (sel <> 0) then							event := 1;					oldSel := sel;					lastTime := tickCount;				end;			if (event = 1) and (sel = 0) then				begin					doError('Please select an item first...');					openDial.reDraw;					event := 12;				end;		until (event = 1) or (event = 2);		if event = 1 then			name := openDial.list[sel];		openChoice := (event = 1);		openDial.rid;	end;{$S DorkySegment2}	function DeleteChoice (var name: str255; delDial: CInfoScrollDialog): boolean;		var			keys: keyMap;			up, down, r: rect;			event, sel, oldSel: integer;			lastTime: longint;	begin		sel := 1;		oldSel := 0;		delDial.sel := 1;		delDial.setUp2(false);		lastTime := 0;		repeat			event := 0;			getKeys(keys);			while not button and not keys[36] and not keys[126] and not keys[125] and not keys[53] do				getKeys(keys);			if keys[36] then				event := delDial.returnHit			else if keys[125] then				sel := delDial.goDown			else if keys[126] then				sel := delDial.goUp			else if keys[53] then				event := 2			else				event := delDial.mouseDown(sel);			if event = 15 then				begin					if (oldSel = sel) then						if ((tickCount - lastTime) <= (getDblTime)) and (sel <> 0) then							event := 1;					oldSel := sel;					lastTime := tickCount;				end;			if (event = 1) and (sel = 0) then				begin					doError('Please select an item first...');					delDial.reDraw;					event := 12;				end;			if event = 1 then				begin					if CheckSure then						name := delDial.list[sel]					else						event := 0;					delDial.redraw;				end;		until (event = 1) or (event = 2);		deleteChoice := (event = 1);		delDial.rid;	end;	function getWinName (var theName: str255; Dial: CInfoDialog): boolean;		var			keys: keyMap;			r: rect;			on, done, shift: boolean;			ch, oldCh: char;			at: point;			name: str255;			count, ct: longint;			event, place: integer;			d: integer;	begin		Dial.setUp;		ct := getCaretTime;		on := false;		done := false;		RGBForeColor(myBlackColor);		fillRect(Dial.boxes[3], black);		moveTo(22, 55);		count := tickCount;		place := 1;		name := '';		repeat			moveTo(22 + stringWidth(name), 55);			done := false;			while not button and not done do				begin					if (tickCount >= (count + ct)) then						begin							if on then								RGBForeColor(myBlackColor)							else								RGBForeColor(myRedColor);							getPen(at);							moveTo(at.h, at.v + 2);							lineTo(at.h, at.v - 12);							on := (on = false);							moveTo(at.h, at.v);							count := tickCount;						end;					getKeys(keys);					ch := changeKey(keys, shift, d);					if ch in ['a'..'z'] then						ch := '_';					if (ch <> oldCh) then						begin							if not shift and (ch in ['A'..'Z']) then								ch := chr(ord(ch) + (ord('a') - ord('A')));							if (ch = '_') and (stringWidth(name) < 148) then								begin									RGBForeColor(myBlackColor);									getPen(at);									moveTo(at.h, at.v + 2);									lineTo(at.h, at.v - 12);									moveTo(at.h, at.v);									drawChar(' ');									name := concat(name, ' ');									name[place] := ' ';									place := place + 1;								end							else if (ch = '~') and (place > 1) then								begin									getPen(at);									RGBForeColor(myBlackColor);									setRect(r, at.h - CharWidth(name[place - 1]), at.v - 13, at.h + 2, at.v + 3);									fillRect(r, black);									place := place - 1;									delete(name, place, 1);									moveTo(r.left, at.v);								end							else if (ch <> '+') and (ch <> '~') and (stringWidth(name) < 140) then								begin									RGBForeColor(myBlackColor);									getPen(at);									moveTo(at.h, at.v + 2);									lineTo(at.h, at.v - 12);									moveTo(at.h, at.v);									rgbForeColor(myRedColor);									drawKey(ch, false);									name := concat(name, ' ');									name[place] := ch;									place := place + 1;								end;						end					else if keys[36] then						done := true					else if keys[53] then						done := true;					if not shift and (ch in ['a'..'z']) then						oldCh := chr(ord(ch) + (ord('A') - ord('a')))					else						oldCh := ch;				end;			if not done then				event := Dial.mouseDown(place)			else if keys[36] then				event := Dial.returnHit			else				event := 2;			if (place = 1) and (event = 1) then				begin					doError('Sorry, you have to have at least one or two letters in your name...');					Dial.redraw;					event := 0;				end;		until (event = 1) or (event = 2);		if event <> 2 then			theName := name;		getWinName := event <> 2;		Dial.rid;	end;	procedure doAbout (aboutDial: CInfoDialog);		var			at: point;			event, c, d: integer;			l: real;			r, specialRect: rect;			err: osErr;			myGW: GWorldPtr;			picNum: integer;			oldGW: GWorldPtr;			oldGD: GDHandle;			rBox: rect;			regi: boolean;			regiName: str255;		procedure SetRInf;			type				somethingRec = record						dumInt1: integer;						dumFloat2: real;						ignoreS1: str255;						ignoreS2: str255;						theS: str255;						moreDum: integer;					end;				stPtr = ^somethingRec;				stHand = ^stPtr;			var				mySH: stHand;				cnt: integer;		begin			cnt := Count1Resources('QarD');			if (cnt = 1) and (resError = noErr) then				begin					mySH := stHand(Get1Resource('QarD', 128));					if (mySH <> nil) and (resError = noErr) then						begin							regi := TRUE;							regiName := mySH^^.theS;							ReleaseResource(handle(mySH));						end					else						begin							regi := FALSE;							regiName := '';						end;				end			else				begin					regi := FALSE;					regiName := '';				end;		end;		procedure Strip1 (var s: str255);			var				t: str255;				c: integer;		begin			t := '';			for c := 1 to length(s) - 1 do				t := concat(t, s[c]);			s := t;		end;	begin		aboutDial.setUp;		RGBForeColor(myBlackColor);		TextMode(srcOr);		TextSize(9);		TextFace([]);		rBox.top := 63;		rBox.bottom := 93;		rBox.left := 10;		rBox.right := 89;{FrameRect(rBox);}		SetRInf;		if regi then			begin				MoveTo(rBox.left + 3, rBox.top + 12);				DrawString('Registered to:');				MoveTo(rBox.left + 3, rBox.bottom - 6);				while StringWidth(regiName) >= ((rBox.right - rBox.left) - 3) do					Strip1(regiName);				DrawString(regiName);			end		else			begin				MoveTo(((rBox.right + rBox.left) div 2) - (stringWidth('Unregistered') div 2), ((rBox.bottom + rBox.top) div 2) + 3);				DrawString('Unregistered');			end;		setRect(r, 0, 0, 116, 138);		myGW := makeGWorld(r);		at.h := 0;		setRect(specialRect, 130, 60, 246, 198);		picNum := 150;		at.v := -10;		event := 1;		repeat			if button then				event := aboutDial.mouseDown(c);			case event of				1, 2: 					begin						picNum := 149 + event;						at.v := -10;					end;				3: 					;				4: 					begin						setRect(r, 38, 64, 70, 96);				{murph}						for c := 500 to 510 do							begin								err := PlotIconID(r, 0, 0, c);								for d := 1 to 230 * 2 do									l := 5 * (trunc(tickcount + 27));							end;						err := PlotIconID(r, 0, 0, 500);						for d := 1 to 230 do							l := 5 * (trunc(tickcount + 27));						err := PlotIconID(r, 0, 0, 198);					end;				otherwise					;			end;			ForeColor(blackColor);			BackColor(whiteColor);			GetGWorld(oldGW, oldGD);			if not LockPixels(myGW^.portpixmap) then				exittoshell;			SetGWorld(myGW, nil);			drawPic(picNum, at);			at.v := at.v - 2;			SetGWorld(oldGw, oldGD);			UnlockPixels(myGW^.portpixmap);			CopyWorldBits2(myGW, AboutDial.wind, myGW^.portRect, specialRect);			if picNum = 150 then				begin					if at.v < -975 then						at.v := -20;				end			else				begin					if at.v < -800 then						at.v := -20;				end;			if event in [1, 2, 4] then				event := 0;		until event = 3;		destroyGWorld(myGW);		aboutDial.rid;	end;	function doReg (var name: str255; regDial: CInfoDialog): boolean;		const {ipated}			tooLong = 'WWWWWWWWWWWWWWWWWWWWWWWW..';		var			keys: keyMap;			r: rect;			on, done, shift: boolean;			ch, oldCh: char;			at: point;			strings: array[1..2] of str255;			whichBox: integer;			count, ct: longint;			event, place: integer;			places: array[1..2] of integer;			j: integer;		function checkRegis (nreg, rcod: str255): boolean;			function BankCode (occ: integer; bnk: integer; offset: integer): str255;				var					r: str255;					ini: integer;					amtAdd: integer;					ranges: array[1..5] of integer;					c: integer;					temp: integer;					theNum: integer;			begin				ini := (bnk - 1) * 5 + 1;	{calc initial number of bank}				for c := 1 to 5 do		{figure number range}					ranges[c] := ini + (c - 1);				for c := 1 to offset do	{rotate numbers}					begin						temp := ranges[5];						ranges[5] := ranges[4];						ranges[4] := ranges[3];						ranges[3] := ranges[2];						ranges[2] := ranges[1];						ranges[1] := temp;					end;				theNum := ranges[occ];	{choose the correct number}				case theNum of					1: 						r := 'BC';					2: 						r := 'D3';					3: 						r := '5B';					4: 						r := '7C';					5: 						r := '4Q';					6: 						r := 't4';					7: 						r := '3V';					8: 						r := 'aS';					9: 						r := 'pT';					10: 						r := '23';					11: 						r := 'tL';					12: 						r := 'aA';					13: 						r := 'Rd';					14: 						r := 'vA';					15: 						r := 'rK';					16: 						r := 'lE';					17: 						r := 'Ts';					18: 						r := 'Le';					19: 						r := 'eP';					20: 						r := 'iN';					21: 						r := 'gD';					22: 						r := 'Og';					23: 						r := 'sL';					24: 						r := 'iE';					25: 						r := '42';					26: 						r := 'hI';					27: 						r := 'hO';					28: 						r := 'wA';					29: 						r := 'rE';					30: 						r := 'yO';					31: 						r := 'uT';					32: 						r := 'oD';					33: 						r := 'aY';					34: 						r := '2Q';					35: 						r := 'VB';				end;				BankCode := r;			end;			procedure ToLower (var s: Str255);				var					c: integer;			begin				for c := 1 to length(s) do					if (s[c] >= 'A') and (s[c] <= 'Z') then						s[c] := char(ord(s[c]) + (ord('a') - ord('A')));			end;			function FindCode (name: str255): str255;				var					t: str255;					bnum: integer;					onum: integer;					c: integer;			begin				ToLower(name);				t := '';				for c := 1 to length(name) do					begin						onum := 0;						if name[c] = ' ' then							bnum := 7						else if name[c] = 'z' then							bnum := 6						else							begin								bnum := ((ord(name[c]) - ord('a')) div 5) + 1;								onum := ((ord(name[c]) - ord('a')) mod 5);							end;						t := concat(t, BankCode((c - 1) mod 5 + 1, bnum, onum));					end;				t := concat(char((length(name) mod 26) + ord('A')), t);				FindCode := t;			end;			function IllChar (s: str255): boolean;				var					ic: boolean;					b: integer;			begin				ic := false;				b := 1;				while not ic and (b <= length(s)) do					if not (s[b] in ['A'..'Z', ' ', 'a'..'z']) then						ic := TRUE					else						b := b + 1;				IllChar := ic;			end;		begin			if not IllChar(nreg) then				begin					if length(nreg) > 4 then						begin							if rcod = FindCode(nreg) then								checkRegis := TRUE							else								checkRegis := FALSE;						end					else						checkRegis := FALSE;				end			else				checkRegis := FALSE;		end;		function coolLengths: boolean;			var				a: boolean;		begin			if whichBox = 1 then				coolLengths := (stringWidth(strings[1]) < stringWidth(tooLong))			else				coolLengths := (stringWidth(strings[2]) < stringWidth(tooLong))		end;		var			d: boolean;	begin		strings[1] := '';		strings[2] := '';		regDial.setUp;		ct := getCaretTime;		on := false;		done := false;		moveTo(22, 85);		count := tickCount;		places[1] := 1;		places[2] := 1;		place := 1;		name := '';		whichBox := 1;		repeat			if whichBox = 1 then				moveTo(58 + stringWidth(strings[1]), 82)			else				moveTo(58 + stringWidth(strings[2]), 109);			done := false;			while not button and not done do				begin					if (tickCount >= (count + ct)) then						begin							if on then								RGBForeColor(myBlackColor)							else								RGBForeColor(myRedColor);							getPen(at);							moveTo(at.h, at.v + 2);							lineTo(at.h, at.v - 12);							on := (on = false);							moveTo(at.h, at.v);							count := tickCount;						end;					getKeys(keys);					ch := changeKey(keys, shift, j);					if ch in ['a'..'z'] then						ch := '_';					if (ch <> oldCh) then						begin							if not shift and (ch in ['A'..'Z']) then								ch := chr(ord(ch) + (ord('a') - ord('A')));							if (ch = '_') and coolLengths then								begin									RGBForeColor(myBlackColor);									getPen(at);									moveTo(at.h, at.v + 2);									lineTo(at.h, at.v - 12);									moveTo(at.h, at.v);									drawChar(' ');									strings[whichbox] := concat(strings[whichbox], ' ');									strings[whichbox][place] := ' ';									place := place + 1;								end							else if ch = ' ' then								begin									RGBForeColor(myBlackColor);									getPen(at);									moveTo(at.h, at.v + 2);									lineTo(at.h, at.v - 12);									moveTo(at.h, at.v);									places[whichBox] := place;									whichBox := (whichBox mod 2) + 1;									place := places[whichBox];									if whichBox = 1 then										moveTo(58 + stringWidth(strings[1]), 82)									else										moveTo(58 + stringWidth(strings[2]), 109);								end							else if (ch = '~') and (place > 1) then								begin									getPen(at);									RGBForeColor(myBlackColor);									setRect(r, at.h - CharWidth(strings[whichbox][place - 1]), at.v - 13, at.h + 2, at.v + 3);									fillRect(r, black);									place := place - 1;									delete(strings[whichbox], place, 1);									moveTo(r.left, at.v);								end							else if (ch <> '+') and (ch <> '~') and coolLengths then								begin									RGBForeColor(myBlackColor);									getPen(at);									moveTo(at.h, at.v + 2);									lineTo(at.h, at.v - 12);									moveTo(at.h, at.v);									rgbForeColor(myRedColor);									drawKey(ch, false);									strings[whichbox] := concat(strings[whichbox], ' ');									strings[whichbox][place] := ch;									place := place + 1;								end;						end					else if keys[36] then						done := true;					if not shift and (ch in ['a'..'z']) then						oldCh := chr(ord(ch) + (ord('A') - ord('a')))					else						oldCh := ch;				end;			if not done then				begin					event := regDial.mouseDown(place);					if (event > 2) and (event - 2 <> whichBox) then						begin							RGBForeColor(myBlackColor);							getPen(at);							moveTo(at.h, at.v + 2);							lineTo(at.h, at.v - 12);							moveTo(at.h, at.v);							places[whichBox] := place;							whichBox := event - 2;							place := places[whichBox];						end;				end			else				event := regDial.returnHit;			if (place = 1) and (event = 1) then				begin					doError('Sorry, you have to have at least one or two letters in your name...');					regDial.redraw;					event := 0;				end;			if event = 1 then				begin					d := checkRegis(strings[1], strings[2]);					if not d then						begin							doError('Sorry, your registration code is invalid.  Please guess again...');							event := 0;						end					else						begin							doReg := true;							name := strings[1];						end;				end;		until (event = 1) or (event = 2);		if event = 2 then			doReg := false;		regDial.rid;	end;	procedure SetUpDials (var RegDial, AboutDial, newDial, renDial, keysDial, help: CInfoDialog; var lvlDial, openDial, delDial: CInfoScrollDialog);		var			at: point;			r, up, down: rect;	begin		new(CInfoDialog(regDial));		regDial.init(155, 155);		setRect(r, 348, 67, 421, 86);		{ok}		regDial.setBox(1, r, true);		setRect(r, 348, 94, 421, 113);	{cancel}		regDial.setBox(2, r, true);		setRect(r, 55, 67, 345, 86);		{name}		regDial.setBox(3, r, false);		setRect(r, 55, 94, 345, 113);		{regis code}		regDial.setBox(4, r, false);		new(CInfoDialog(AboutDial));		AboutDial.init(149, 149);		setRect(r, 20, 109, 93, 128);		AboutDial.setBox(1, r, true);		setRect(r, 20, 138, 93, 157);		AboutDial.setBox(2, r, true);		setRect(r, 20, 167, 93, 186);		AboutDial.setBox(3, r, true);{    setRect(r, 36, 62, 73, 99);}{    AboutDial.setBox(4, r, false);}		new(CInfoDialog(newDial));		newDial.init(133, 133);		setRect(r, 200, 13, 273, 32);		newDial.setBox(1, r, true);		setRect(r, 200, 41, 273, 60);		newDial.setBox(2, r, true);		setRect(r, 17, 42, 178, 59);		newDial.setBox(3, r, false);		new(CInfoDialog(renDial));		renDial.init(133, 134);		setRect(r, 200, 13, 273, 32);		renDial.setBox(1, r, true);				{ok}		setRect(r, 200, 41, 273, 60);		renDial.setBox(2, r, true);				{cancel}		setRect(r, 17, 42, 178, 59);		renDial.setBox(3, r, false);				{text}		new(CInfoDialog(Help));		help.init(143, 143);		setRect(r, 32, 53, 70, 91);				{murph}		help.setBox(1, r, false);		setRect(r, 32, 120, 70, 158);			{quark}		help.setBox(2, r, false);		setRect(r, 175, 53, 213, 91);			{info}		help.setBox(3, r, false);		setRect(r, 336, 53, 374, 91);			{term}		help.setBox(4, r, false);		setRect(r, 336, 120, 374, 158);		{bug}		help.setBox(5, r, false);		setRect(r, 175, 185, 213, 223);		{snik}		help.setBox(6, r, false);		setRect(r, 336, 185, 374, 223);		{zonk}		help.setBox(7, r, false);		setRect(r, 32, 250, 141, 288);		{disks}		help.setBox(8, r, false);		setRect(r, 32, 185, 70, 223);			{circuit}		help.setBox(9, r, false);		setRect(r, 175, 120, 213, 158);		{exit}		help.setBox(10, r, false);		setRect(r, 293, 250, 400, 288);		{ports}		help.setBox(11, r, false);		setRect(r, 32, 332, 141, 370);		{chips}		help.setBox(12, r, false);		setRect(r, 177, 332, 439, 370);		{hardware}		help.setBox(13, r, false);		setRect(r, 403, 14, 456, 37);			{ok}		help.setBox(15, r, true);		new(CInfoScrollDialog(lvlDial));		setRect(up, 283, 12, 296, 25);		setRect(down, 283, 129, 296, 142);		lvlDial.init2(130, 130, 162, 9, up, down, levelResType, true);		setRect(r, 19, 32, 92, 51);				{choose}		lvlDial.setBox(1, r, true);		setRect(r, 19, 68, 92, 87);				{skip}		lvlDial.setBox(2, r, true);		setRect(r, 19, 101, 92, 120);			{cancel}		lvlDial.setBox(3, r, true);		new(CInfoDialog(keysDial));		keysDial.init(132, 132);		setRect(r, 14, 170, 87, 189);		keysDial.setBox(1, r, true);				{ok}		setRect(r, 105, 170, 178, 189);		keysDial.setBox(2, r, true);				{cancel}		setRect(r, 84, 14, 111, 32);		keysDial.setBox(3, r, false);				{up}		setRect(r, 30, 61, 58, 80);		keysDial.setBox(4, r, false);				{left}		setRect(r, 135, 62, 163, 80);		keysDial.setBox(5, r, false);				{right}		setRect(r, 84, 110, 111, 129);		keysDial.setBox(6, r, false);				{down}		setRect(r, 137, 137, 164, 155);		keysDial.setBox(7, r, false);				{special}		setRect(r, 77, 51, 114, 88);		keysDial.setBox(8, r, false);		new(CInfoScrollDialog(openDial));		setRect(up, 179, 11, 192, 24);		setRect(down, 179, 101, 192, 114);		openDial.init2(131, 131, 161, 7, up, down, playerResType, false);		setRect(r, 215, 33, 288, 52);		openDial.setBox(1, r, true);				{ok}		setRect(r, 215, 76, 288, 95);		openDial.setBox(2, r, true);				{cancel}		new(CInfoScrollDialog(delDial));		setRect(up, 179, 11, 192, 24);		setRect(down, 179, 101, 192, 114);		delDial.init2(131, 145, 161, 7, up, down, playerResType, false);		setRect(r, 215, 33, 288, 52);		delDial.setBox(1, r, true);				{ok}		setRect(r, 215, 76, 288, 95);		delDial.setBox(2, r, true);				{cancel}	end;{$S ReallyBizarre}end.
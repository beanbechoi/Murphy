unit DesBoard;{4.0}interface	uses		PascalSucks, QDOffscreen, QOffscreen;	const		kMaxThings = 40;		kBaseNum = 128;		levelResType = 'lŸVl';	type		copyArray = array[1..20, 1..20] of integer;		boardArray = array[1..150, 1..150] of integer;		ThingArray = array[1..kMaxThings] of integer;		twoZeroArray = array[1..120, 1..120] of integer;		oneZeroArray = array[0..0] of integer;{User interface description}		bcp = ^bcpp;		bcpp = ^CompressedBoard;		CompressedBoard = record				name: str255;				sizeX, sizeY: integer;									{How far right and down does the level extend?}				murphy, term: integer;											{where does murphy start}				numScissors: integer;				numQuarks: integer;				numInfotrons: integer;				numBugs: integer;				numComp: integer;			{how many run-length compression thingys did we use up?}				theBoard: oneZeroArray;			end;		bap = ^bapp;		bapp = ^LevelRecord;		LevelRecord = record				name: str255;				sizeX, sizeY: integer;									{How far right and down does the level extend?}				murphy, term: integer;											{where does murphy start}				numScissors: integer;				numQuarks: integer;				numInfotrons: integer;				numBugs: integer;				scissors, quarks, bugs: ThingArray;				theBoard: twoZeroArray;			end;{$S DesBoard}	type		funkPtr = ^locArr;		locArr = array[128..1500] of rect;	var		gIconOff: GWorldPtr;		gIconLocs: funkPtr;	function NewBoardDataStructure: bap;	function DecompressBoard (c: bcp; var b: bap): boolean;				{FALSE if it failed}	function LoadCompBoard (name: str255; var compData: bcp): boolean;	function loadBoard (name: str255; var theBoard: bap): boolean;	procedure DrawBoard (theBoard: bap; theWind: WindowPtr; top, left: integer);	procedure DrawHStrip (theBoard: bap; theWind: WindowPtr; theRect: rect; top, left: integer);	procedure DrawVStrip (theBoard: bap; theWind: WindowPtr; theRect: rect; top, left: integer);	function PlotIconID (TheRect: Rect; Align: integer; Transform: integer; TheResID: INTEGER): OSErr;	procedure CompressLevel (b: bap; var c: bcp);	procedure InitDesBoard;implementation	function PlotIconID (TheRect: Rect; Align: integer; Transform: integer; TheResID: INTEGER): OSErr;		{keep same format}		var			gp: GrafPtr;	begin		GetPort(gp);		CopyWorldBits2(gIconOff, gp, gIconLocs^[theResID], theRect);	end;	function PlotOld (TheRect: Rect; Align: integer; Transform: integer; TheResID: INTEGER): OSErr;	inline			{the old plot routine}		$303C, $0500, $ABC9;	procedure SetUpIcons;		var			count: integer;			oldGD: GDHandle;			oldGW: GWorldPtr;			numAc: integer;			r: rect;			myIcn: handle;			err: OSErr;			ignore: boolean;			invalidR: rect;	begin		SetRect(r, 0, 0, 482 + 64, 418 + 64);		gIconOff := MakeGWorld(r);		SetRect(invalidR, -1, -1, -1, -1);		r.top := 1;		r.left := 1;		r.right := 1 + 32;		r.bottom := 1 + 32;		GetGWorld(oldGW, oldGD);		SetGWorld(gIconOff, nil);		ignore := LockPixels(gIconOff^.PortPixMap);		numAc := 0;		for count := 128 to 1500 do			begin				myIcn := GetResource('icl8', count);				if (myIcn <> nil) and (resError = noErr) then					begin						gIconLocs^[count] := r;						err := PlotOld(r, 0, 0, count);						ReleaseResource(myIcn);						OffsetRect(r, 32, 0);						numAc := numAc + 1;						if numAc = 17 then							begin								r.left := 1;								r.right := 1 + 32;								numAc := 0;								OffsetRect(r, 0, 32);							end;					end				else					gIconLocs^[count] := invalidR;				myIcn := nil;			end;		UnlockPixels(gIconOff^.portPixMap);		SetGWorld(oldGW, oldGD);	end;	procedure InitDesBoard;	begin		gIconLocs := funkPtr(NewPtrClear(sizeOf(locArr)));		SetUpIcons;	end;	function NewBoardDataStructure: bap;		var			qd: bap;			x, y: integer;	begin		qd := bap(NewHandleClear(sizeOf(LevelRecord)));		if (qd <> nil) and (memError = noErr) then			begin				MoveHHi(handle(qd));				HLock(handle(qd));				qd^^.sizeX := 120;				qd^^.sizeY := 120;				for x := 1 to qd^^.sizeX do					for y := 1 to qd^^.sizeY do{$PUSH}{$R-}						qd^^.theBoard[x, y] := kBaseNum;{$POP}			end;		NewBoardDataStructure := qd;	end;	function DecompressBoard (c: bcp; var b: bap): boolean;				{FALSE if it failed}		var			atx, aty, atbn: integer;			q: integer;			lastVal: integer;			cnt: integer;	begin		b := NewBoardDataStructure;		b^^.name := c^^.name;		b^^.sizeX := c^^.sizeX;		b^^.sizeY := c^^.sizeY;		b^^.murphy := c^^.murphy;		b^^.term := c^^.term;		b^^.numScissors := c^^.numScissors;		b^^.numQuarks := c^^.numQuarks;		b^^.numInfotrons := c^^.numInfotrons;		b^^.numBugs := c^^.numBugs;		atx := 1;		aty := 1;		atbn := 0;{$PUSH}{$R-}		for cnt := 1 to c^^.numScissors do			begin				b^^.scissors[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;		for cnt := 1 to c^^.numQuarks do			begin				b^^.quarks[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;		for cnt := 1 to c^^.numBugs do			begin				b^^.bugs[cnt] := c^^.theBoard[atbn];				atbn := atbn + 1;			end;{$R+}		lastVal := 128;		while (atbn < c^^.numComp) do			begin				atbn := atbn + 1;{$PUSH}{$R-}				if c^^.theBoard[atbn] < 0 then					begin						for q := 1 to (-c^^.theBoard[atbn] - 1) do{$R+}							begin								b^^.theBoard[atx, aty] := lastVal;								atx := atx + 1;								if atx > c^^.sizeX then									begin										aty := aty + 1;										atx := 1;									end;							end;					end				else					begin{$PUSH}{$R-}						b^^.theBoard[atx, aty] := c^^.theBoard[atbn];						lastVal := c^^.theBoard[atbn];{$R+}						atx := atx + 1;						if atx > c^^.sizeX then							begin								aty := aty + 1;								atx := 1;							end;					end;			end;		DecompressBoard := TRUE;		{it WILL work, darn it!}	end;	function LoadCompBoard (name: str255; var compData: bcp): boolean;		var			i: Handle;			com: bcp;			err: OSErr;			worked: boolean;			oldRes: integer;	begin{    KillData;}		i := GetNamedResource(levelResType, name);		worked := (i <> nil) and (ResError = noErr);		if worked then			begin				DetachResource(i);				com := bcp(i);				MoveHHi(handle(com));				HLock(handle(com));				compData := com;			end;		LoadCompBoard := worked;	end;	function loadBoard (name: str255; var theBoard: bap): boolean;		var			worked: boolean;			someData: bap;			dorky: rect;			e: boolean;			c: integer;			tempComp: bcp;	begin		worked := LoadCompBoard(name, tempComp);		if worked then			begin				worked := DecompressBoard(tempComp, someData);				HUnlock(handle(tempComp));				DisposeHandle(handle(tempComp));				MoveHHi(handle(someData));				HLock(handle(someData));				theBoard := someData;			end;		LoadBoard := worked;	end;	procedure DrawBoard (theBoard: bap; theWind: WindowPtr; top, left: integer);		var			ogp: GrafPtr;			countY, countX, numX, numY: integer;			r, r2: rect;			err: oserr;			tmpOff: GWorldPtr;			ignore: boolean;			oldGW: GWorldPtr;			oldGD: GDHandle;	begin		GetPort(ogp);		SetPort(theWind);		r := theWind^.portRect;		r.right := r.right + 32;		r.bottom := r.bottom + 32;		tmpOff := MakeGWorld(r);		if tmpOff = nil then			exittoshell;		r.right := r.right - 15 - 32;		r.bottom := r.bottom - 15 - 32;		GetGWorld(oldGW, oldGD);		SetGWorld(tmpOff, nil);		ignore := LockPixels(tmpOff^.portPixMap);		numX := (r.right - r.left) div 32 + 1;		numY := (r.bottom - r.top) div 32 + 1;		r2.left := 0;		r2.right := 32;		r2.bottom := 32;		r2.top := 0;		for countY := top to top + numY - 1 do			begin				for countX := left to left + numX - 1 do					begin						if (countX < 121) and (countY < 121) then							err := PlotIconID(r2, 0, 0, theBoard^^.theBoard[countX, countY]);						OffsetRect(r2, 32, 0);					end;				r2.left := 0;				r2.right := 32;				OffSetRect(r2, 0, 32);			end;		UnlockPixels(tmpOff^.portPixMap);		SetGWorld(oldGW, oldGD);		CopyWorldBits2(tmpOff, theWind, r, r);		DestroyGWorld(tmpOff);		SetPort(ogp);	end;	procedure DrawVStrip (theBoard: bap; theWind: WindowPtr; theRect: rect; top, left: integer);		var			ogp: GrafPtr;			countY, countX, numX, numY: integer;			r, r2: rect;			err: oserr;			tmpOff: GWorldPtr;			ignore: boolean;			oldGW: GWorldPtr;			oldGD: GDHandle;	begin		GetPort(ogp);		SetPort(theWind);		r := theRect;		r.right := r.right + 32;		r.bottom := r.bottom + 32;		tmpOff := MakeGWorld(r);		if tmpOff = nil then			exittoshell;		r.right := r.right - 32;		r.bottom := r.bottom - 32;		GetGWorld(oldGW, oldGD);		SetGWorld(tmpOff, nil);		ignore := LockPixels(tmpOff^.portPixMap);		numX := (r.bottom - r.top) div 32 + 1;		r2.left := theRect.left;		r2.right := theRect.left + 32;		r2.top := 0;		r2.bottom := 32;		for countX := top to top + numX - 1 do			begin				if (countX < 121) and (left < 121) then					err := PlotIconID(r2, 0, 0, theBoard^^.theBoard[left, countX]);				OffsetRect(r2, 0, 32);			end;		UnlockPixels(tmpOff^.portPixMap);		SetGWorld(oldGW, oldGD);		CopyWorldBits2(tmpOff, theWind, r, r);		DestroyGWorld(tmpOff);		SetPort(ogp);	end;	procedure DrawHStrip (theBoard: bap; theWind: WindowPtr; theRect: rect; top, left: integer);		var			ogp: GrafPtr;			countY, countX, numX, numY: integer;			r, r2: rect;			err: oserr;			tmpOff: GWorldPtr;			ignore: boolean;			oldGW: GWorldPtr;			oldGD: GDHandle;	begin		GetPort(ogp);		SetPort(theWind);		r := theRect;		r.right := r.right + 32;		r.bottom := r.bottom + 32;		tmpOff := MakeGWorld(r);		if tmpOff = nil then			exittoshell;		r.right := r.right - 32;		r.bottom := r.bottom - 32;		GetGWorld(oldGW, oldGD);		SetGWorld(tmpOff, nil);		ignore := LockPixels(tmpOff^.portPixMap);		numX := (r.right - r.left) div 32 + 1;		r2.left := 0;		r2.right := 32;		r2.top := theRect.top;		r2.bottom := theRect.top + 32;		for countX := left to left + numX - 1 do			begin				if (countX < 121) and (top < 121) then					err := PlotIconID(r2, 0, 0, theBoard^^.theBoard[countX, top]);				OffsetRect(r2, 32, 0);			end;		UnlockPixels(tmpOff^.portPixMap);		SetGWorld(oldGW, oldGD);		CopyWorldBits2(tmpOff, theWind, r, r);		DestroyGWorld(tmpOff);		SetPort(ogp);	end;	procedure CompressLevel (b: bap; var c: bcp);		var			currentVal: integer;			currentCount: integer;			cx, cy: integer;			bcnt: integer;			cnt: integer;	begin		c := bcp(NewHandleClear(SizeOf(CompressedBoard) + b^^.sizeX * b^^.sizeY * 2));		{# of bytes!}		MoveHHi(handle(c));		HLock(handle(c));		currentVal := -1;		currentCount := 1;		c^^.name := b^^.name;		c^^.sizeX := b^^.sizeX;		c^^.sizeY := b^^.sizeY;		c^^.murphy := b^^.murphy;		c^^.term := b^^.term;		c^^.numScissors := b^^.numScissors;		c^^.numQuarks := b^^.numQuarks;		c^^.numBugs := b^^.numBugs;		c^^.numInfotrons := b^^.numInfotrons;		bcnt := 1;{$PUSH}{$R-}		for cnt := 1 to c^^.numScissors do			begin				c^^.theBoard[bcnt] := b^^.scissors[cnt];				bcnt := bcnt + 1;			end;		for cnt := 1 to c^^.numQuarks do			begin				c^^.theBoard[bcnt] := b^^.quarks[cnt];				bcnt := bcnt + 1;			end;		for cnt := 1 to c^^.numBugs do			begin				c^^.theBoard[bcnt] := b^^.bugs[cnt];				bcnt := bcnt + 1;			end;{$POP}		for cy := 1 to b^^.sizeY do			for cx := 1 to b^^.sizeX do				begin					if b^^.theBoard[cx, cy] = currentVal then						currentCount := currentCount + 1					else if currentCount < 2 then						begin{$PUSH}{$R-}							c^^.theBoard[bcnt] := currentVal;							bcnt := bcnt + 1;						end					else						begin							c^^.theBoard[bcnt] := currentVal;							c^^.theBoard[bcnt + 1] := -currentCount;{$POP}							bcnt := bcnt + 2;							currentcount := 1;						end;					currentVal := b^^.theBoard[cx, cy];				end;		c^^.numComp := bcnt - 1;		HUnlock(handle(c));		SetHandleSize(handle(c), sizeof(CompressedBoard) + (bcnt + 1) * 2);		MoveHHi(handle(c));		HLock(handle(c));	end;{$S main}end.
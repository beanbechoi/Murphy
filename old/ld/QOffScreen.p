unit QOffScreen;{this is the revised color offscreen unit. Updated 6/4/94. Thanx to Brooke for discovering a bug,}{and to apprentice for fixing it!}{6/4: serious memory-leak/computer-crash problem fixed}{		routines renamed to make some damn sense!}{		got rid of COTBRand, since it seemed useless.}interface	uses		PascalSucks, QDOffscreen;	procedure Internal_QErr (s: str255;									shouldQuit: boolean);{MakeGWorld - call this to create an 8-bit GWorld the size of rect 'r'}	function MakeGWorld (r: rect): GWorldPtr;{MakeGWorldDepth - call this to create an n-bit GWorld the size of rect 'r'}	function MakeGWorldDepth (r: rect;									n: integer): GWorldPtr;{DestroyGWorld - Call this when you are done using your GWorldPtr}	procedure DestroyGWorld (var o: GWorldPtr);{CopyWorldBits - This will copy data from the given GWorld directly to the given window.}{The rect 'r' is the place that the data from the world should be positioned in the window.}{Note: the ENTIRE world is copied in this routine.}	procedure CopyWorldBits (world: GWorldPtr;									window: WindowPtr;									r: rect);{CopyWorldBits2 - This will copy data from the given GWorld directly to the given window.}{The rect 'r1' is the rect, in the offscreen's coordinates, of what to copy}{The rect 'r2' is the rect, in window coordinates, of where the copy should be placed.}{Note: this is useful for copying small portions of the offscreen world onto your window.}	procedure CopyWorldBits2 (world: GWorldPtr;									window: WindowPtr;									r1, r2: rect);{CopyWorldMask - by Daniel Sandler.  Uses a mask.}	procedure CopyWorldMask (world, maskWorld: GWorldPtr;									window: WindowPtr;									r1, rmask, r2: rect);	procedure CopySameWorldMask (world: GWorldPtr;									window: WindowPtr;									r1, rmask, r2: rect);{CopyBitMapToOffscreen - if you have a bit map (such as qd.qd.qd.qd.qd.qd.qd.screenBits) that you want to}{copy, here's what you use. The entire bitmap will be copied, but you can specify the}{destination rectangle of the copied image in GWorld coordinates, using 'r'}	procedure CopyBitMapToOffscreen (biting: BitMap;									world: GWorldPtr;									r: rect);{CopyOffscreenToBitMap - the reverse of CopyBitMapToOffscreen, this one will copy}{from your gworld to a bit map (such as qd.qd.qd.qd.qd.qd.qd.screenBits).}{Note: 'r' is the rectangle of your SOURCE image, and not the destination.}{		The entire bitmap will be filled using this routine.}	procedure CopyOffscreenToBitMap (world: GWorldPtr;									biting: BitMap;									r: rect);	procedure CopyOffToOffRect (w1: GWorldPtr;									l1: boolean;									w2: GWorldPtr;									l2: boolean;									r1, r2: rect);implementation	procedure Internal_QErr (s: str255;									shouldQuit: boolean);		procedure Internal_SDD (num: integer);			var				tDlog: DialogPtr;				itemHit: integer;		begin			tDlog := GetNewDialog(num, nil, WindowPtr(-1));			ShowWindow(tDlog);			SetPort(tDlog);			ModalDialog(nil, itemHit);			DisposeDialog(tDlog);		end;	begin		Sysbeep(10);		ParamText(s, '', '', '');		Internal_SDD(501);		if shouldQuit then			exittoshell;	end;	function MakeGWorld (r: rect): GWorldPtr;		var			oldGD: GDHandle;			oldGW, newWorld: GWorldPtr;			err: QDErr;			pt: GrafPtr;	begin		GetPort(pt);		GetGWorld(oldGW, oldGD);		err := NewGWorld(newWorld, 8, r, nil, oldGD, 0);		if err <> noErr then			Internal_QErr('Fatal Error: Not enough memory. Please increase the amount of memory Infotronª has by choosing "Get Info..." from the File menu while Infotronª is selected.', TRUE);		makegworld := newWorld;	end;	function MakeGWorldDepth (r: rect;									n: integer): GWorldPtr;		var			oldGD: GDHandle;			oldGW, newWorld: GWorldPtr;			err: QDErr;			pt: GrafPtr;	begin		GetPort(pt);		GetGWorld(oldGW, oldGD);		err := NewGWorld(newWorld, n, r, nil, oldGD, 0);		if err <> noErr then			Internal_QErr('Fatal Error: Not enough memory. Please increase the amount of memory Infotronª has by choosing "Get Info..." from the File menu while Infotronª is selected.', TRUE);		MakeGWorldDepth := newWorld;	end;	procedure DestroyGWorld (var o: GWorldPtr);{memory leak/bug fixed: 6/4/94}	begin		if o <> nil then			begin				UnlockPixels(o^.portPixMap);				DisposeGWorld(o);			end;	end;	procedure CopyWorldBits (world: GWorldPtr;									window: WindowPtr;									r: rect);		var			clr: RGBColor;			m: Boolean;	begin		m := LockPixels(world^.portPixMap);		CopyBits(GrafPtr(world)^.portBits, GrafPtr(window)^.portBits, world^.portRect, r, srcCopy, nil);		UnlockPixels(world^.portPixMap);	end;	procedure CopyWorldBits2 (world: GWorldPtr;									window: WindowPtr;									r1, r2: rect);		var			clr: RGBColor;			m: Boolean;	begin		m := LockPixels(world^.portPixMap);		CopyBits(GrafPtr(world)^.portBits, GrafPtr(window)^.portBits, r1, r2, srcCopy, nil);		UnlockPixels(world^.portPixMap);	end;	procedure CopyWorldMask (world, maskWorld: GWorldPtr;									window: WindowPtr;									r1, rmask, r2: rect);		var			clr: RGBColor;			m, m2: Boolean;	begin		m := LockPixels(GetGWorldPixMap(world));		if not m then			internal_Qerr('Couldn''t lock src pixels', true);		m2 := LockPixels(GetGWorldPixMap(maskworld));		if not m2 then			internal_Qerr('Couldn''t lock mask pixels', true);		CopyMask(GrafPtr(world)^.portBits, GrafPtr(maskWorld)^.portBits, GrafPtr(window)^.portBits, r1, rmask, r2);		UnlockPixels(GetGWorldPixMap(world));		UnlockPixels(GetGWorldPixMap(maskworld));	end;	procedure CopySameWorldMask (world: GWorldPtr;									window: WindowPtr;									r1, rmask, r2: rect);		var			clr: RGBColor;			m, m2: Boolean;	begin		m := LockPixels(GetGWorldPixMap(world));		if not m then			internal_Qerr('Couldn''t lock src pixels', true);		CopyMask(GrafPtr(world)^.portBits, GrafPtr(world)^.portBits, GrafPtr(window)^.portBits, r1, rmask, r2);		UnlockPixels(GetGWorldPixMap(world));	end;	procedure CopyBitMapToOffscreen (biting: BitMap;									world: GWorldPtr;									r: rect);		var			clr: RGBColor;			m: Boolean;	begin		m := LockPixels(world^.portPixMap);		CopyBits(biting, GrafPtr(world)^.portBits, biting.bounds, r, srcCopy, nil);		UnlockPixels(world^.portPixMap);	end;	procedure CopyOffscreenToBitMap (world: GWorldPtr;									biting: BitMap;									r: rect);		var			clr: RGBColor;			m: Boolean;	begin		m := LockPixels(world^.portPixMap);		CopyBits(GrafPtr(world)^.portBits, biting, r, biting.bounds, srcCopy, nil);		UnlockPixels(world^.portPixMap);	end;	procedure CopyOffToOffRect (w1: GWorldPtr;									l1: boolean;									w2: GWorldPtr;									l2: boolean;									r1, r2: rect);		var			m: boolean;	begin		if (l1) then			m := LockPixels(w1^.portPixMap);		if (l2) then			m := LockPixels(w2^.portPixMap);		CopyBits(GrafPtr(w1)^.portBits, GrafPtr(w2)^.portBits, r1, r2, srcCopy, nil);		if (l1) then			UnlockPixels(w1^.portPixMap);		if (l2) then			UnlockPixels(w2^.portPixMap);	end;end.
unit QStringInts;{4.0}{This unit deals with numbers and strings, containing misc. functions/procedures}{for converting/drawing/modifying them.}{also contains the delay procedure}interfaceuses PascalSucks;	function Q_IntToStr (anInteger: integer; leadingZeros: boolean): str255;	function Q_StrToInt (theS: str255): integer;{	function Q_RealToStr (aReal: real): Str255;}{	function Q_StrToReal (theS: Str255): real;}	procedure Q_DrawInteger (anInteger: integer; leadingZeros: boolean);	function Q_PowerOf (base, expo: integer): integer;implementation{	function Q_RealToStr (aReal: real): Str255;		var			decimalPos: integer;			isNeg: boolean;			where: integer;			tempString: Str255;			stringClear: integer;			didIt: boolean;	begin		isNeg := (aReal < 0);		decimalPos := 0;		if isNeg then			aReal := -aReal;		while aReal >= 1 do			begin				aReal := aReal / 10;				decimalPos := decimalPos + 1;			end;		where := 1;		didIt := false;		while (trunc(aReal) <> aReal) and (where < 10) do			begin				if (where = decimalPos + 1) or ((decimalPos = 0) and not didIt) then					begin						tempString := concat(tempString, '.');						where := where + 1;						didIt := true;					end;				aReal := aReal * 10;				tempString := concat(tempString, char(trunc(aReal) + 48));				aReal := aReal - trunc(aReal);				where := where + 1;			end;		if tempString[where - 1] = '.' then			where := where - 1;		if isNeg then			begin				tempString := concat('-', tempString);				where := where + 1;			end;		for stringClear := where to 255 do			tempString[stringClear] := ' ';		Q_RealToStr := tempString;	end;}	{function Q_StrToReal (theS: Str255): real;		var			decimalPart, digitPart, noDecimal: Str255;			decimalPos: integer;			tempReal: real;			powerOfTen: real;			start: integer;			makeReal: integer;			accuracyZeros: integer;	begin		decimalPos := pos('.', theS);		if decimalPos = 0 then			Q_StrToReal := Q_StrToInt(theS)		else			begin				if decimalPos = 1 then					begin						theS := concat('0', theS);						decimalPos := decimalPos + 1;					end;				decimalPart := omit(theS, 1, decimalPos);				for accuracyZeros := 1 to 10 do					decimalPart := concat(decimalPart, '0');				digitPart := omit(theS, decimalPos, length(theS) - decimalPos + 1);				noDecimal := Concat(digitPart, decimalPart);				tempReal := 0;				powerOfTen := Q_PowerOf(10, length(digitPart) - 1);				if theS[1] = '-' then					start := 2				else					start := 1;				for makeReal := start to length(noDecimal) + start do					begin						tempReal := tempReal + (powerOfTen * (ord(noDecimal[makeReal]) - 48));						powerOfTen := powerOfTen / 10;					end;				if start = 2 then					tempReal := -tempReal;				Q_StrToReal := tempReal;			end;	end;}	function Q_StrToInt (theS: str255): integer;		var			count: integer;			tempInt: integer;			ml: integer;			start: integer;	begin		ml := length(theS);		if ml > 5 then			ml := 5;		Q_StrToInt := 0;		tempInt := 0;		if theS[1] = '-' then			start := 2		else			start := 1;		for count := start to ml do			begin				if theS[count] <> ' ' then					begin						tempInt := tempInt * 10;						tempInt := tempInt + (ord(theS[count]) - 48);					end;			end;		if theS[1] = '-' then			tempInt := -tempInt;		Q_StrToInt := tempInt;	end;	function Q_IntToStr (anInteger: integer; leadingZeros: boolean): str255;		var			ones, tens, hundreds, thousands, tenthousands: char;			result: integer;			where: integer;			alReady: boolean;			soi: str255;	begin		soi := '     ';		if abs(anInteger) > 9999 then			tenThousands := char((abs(anInteger) div 10000) + 48)		else			tenThousands := '0';		result := abs(anInteger) mod 10000;		if abs(anInteger) > 999 then			thousands := char((result div 1000) + 48)		else			thousands := '0';		result := result mod 1000;		if abs(anInteger) > 99 then			hundreds := char((result div 100) + 48)		else			hundreds := '0';		result := result mod 100;		if abs(anInteger) > 9 then			tens := char((result div 10) + 48)		else			tens := '0';		ones := char((result mod 10) + 48);		alReady := false;		where := 1;		if anInteger < 0 then			begin				soi[where] := '-';				where := where + 1;			end;		if ((not leadingZeros) and (tenThousands <> '0')) or (leadingZeros) then			begin				soi[where] := tenThousands;				where := where + 1;				alReady := true;			end;		if ((not leadingZeros) and (thousands <> '0')) or (leadingZeros) or alReady then			begin				soi[where] := thousands;				where := where + 1;				alReady := true;			end;		if ((not leadingZeros) and (hundreds <> '0')) or (leadingZeros) or alReady then			begin				soi[where] := hundreds;				where := where + 1;				alReady := true;			end;		if ((not leadingZeros) and (tens <> '0')) or (leadingZeros) or alReady then			begin				soi[where] := tens;				where := where + 1;			end;		soi[where] := ones;		Q_IntToStr := soi;	end;	procedure Q_DrawInteger (anInteger: integer; leadingZeros: boolean);		var			ones, tens, hundreds, thousands, tenthousands, result: integer;			alReady: boolean;	begin		if anInteger > 9999 then			tenThousands := anInteger div 10000		else			tenThousands := 0;		result := anInteger mod 10000;		if anInteger > 999 then			thousands := result div 1000		else			thousands := 0;		result := result mod 1000;		if anInteger > 99 then			hundreds := result div 100		else			hundreds := 0;		result := result mod 100;		if anInteger > 9 then			tens := result div 10		else			tens := 0;		ones := result mod 10;		alReady := false;		if ((not leadingZeros) and (tenThousands <> 0)) or (leadingZeros) then			begin				drawChar(chr(tenthousands + 48));				alReady := true;			end;		if ((not leadingZeros) and (thousands <> 0)) or (leadingZeros) or alReady then			begin				drawChar(chr(thousands + 48));				alReady := true;			end;		if ((not leadingZeros) and (hundreds <> 0)) or (leadingZeros) or alReady then			begin				drawChar(chr(hundreds + 48));				alReady := true;			end;		if ((not leadingZeros) and (tens <> 0)) or (leadingZeros) or alReady then			drawChar(chr(tens + 48));		drawChar(chr(ones + 48));	end;	function Q_PowerOf (base, expo: integer): integer;		var			count, tempInt: integer;	begin		tempInt := 1;		for count := 1 to expo do			tempInt := tempInt * base;		Q_PowerOf := tempInt;	end;end.
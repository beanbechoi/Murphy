unit MRLevelUnit;{Murphy's Revenge Level Unit}{©1997 Dave Peck, All Rights Reserved.}interface	uses		stacks, QStringInts, QDOffscreen, QOffscreen, QuickDrawProcs;	const{fudge factor for window sizes}		kFudge = 15;{pict ID for level gfx}		pLevel = 132;{window ID for level }		wLevel = 131;{restype for a level}		kLevelResType = 'MRlv';{120 * 16 = 1920}{1920/480 = 4 screens in any direction. cool.}		kMaxLevelSize = 120;{involving the actual grid of 16x16 images}		klevelItemSize = 32;{if the grid is visible, probably = 1}		klevelItemStart = 0;		klevelItemSeparation = 0;{Cursor IDs}		cPencil = 128;		cSelect = 129;		cFill = 130;		cWatch = 131;	{-138}		cWatchMax = 138;		cEyeDrop = 139;		cOpenHand = 999;		cClosedHand = 1000;		cArrow = -1;		cInspect = 141;		cToggle = 142;{tools}		kPencil = cPencil;		kFill = cFill;		kSelect = cSelect;		kEyedrop = cEyedrop;	type		LevelPoint = record				p: Point; 					{The actual Icon}				userData: integer;	{Special info about this point}			end;		LevelArray = array[1..kMaxLevelSize, 1..kMaxLevelSize] of LevelPoint;		LevelArrayPtr = ^LevelArray;{tag to attach to the window}		MRWinTagStruct = record				winTitle: str255;				winDirty: boolean;				winlevel: MRlevelInfo;				drawOffscreen: boolean;				pathOff: GlevelPtr;				backOff: GlevelPtr;				levelOff: GlevelPtr;				vScroll, hScroll: ControlHandle;				iconsAcross, iconsDown: integer;				drawIcon: Point;				palUpdate: boolean;{the following stuff is for selections}				haveSelection: Boolean;				selectionRect: Rect;				origSelRect: Rect;				copylevel: levelArrayPtr;			end;		MRWinTag = ^MRWinTagStruct;	var{this i moved from the mainline to this unit, only because}{I really really need it and besides everything but this one}{unit is hacked up anyways.}		gCurTool: integer;		gToolSave: integer;{cursor state}		gLastCursor: integer;		gCurrentCurs: CursHandle;{resource file to save data to}		gListRes: integer;	function MakelevelWindow (levelTitle: str255): WindowPtr;	function LoadlevelWindow (levelTitle: str255): WindowPtr;	procedure CloselevelWindow (var levelWind: WindowPtr);	procedure MouseOverlevelWindow (levelWind: WindowPtr;									where: point;									mods: integer);	procedure levelWindowClick (levelWind: WindowPtr;									where: point;									mods: integer);	procedure Savelevel (levelWind: WindowPtr);	procedure DrawLevel (levelWind: WindowPtr);	procedure Resizelevel (levelWind: WindowPtr);	procedure levelActivate (levelWind: WindowPtr;									active: Boolean);	procedure SetDrawIcon (levelWind: WindowPtr;									drawIcon: Point);	procedure DrawCurrentMapIcon (levelWind: WindowPtr;									drawRect: Rect);	procedure SelectlevelIcon (levelWind: WindowPtr);	function levelPaletteUpdate (levelWind: WindowPtr): Boolean;	procedure ZerolevelSelection (levelWind: WindowPtr);	procedure levelKey (levelWind: WindowPtr;									theKey: char);	procedure levelPaste (levelWind: WindowPtr);	function levelEditHilites (levelWind: WindowPtr): Boolean;implementation	procedure level_DrawPicInOff (picID: integer;									level: GlevelPtr);		var			locked: Boolean;			oldGW: GlevelPtr;			oldGD: GDHandle;	begin		GetGlevel(oldGW, oldGD);		SetGlevel(level, nil);		locked := LockPixels(level^.portPixMap);		DrawPicLoc(pLevel, 0, 0);		UnlockPixels(level^.portPixMap);		SetGlevel(oldGW, oldGD);	end;	procedure level_EraseOff (level: GlevelPtr);		var			locked: Boolean;			oldGW: GlevelPtr;			oldGD: GDHandle;	begin		GetGlevel(oldGW, oldGD);		SetGlevel(level, nil);		locked := LockPixels(level^.portPixMap);		EraseRect(level^.portPixMap^^.bounds);		UnlockPixels(level^.portPixMap);		SetGlevel(oldGW, oldGD);	end;	procedure level_DrawSingleIcon (pathOff: GlevelPtr;									levelOff: GlevelPtr;									rectTo: Rect;									pointFrom: Point);		var			rectFrom: Rect;	begin{    pointFrom.h := pointFrom.h + 3;}{calc from rect}		SetRect(rectFrom, (pointFrom.h * (klevelItemSize + klevelItemSeparation)) + klevelItemStart, (pointFrom.v * (klevelItemSize + klevelItemSeparation)) + klevelItemStart, 0, 0);		rectFrom.bottom := rectFrom.top + klevelItemSize;		rectFrom.right := rectFrom.left + klevelItemSize;{copy}		CopyOffToOffRect(pathOff, true, levelOff, false, rectFrom, rectTo);	end;	procedure level_DrawSingleIconAt (pathOff: GlevelPtr;									levelOff: GlevelPtr;									tag: MRWinTag;									atPt: Point;									fromPoint: Point);		var			rectTo: rect;			topH, topV: integer;	begin{atPoint is a point of the grid}{figure out some infos}		topH := GetCtlValue(tag^.hScroll);		topV := GetCtlValue(tag^.vScroll);		atPt.h := atPt.h - topH;		atPt.v := atPt.v - topV;{figure out the draw-to-rect}		SetRect(rectTo, atPt.h * klevelItemSize, atPt.v * klevelItemSize, 0, 0);		rectTo.bottom := rectTo.top + klevelItemSize;		rectTo.right := rectTo.left + klevelItemSize;{draw it!}		level_DrawSingleIcon(pathOff, levelOff, rectTo, fromPoint);	end;	procedure level_RevealSingleIcon (levelWind: WindowPtr;									loc: Point);		var			tag: MRWinTag;			rectTo: rect;			topH, topV: integer;	begin{get tag}		tag := MRWinTag(GetWRefCon(levelWind));{figure out some infos}		topH := GetCtlValue(tag^.hScroll);		topV := GetCtlValue(tag^.vScroll);		loc.h := loc.h - topH;		loc.v := loc.v - topV;{calc rect}		SetRect(rectTo, loc.h * klevelItemSize, loc.v * klevelItemSize, 0, 0);		rectTo.bottom := rectTo.top + klevelItemSize;		rectTo.right := rectTo.left + klevelItemSize;{draw it!}		CopyOffToOffRect(tag^.levelOff, true, GlevelPtr(levelWind), false, rectTo, rectTo);	end;	procedure level_SetGridIcon (tag: MRWinTag;									loc: Point;									whichIcon: Point);	begin		tag^.winlevel^.thelevel^[loc.h, loc.v].p := whichIcon;		if (whichIcon.v < 4) then			begin				if (whichIcon.h = 3) then					tag^.winlevel^.thelevel^[loc.h, loc.v].kind := 2				else if (whichIcon.h > 5) then					tag^.winlevel^.thelevel^[loc.h, loc.v].kind := 1;			end		else			tag^.winlevel^.thelevel^[loc.h, loc.v].kind := 0;	end;	function level_PointFromMouse (levelWind: WindowPtr;									where: Point): point;		var			tag: MRWinTag;			p: Point;	begin{setup}		tag := MRWinTag(GetWRefCon(levelWind));{calc sizes}		p.h := GetCtlValue(tag^.hScroll);		p.v := GetCtlValue(tag^.vScroll);{calculate actual point}		p.h := p.h + (where.h div klevelItemSize);		p.v := p.v + (where.v div klevelItemSize);{return it}		level_PointFromMouse := p;	end;	function level_MakelevelInfo: MRlevelInfo;		var			newLevel: MRlevelInfo;	begin		newLevel := MRlevelInfo(NewPtrClear(sizeof(MRlevelInfoStruct)));{and now the actual level itself}		newLevel^.thelevel := levelArrayPtr(NewPtrClear(sizeof(levelArray)));{return it}		level_MakelevelInfo := newLevel;	end;	procedure level_DestroylevelInfo (var info: MRlevelInfo);	begin		DisposePtr(Ptr(info^.thelevel));		DisposePtr(Ptr(info));	end;	function level_MakeWinTag (newWind: WindowPtr;									levelTitle: Str255): MRWinTag;		var			newTag: MRWinTag;			picRect: rect;			winRect: rect;	begin{ make the tag }		newTag := MRWinTag(NewPtrClear(sizeof(MRWinTagStruct)));		newTag^.winTitle := copy(levelTitle, 1, length(levelTitle));		newTag^.winDirty := false;{ always draw the offscreen }{ also, always bet on black. }		newTag^.drawOffscreen := true;{make the path icons offscreen}		picRect := GetPRect(pLevel);		newTag^.pathOff := MakeGlevelDepth(picRect, 8);		level_DrawPicInOff(pLevel, newTag^.pathOff);{make the window offscreen at the size of the window}		winRect := newWind^.portRect;		OffsetRect(winRect, -winRect.left, -winRect.top);		winRect.right := winRect.right - kFudge;		winRect.bottom := winRect.bottom - kFudge;		newTag^.levelOff := MakeGlevelDepth(winRect, 8);		level_EraseOff(newTag^.levelOff);{calculate icons across and down}		newTag^.iconsAcross := ((winRect.right - kFudge) div klevelItemSize);		newTag^.iconsDown := ((winRect.bottom - kFudge) div klevelItemSize);{return the tag}		level_MakeWinTag := newTag;	end;	procedure level_DestroyWinTag (var tag: MRWinTag);	begin		DestroyGlevel(tag^.pathOff);		DestroyGlevel(tag^.backOff);		DestroyGlevel(tag^.levelOff);		DisposeControl(tag^.vScroll);		DisposeControl(tag^.hScroll);		DisposePtr(Ptr(tag));	end;	procedure level_MakeScrollInfo (wind: WindowPtr;									tag: MRWinTag);		const			kScrollbarWidth = 16;			kScrollBarAdjust = kScrollBarWidth - 1;			kScrollBarTweek = 2;		var			pr: Rect;	begin{create the vScroll and hScroll and size 'em correctly.}		tag^.vScroll := GetNewControl(128, wind);		tag^.hScroll := GetNewControl(128, wind);{set params for the controls}		SetCtlMin(tag^.vScroll, 1);		SetCtlMax(tag^.vScroll, kMaxLevelSize - tag^.iconsDown);		SetCtlValue(tag^.vScroll, 1);		SetCtlMin(tag^.hScroll, 1);		SetCtlMax(tag^.hScroll, kMaxLevelSize - tag^.iconsAcross);		SetCtlValue(tag^.hScroll, 1);{get the window's portRect}		pr := wind^.portRect;		OffsetRect(pr, -pr.left, -pr.top);{position the controls}		MoveControl(tag^.vScroll, pr.right - kScrollbarAdjust, -1);		SizeControl(tag^.vScroll, kScrollBarWidth, (pr.bottom - pr.top) - (kScrollBarAdjust - kScrollBarTweek));		MoveControl(tag^.hScroll, -1, pr.bottom - kScrollBarAdjust);		SizeControl(tag^.hScroll, (pr.right - pr.left) - (kScrollBarAdjust - kScrollBarTweek), kScrollBarWidth);{display the controls}		ShowControl(tag^.vScroll);		ShowControl(tag^.hScroll);	end;	procedure level_DrawFullOffscreen (tag: MRWinTag);		var			drawIcons: Rect;			singleDraw: Rect;			atH, atV: integer;			oldGW: GlevelPtr;			oldGD: GDHandle;			locked: Boolean;	begin		tag^.drawOffscreen := false;{get the virtual rect to draw into.}		drawIcons.top := GetCtlValue(tag^.vScroll);		drawIcons.left := GetCtlValue(tag^.hScroll);		drawIcons.bottom := drawIcons.top + tag^.iconsDown;		drawIcons.right := drawIcons.left + tag^.iconsAcross;{single draw rect is perty}		SetRect(singleDraw, 0, 0, klevelItemSize, klevelItemSize);{ get ready to draw }		atH := drawIcons.left;		atV := drawIcons.top;		GetGlevel(oldGW, oldGD);		SetGlevel(tag^.levelOff, nil);		locked := LockPixels(tag^.levelOff^.portPixMap);{draw the whole derned thing}		while (atH <= drawIcons.right) do			begin				while (atV <= drawIcons.bottom) do					begin						level_DrawSingleIcon(tag^.pathOff, tag^.levelOff, singleDraw, tag^.winlevel^.thelevel^[atH, atV].p);						OffsetRect(singleDraw, 0, klevelItemSize);						atV := atV + 1;					end;				atV := drawIcons.top;				atH := atH + 1;				singleDraw.top := 0;				singleDraw.bottom := klevelItemSize;				OffsetRect(singleDraw, klevelItemSize, 0);			end;{and release}		UnlockPixels(tag^.levelOff^.portPixMap);		SetGlevel(oldGW, oldGD);	end;	procedure level_CtlBounds (control: ControlHandle);		var			cVal: integer;	begin		cVal := GetCtlValue(control);		if (cVal < GetCtlMin(control)) then			SetCtlValue(control, GetCtlMin(control))		else if (cVal > GetCtlMax(control)) then			SetCtlValue(control, GetCtlMax(control));	end;	procedure level_DrawHStrip (tag: MRWinTag;									vertValue: integer;									topLeftPt: Point);		var			atH, atV: integer;			maxH: integer;			singleRect: Rect;			p: Point;			locked: Boolean;			oldGW: GlevelPtr;			oldGD: GDHandle;	begin{prepare}		atH := GetCtlValue(tag^.hScroll);		atV := vertValue;		maxH := atH + tag^.iconsAcross;		SetRect(singleRect, 0, 0, klevelItemSize, klevelItemSize);		OffsetRect(singleRect, topLeftPt.h, topLeftPt.v);		GetGlevel(oldGW, oldGD);		SetGlevel(tag^.levelOff, nil);		locked := LockPixels(tag^.levelOff^.portPixMap);{draw}		while (atH <= maxH) do			begin				p := tag^.winlevel^.thelevel^[atH, atV].p;				level_DrawSingleIcon(tag^.pathOff, tag^.levelOff, singleRect, p);				OffsetRect(singleRect, klevelItemSize, 0);				atH := atH + 1;			end;		UnlockPixels(tag^.levelOff^.portPixMap);		SetGlevel(oldGW, oldGD);	end;	procedure level_DrawVStrip (tag: MRWinTag;									horizValue: integer;									topLeftPt: Point);		var			atH, atV: integer;			maxV: integer;			singleRect: Rect;			p: Point;			locked: Boolean;			oldGW: GlevelPtr;			oldGD: GDHandle;	begin{prepare}		atV := GetCtlValue(tag^.vScroll);		atH := horizValue;		maxV := atV + tag^.iconsDown;		SetRect(singleRect, 0, 0, klevelItemSize, klevelItemSize);		OffsetRect(singleRect, topLeftPt.h, topLeftPt.v);		GetGlevel(oldGW, oldGD);		SetGlevel(tag^.levelOff, nil);		locked := LockPixels(tag^.levelOff^.portPixMap);{draw}		while (atV <= maxV) do			begin				p := tag^.winlevel^.thelevel^[atH, atV].p;{    ForeColor(redColor);}{    InsetRect(singleRect, -1, -1);}{    FillRect(singleRect, black);}{    InsetRect(singleRect, 1, 1);}{    ForeColor(blackColor);}				level_DrawSingleIcon(tag^.pathOff, tag^.levelOff, singleRect, p);				OffsetRect(singleRect, 0, klevelItemSize);				atV := atV + 1;			end;		UnlockPixels(tag^.levelOff^.portPixMap);		SetGlevel(oldGW, oldGD);	end;	procedure level_VertAction (control: ControlHandle;									part: Integer);		var			levelWind: WindowPtr;			tag: MRWinTag;			cValue: integer;			fromRect, toRect: rect;			pr: rect;			drawPoint: Point;	begin		if (part <> 0) then			begin				levelWind := control^^.contrlOwner;				tag := MRWinTag(GetWRefCon(levelWind));				cValue := GetCtlValue(control);				pr := levelWind^.portRect;				OffsetRect(pr, -pr.left, -pr.top);				pr.right := pr.right - klevelItemSize;				pr.bottom := pr.bottom - klevelItemSize;				case part of					inUpButton: 						begin{move the box}							SetCtlValue(control, cValue - 1);							level_CtlBounds(control);{draw the change, but only if necessary.}							if (cValue - 1 > 0) then								begin									SetRect(fromRect, pr.left, pr.top, pr.right + 1, pr.bottom - klevelItemSize + 1);									SetRect(toRect, pr.left, pr.top + klevelItemSize, pr.right + 1, pr.bottom + 1);									CopyOffToOffRect(tag^.levelOff, true, tag^.levelOff, false, fromRect, toRect);									drawPoint.h := 0;									drawPoint.v := 0;									level_DrawHStrip(tag, cValue - 1, drawPoint);									DrawLevel(levelWind);								end;						end;					inDownButton: 						begin{move the box}							SetCtlValue(control, cValue + 1);							level_CtlBounds(control);{draw the change, but only if necessary.}							if (cValue + 1 <= GetCtlMax(control)) then								begin									SetRect(fromRect, pr.left, pr.top + klevelItemSize, pr.right + 1, pr.bottom + 1);									SetRect(toRect, pr.left, pr.top, pr.right + 1, pr.bottom - klevelItemSize + 1);									CopyOffToOffRect(tag^.levelOff, true, tag^.levelOff, false, fromRect, toRect);									drawPoint.h := fromRect.left;									drawPoint.v := toRect.bottom;									level_DrawHStrip(tag, cValue + tag^.iconsDown, drawPoint);									DrawLevel(levelWind);								end;						end;					inPageUp, inPageDown: 						begin{move it:}							if (part = inPageUp) then								SetCtlValue(control, cValue - tag^.iconsDown + 1)							else								SetCtlValue(control, cValue + tag^.iconsDown - 1);							level_CtlBounds(control);{ the window's top has been changed: }							tag^.drawOffscreen := true;							DrawLevel(levelWind);						end;				end;			end;	end;	procedure level_HorizAction (control: ControlHandle;									part: Integer);		var			levelWind: WindowPtr;			tag: MRWinTag;			cValue: integer;			fromRect, toRect: rect;			pr: rect;			drawPoint: Point;	begin		if (part <> 0) then			begin				levelWind := control^^.contrlOwner;				tag := MRWinTag(GetWRefCon(levelWind));				cValue := GetCtlValue(control);				pr := levelWind^.portRect;				OffsetRect(pr, -pr.left, -pr.top);				pr.right := pr.right - klevelItemSize;				pr.bottom := pr.bottom - klevelItemSize;				case part of					inUpButton: 						begin{move the box}							SetCtlValue(control, cValue - 1);							level_CtlBounds(control);{draw the change, but only if necessary.}							if (cValue - 1 > 0) then								begin									SetRect(fromRect, pr.left, pr.top, pr.right - klevelItemSize + 1, pr.bottom + 1);									SetRect(toRect, pr.left + klevelItemSize, pr.top, pr.right + 1, pr.bottom + 1);									CopyOffToOffRect(tag^.levelOff, true, tag^.levelOff, false, fromRect, toRect);									drawPoint.h := 0;									drawPoint.v := 0;									level_DrawVStrip(tag, cValue - 1, drawPoint);									DrawLevel(levelWind);								end;						end;					inDownButton: 						begin{move the box}							SetCtlValue(control, cValue + 1);							level_CtlBounds(control);{draw the change, but only if necessary.}							if (cValue + 1 <= GetCtlMax(control)) then								begin									SetRect(fromRect, pr.left + klevelItemSize, pr.top, pr.right + 1, pr.bottom + 1);									SetRect(toRect, pr.left, pr.top, pr.right - klevelItemSize + 1, pr.bottom + 1);									CopyOffToOffRect(tag^.levelOff, true, tag^.levelOff, false, fromRect, toRect);									drawPoint.h := toRect.right;									drawPoint.v := fromRect.top;									level_DrawVStrip(tag, cValue + tag^.iconsAcross, drawPoint);									DrawLevel(levelWind);								end;						end;					inPageUp, inPageDown: 						begin{move it:}							if (part = inPageUp) then								SetCtlValue(control, cValue - tag^.iconsAcross + 1)							else								SetCtlValue(control, cValue + tag^.iconsAcross - 1);							level_CtlBounds(control);{ the window's top has been changed: }							tag^.drawOffscreen := true;							DrawLevel(levelWind);						end;				end;			end;	end;	procedure level_Warning (warnString: Str255);		var			warnDlog: DialogPtr;			itemHit: integer;	begin		InitCursor;		ParamText(warnString, '', '', '');		warnDlog := GetNewDialog(131, nil, WindowPtr(-1));		ShowWindow(warnDlog);		SysBeep(5);		repeat			ModalDialog(nil, itemHit);		until itemHit = 1;		DisposeDialog(warnDlog);		SetCursor(gCurrentCurs^^);	end;	function level_ChoiceWarning (warnString: Str255): Boolean;		var			warnDlog: DialogPtr;			itemHit: integer;	begin		InitCursor;		ParamText(warnString, '', '', '');		warnDlog := GetNewDialog(2000, nil, WindowPtr(-1));		ShowWindow(warnDlog);		SysBeep(5);		repeat			ModalDialog(nil, itemHit);		until itemHit <= 2;		DisposeDialog(warnDlog);		SetCursor(gCurrentCurs^^);		level_ChoiceWarning := (itemHit = 1);	end;	function level_SelRectInWindow (tag: MRWinTag): Rect;		var			r, r2: rect;	begin		r := tag^.selectionRect;		OffsetRect(r, -GetCtlValue(tag^.hScroll), -GetCtlValue(tag^.vScroll));		SetRect(r2, r.left * klevelItemSize, r.top * klevelItemSize, r.right * klevelItemSize, r.bottom * klevelItemSize);		level_SelRectInWindow := r2;	end;	procedure level_PieceInspDlog (levelWind: WindowPtr;									tag: MRWinTag;									loc: Point;									iconToDraw: Point);		var			inspDlog: DialogPtr;			itemHit: integer;			itemType: integer;			itemBounds: Rect;			item: Handle;			typedText: Str255;			typedInt: integer;	begin{set the cursor up for a dialog}		InitCursor;{put the dlog on screen}		inspDlog := GetNewDialog(1002, nil, WindowPtr(-1));		ShowWindow(inspDlog);{set the edit text to the appropriate value}		GetDItem(inspDlog, 2, itemType, item, itemBounds);		SetIText(item, stringof(tag^.winlevel^.thelevel^[loc.h, loc.v].trig : 1));{select the text for easy editing}		SelIText(inspDlog, 2, 0, 32767);{draw the icon, only make it big}		SetRect(itemBounds, 20, 10, 20 + 32, 10 + 32);		level_DrawSingleIcon(tag^.pathOff, GlevelPtr(inspDlog), itemBounds, iconToDraw);{handle the actual dialog}		repeat			ModalDialog(nil, itemHit);		until (itemHit = 1);{get the new value they typed in}		GetDItem(inspDlog, 2, itemType, item, itemBounds);		GetIText(item, typedText);		typedInt := Q_StrToInt(typedText);{now set the value appropriately}		tag^.winlevel^.thelevel^[loc.h, loc.v].trig := typedInt;{get rid of the dialog}		DisposeDialog(inspDlog);{reset the cursor}		SetCursor(gCurrentCurs^^);	end;	procedure level_LevelInspDlog (levelWind: WindowPtr;									tag: MRWinTag;									loc: Point;									iconToDraw: Point);		var			inspDlog: DialogPtr;			itemHit: integer;			itemType: integer;			itemBounds: Rect;			item: Handle;			typedText: Str255;			typedInt: integer;	begin{this routine is very similar to the piece insp, only it changes different things.}{set the cursor up for a dialog}		InitCursor;{put the dlog on screen}		inspDlog := GetNewDialog(1001, nil, WindowPtr(-1));		ShowWindow(inspDlog);{set the edit text to the appropriate value}		GetDItem(inspDlog, 2, itemType, item, itemBounds);		SetIText(item, stringof(tag^.winlevel^.thelevel^[loc.h, loc.v].levelID : 1));{select the text for easy editing}		SelIText(inspDlog, 2, 0, 32767);{handle the actual dialog}		repeat			ModalDialog(nil, itemHit);		until (itemHit = 1);{get the new value they typed in}		GetDItem(inspDlog, 2, itemType, item, itemBounds);		GetIText(item, typedText);		typedInt := Q_StrToInt(typedText);{now set the value appropriately}		tag^.winlevel^.thelevel^[loc.h, loc.v].levelID := typedInt;{get rid of the dialog}		DisposeDialog(inspDlog);{reset the cursor}		SetCursor(gCurrentCurs^^);	end;	procedure level_MultiInspDlog (levelWind: WindowPtr;									tag: MRWinTag);		var			inspDlog: DialogPtr;			itemHit: integer;			itemType: integer;			itemBounds: Rect;			item: Handle;			typedText: Str255;			typedInt: integer;			h, v: integer;	begin{this routine is very similar to the piece insp, only it changes different things.}{set the cursor up for a dialog}		InitCursor;{put the dlog on screen}		inspDlog := GetNewDialog(1003, nil, WindowPtr(-1));		ShowWindow(inspDlog);{set the edit text to the appropriate value}		GetDItem(inspDlog, 2, itemType, item, itemBounds);		SetIText(item, stringof(0 : 1));{select the text for easy editing}		SelIText(inspDlog, 2, 0, 32767);{handle the actual dialog}		repeat			ModalDialog(nil, itemHit);		until (itemHit = 1);{get the new value they typed in}		GetDItem(inspDlog, 2, itemType, item, itemBounds);		GetIText(item, typedText);		typedInt := Q_StrToInt(typedText);{now set the value appropriately}		for h := tag^.selectionRect.left to (tag^.selectionRect.right - 1) do			for v := tag^.selectionRect.top to (tag^.selectionRect.bottom - 1) do				tag^.winlevel^.thelevel^[h, v].trig := typedInt;{get rid of the dialog}		DisposeDialog(inspDlog);{reset the cursor}		SetCursor(gCurrentCurs^^);	end;	procedure level_SwitchInspDlog (levelWind: WindowPtr;									tag: MRWinTag;									loc: Point;									iconToDraw: Point);		var			inspDlog: DialogPtr;			itemHit: integer;			itemType: integer;			itemBounds: Rect;			item: Handle;			typedText: Str255;			typedInt: integer;			mapTrig: boolean;			trigP: Point;	begin{this routine is very similar to the piece insp, only it changes different things.}{set the cursor up for a dialog}		InitCursor;{put the dlog on screen}		inspDlog := GetNewDialog(1000, nil, WindowPtr(-1));		ShowWindow(inspDlog);{set the edit text to the appropriate value}		GetDItem(inspDlog, 2, itemType, item, itemBounds);		SetIText(item, stringof(tag^.winlevel^.thelevel^[loc.h, loc.v].trig : 1));{select the text for easy editing}		SelIText(inspDlog, 2, 0, 32767);{figure out what kind of trigger it is}		if (tag^.winlevel^.thelevel^[loc.h, loc.v].state = 0) then			trigP := tag^.winlevel^.thelevel^[loc.h, loc.v].trigP		else			trigP := tag^.winlevel^.thelevel^[loc.h, loc.v].p;		mapTrig := ((trigP.h = 0) and (trigP.v = 0)) or (trigP.h = 7);		trigP.v := iconToDraw.v;{set the correct control}		if (mapTrig) then			GetDItem(inspDlog, 3, itemType, item, itemBounds)		else			GetDItem(inspDlog, 4, itemType, item, itemBounds);		SetCtlValue(ControlHandle(item), 255);{handle the actual dialog}		repeat			ModalDialog(nil, itemHit);			if (itemHit = 3) or (itemHit = 4) then				begin{the map radio button, the abstract radio button}					GetDItem(inspDlog, 3, itemType, item, itemBounds);					SetCtlValue(ControlHandle(item), 0);					GetDItem(inspDlog, 4, itemType, item, itemBounds);					SetCtlValue(ControlHandle(item), 0);					GetDItem(inspDlog, itemHit, itemType, item, itemBounds);					SetCtlValue(ControlHandle(item), 255);					mapTrig := (itemHit = 3);				end;		until (itemHit = 1);{set the trigP icon, if necessary}		if (mapTrig) then			trigP.h := 7		else			trigP.h := 8;{store the trigger data}		if (tag^.winlevel^.thelevel^[loc.h, loc.v].state = 0) then			tag^.winlevel^.thelevel^[loc.h, loc.v].trigP := trigP		else			tag^.winlevel^.thelevel^[loc.h, loc.v].p := trigP;{get the new value they typed in}		GetDItem(inspDlog, 2, itemType, item, itemBounds);		GetIText(item, typedText);		typedInt := Q_StrToInt(typedText);{now set the value appropriately}		tag^.winlevel^.thelevel^[loc.h, loc.v].trig := typedInt;{get rid of the dialog}		DisposeDialog(inspDlog);{redraw the level}		tag^.drawOffscreen := true;		DrawLevel(levelWind);{reset the cursor}		SetCursor(gCurrentCurs^^);	end;	procedure level_ToggleAllTrig (levelWind: WindowPtr;									tag: MRWinTag;									trigVal: integer);		var			x, y: integer;			tempPt: Point;			thelevel: levelArrayPtr;	begin{for efficiency, grab the actual level}		thelevel := tag^.winlevel^.thelevel;		for x := 1 to kMaxLevelSize do			for y := 1 to kMaxLevelSize do				if (thelevel^[x, y].trig = trigVal) then					begin						tempPt := thelevel^[x, y].p;						thelevel^[x, y].p := thelevel^[x, y].trigP;						thelevel^[x, y].trigP := tempPt;						if (thelevel^[x, y].kind = 1) then							thelevel^[x, y].state := 1 - thelevel^[x, y].state;					end;	end;	procedure level_MultiInspect (levelWind: WindowPtr;									tag: MRWinTag);		function SelectionContainsDiamond (tag: MRWinTag): boolean;			var				h, v: integer;				hasDiamond: Boolean;				iconPt: Point;		begin			hasDiamond := false;			h := tag^.selectionRect.left;			v := tag^.selectionRect.top;			while (not hasDiamond) and (h < tag^.selectionRect.right) do				begin					while (not hasDiamond) and (v < tag^.selectionRect.bottom) do						begin							iconPt := tag^.winlevel^.thelevel^[h, v].p;							hasDiamond := ((iconPt.v < 4) and (iconPt.h > 5));							v := v + 1;						end;					v := tag^.selectionRect.top;					h := h + 1;				end;			SelectionContainsDiamond := hasDiamond;		end;		function SelectionContainsSwitchIDs (tag: MRWinTag): Boolean;			var				h, v: integer;				hasID: Boolean;		begin			hasID := false;			h := tag^.selectionRect.left;			v := tag^.selectionRect.top;			while (not hasID) and (h < tag^.selectionRect.right) do				begin					while (not hasID) and (v < tag^.selectionRect.bottom) do						begin							hasID := (tag^.winlevel^.thelevel^[h, v].trig > 0);							v := v + 1;						end;					v := tag^.selectionRect.top;					h := h + 1;				end;			SelectionContainsSwitchIDs := hasID;		end;		var			doIt: Boolean;	begin{multi-inspection works like this:}{first, check for diamonds. you can't switch 'em}		if (SelectionContainsDiamond(tag)) then			begin				level_Warning('You cannot multi-inspect a selection containing a diamond (switch). Sorry.');			end{next, check for previous switch IDs already set}		else			begin				doIt := true;				if (SelectionContainsSwitchIDs(tag)) then					doIt := level_ChoiceWarning('Multi-inspect will erase current switch IDs inside your selection. Proceed?');				if (doIt) then					level_MultiInspDlog(levelWind, tag);			end;	end;	procedure level_CopyArea (f, t: levelArrayPtr;									rf, rt: Rect);		var			h, v, h2, v2: integer;	begin{this routine is coded for maximum efficency, as if pascal does that kinda stuff.}		h2 := rt.left;		for h := rf.left to rf.right - 1 do			begin				v2 := rt.top;				for v := rf.top to rf.bottom - 1 do					begin						t^[h2, v2] := f^[h, v];						v2 := v2 + 1;					end;				h2 := h2 + 1;			end;	end;	procedure level_ContentClick (levelWind: WindowPtr;									where: point;									mods: integer);		const			kPencilThing = 1;			kFillThing = 2;			kSelectThing = 3;			kEyedropThing = 4;			kInspectThing = 5;			kToggleThing = 6;			kGrabSelectThing = 7;			kMultiInspectThing = 8;			kUnselectThing = 9;		var			tag: MRWinTag;			loc: Point;			iconToDraw: Point;			oldPort: GrafPtr;			pr: Rect;			thingToDo: integer;{for fills}			fillVal: Point;			x, y: integer;			newX, newY: integer;			myStack: stack;			trigVal: integer;{for shift-constrain}			rememberLoc: Point;			haveConstrain: Boolean;			constrainHoriz: Boolean;{for select}			curLoc: Point;			calcRect: Rect;			lastSelRect: Rect;			offsetPt: Point;	begin{remember where we parked!}		GetPort(oldPort);		SetPort(levelWind);{get the rect}		pr := levelWind^.portRect;		pr.right := pr.right - kFudge;		pr.bottom := pr.bottom - kFudge;{get the tag}		tag := MRWinTag(GetWRefCon(levelWind));{init the "thing"}		thingToDo := kPencilThing;{what "thing" do we want to do?}		if (BAND(mods, cmdKey) = cmdKey) and (not tag^.haveSelection) then			thingToDo := kToggleThing		else if (BAND(mods, optionKey) = optionKey) and (not tag^.haveSelection) then			thingToDo := kEyedropThing		else if (BAND(mods, controlKey) = controlKey) and (not tag^.haveSelection) then			thingToDo := kInspectThing		else			case gCurTool of				kPencil: 					thingToDo := kPencilThing;				kFill: 					thingToDo := kFillThing;				kSelect: 					if (tag^.haveSelection) then						begin							if (BAND(mods, controlKey) = controlKey) then								thingToDo := kMultiInspectThing							else if (gLastCursor = cArrow) then								thingToDo := kGrabSelectThing							else								thingToDo := kSelectThing;						end					else						thingToDo := kSelectThing;				kEyeDrop: 					thingToDo := kEyedropThing;			end;{do that particular "thing"}		case thingToDo of			kPencilThing: 				begin{repeat while mouse button is down}					rememberLoc := level_PointFromMouse(levelWind, where);					haveConstrain := false;					constrainHoriz := true;					repeat						if PtInRect(where, pr) then							begin								loc := level_PointFromMouse(levelWind, where);								if (BAND(mods, shiftKey) = shiftKey) then									begin{shift-constrain keeps drawing on a line.}										if (not haveConstrain) then											begin												if (loc.v <> rememberLoc.v) then													begin														constrainHoriz := false;														haveConstrain := true;														loc.h := rememberLoc.h;													end												else if (loc.h <> rememberLoc.h) then													begin														haveConstrain := true;														loc.v := rememberLoc.v;													end;											end										else if (constrainHoriz) then											loc.v := rememberLoc.v										else											loc.h := rememberLoc.h;									end;								iconToDraw := tag^.drawIcon;								level_DrawSingleIconAt(tag^.pathOff, tag^.levelOff, tag, loc, iconToDraw);								level_SetGridIcon(tag, loc, iconToDraw);								level_RevealSingleIcon(levelWind, loc);							end;						GetMouse(where);					until (not Button);				end;			kFillThing: 				begin					loc := level_PointFromMouse(levelWind, where);					x := loc.h;					y := loc.v;					myStack := newStack;					fillVal := tag^.winlevel^.thelevel^[x, y].p;					Push(myStack, x, y);					while not StackEmpty(myStack) do						begin							Pop(myStack, newX, newY);							if (EqualPt(tag^.winlevel^.thelevel^[newX, newY].p, fillVal)) then								begin									if (newX + 1 <= kMaxLevelSize) then										Push(myStack, newX + 1, newY);									if (newY + 1 <= kMaxLevelSize) then										Push(myStack, newX, newY + 1);									if (newX - 1 > 0) then										Push(myStack, newX - 1, newY);									if (newY - 1 > 0) then										Push(myStack, newX, newY - 1);									tag^.winlevel^.thelevel^[newX, newY].p := tag^.drawIcon;								end;						end;					KillStack(myStack);					tag^.drawOffscreen := true;					DrawLevel(levelWind);				end;			kSelectThing: 				begin					loc := level_PointFromMouse(levelWind, where);					tag^.haveSelection := true;					SetRect(lastSelRect, -1, -1, -1, -1);					pr := levelWind^.portRect;					pr.right := pr.right - kFudge;					pr.bottom := pr.bottom - kFudge;					if (tag^.copylevel <> nil) then						begin							DisposePtr(Ptr(tag^.copylevel));							tag^.copylevel := nil;						end;					while Button do						begin							GetMouse(where);							curLoc := level_PointFromMouse(levelWind, where);							if (loc.h < curLoc.h) then								begin									tag^.selectionRect.left := loc.h;									tag^.selectionRect.right := curLoc.h;								end							else								begin									tag^.selectionRect.right := loc.h;									tag^.selectionRect.left := curLoc.h;								end;							if (loc.v < curLoc.v) then								begin									tag^.selectionRect.top := loc.v;									tag^.selectionRect.bottom := curLoc.v;								end							else								begin									tag^.selectionRect.bottom := loc.v;									tag^.selectionRect.top := curLoc.v;								end;							if (not PtInRect(where, pr)) then								begin{scroll the window}									if (where.h < pr.left) then										level_HorizAction(tag^.hScroll, inUpButton)									else if (where.h > pr.right) then										level_HorizAction(tag^.hScroll, inDownButton);									if (where.v < pr.top) then										level_VertAction(tag^.vScroll, inUpButton)									else if (where.v > pr.bottom) then										level_VertAction(tag^.vScroll, inDownButton);									lastSelRect := tag^.selectionRect;								end							else if (not EqualRect(lastSelRect, tag^.selectionRect)) then								begin									DrawLevel(levelWind);									lastSelRect := tag^.selectionRect;								end;						end;					if (EmptyRect(tag^.selectionRect)) then						begin							tag^.haveSelection := false;							DrawLevel(levelWind);						end					else						begin							if (tag^.selectionRect.left < 0) then								tag^.selectionRect.left := 0							else if (tag^.selectionRect.right > kMaxLevelSize) then								tag^.selectionRect.right := kMaxLevelSize;							if (tag^.selectionRect.top < 0) then								tag^.selectionRect.top := 0							else if (tag^.selectionRect.bottom > kMaxLevelSize) then								tag^.selectionRect.bottom := kMaxLevelSize;							DrawLevel(levelWind);						end;				end;			kGrabSelectThing: 				begin{this is the big cheeze! i've actually got to move this sucker around.}{i think copying will be automatic, since I also have delete-fill implemented}					if (tag^.copylevel = nil) then						begin							tag^.copylevel := levelArrayPtr(NewPtrClear(sizeof(levelArray)));							BlockMove(Ptr(tag^.winlevel^.thelevel), Ptr(tag^.copylevel), sizeof(levelArray));							tag^.origSelRect := tag^.selectionRect;						end;					loc := level_PointFromMouse(levelWind, where);					offsetPt.h := loc.h - tag^.selectionRect.left;					offsetPt.v := loc.v - tag^.selectionRect.top;					pr := levelWind^.portRect;					pr.right := pr.right - kFudge;					pr.bottom := pr.bottom - kFudge;					while Button do						begin							GetMouse(where);							curLoc := level_PointFromMouse(levelWind, where);							if (loc.h <> curLoc.h) or (loc.v <> curLoc.v) then								begin{user moved. copy the original stuff to the level.}									level_CopyArea(tag^.copylevel, tag^.winlevel^.thelevel, tag^.selectionRect, tag^.selectionRect);{now calculate the new selection rectangle}									OffsetRect(tag^.selectionRect, curLoc.h - loc.h, curLoc.v - loc.v);{now copy that stuff.}									level_CopyArea(tag^.copylevel, tag^.winlevel^.thelevel, tag^.origSelRect, tag^.selectionRect);{set up for drawing}									loc := curLoc;									tag^.drawOffscreen := true;									if (not PtInRect(where, pr)) then										begin{scroll the window}											if (where.h < pr.left) then												level_HorizAction(tag^.hScroll, inUpButton)											else if (where.h > pr.right) then												level_HorizAction(tag^.hScroll, inDownButton);											if (where.v < pr.top) then												level_VertAction(tag^.vScroll, inUpButton)											else if (where.v > pr.bottom) then												level_VertAction(tag^.vScroll, inDownButton);										end									else{simply draw the level}										DrawLevel(levelWind);								end;						end;{the copylevel gets disposed (1) when user clicks to unselect area, or (2) user hits delete.}				end;			kMultiInspectThing: 				begin					level_MultiInspect(levelWind, tag);				end;			kUnselectThing: 				begin					tag^.haveSelection := false;					DrawLevel(levelWind);				end;			kEyedropThing: 				begin					loc := level_PointFromMouse(levelWind, where);					tag^.drawIcon := tag^.winlevel^.thelevel^[loc.h, loc.v].p;					tag^.palUpdate := true;				end;			kInspectThing: 				begin					loc := level_PointFromMouse(levelWind, where);					iconToDraw := tag^.winlevel^.thelevel^[loc.h, loc.v].p;					if (iconToDraw.v > 3) or ((iconToDraw.h = 0) and (iconToDraw.v = 0)) then						level_PieceInspDlog(levelWind, tag, loc, iconToDraw)					else if (iconToDraw.h = 3) then						level_LevelInspDlog(levelWind, tag, loc, iconToDraw)					else						level_SwitchInspDlog(levelWind, tag, loc, iconToDraw);				end;			kToggleThing: 				begin					loc := level_PointFromMouse(levelWind, where);					iconToDraw := tag^.winlevel^.thelevel^[loc.h, loc.v].p;					if (iconToDraw.h > 5) and (iconToDraw.v < 4) then						begin{wowzers! time to toggle!}							trigVal := tag^.winlevel^.thelevel^[loc.h, loc.v].trig;							if (trigVal > 0) then								begin									level_ToggleAllTrig(levelWind, tag, trigVal);									tag^.drawOffscreen := true;									DrawLevel(levelWind);								end							else								level_Warning('Before toggling a switch, you must assign it an ID.');						end					else						level_Warning('You can only toggle switches (diamonds) into alternate states.');				end;			otherwise				;		end;{Park!}		SetPort(oldPort);	end;	function MakelevelWindow (levelTitle: str255): WindowPtr;		var			newWind: WindowPtr;			newTag: MRWinTag;			newLevel: MRlevelInfo;			picRect: rect;			winRect: rect;			pr: rect;	begin{make the window}		newWind := GetNewCWindow(wLevel + 1, nil, WindowPtr(-1));		SetPort(newWind);{make the tag}		newTag := level_MakeWinTag(newWind, levelTitle);{make the level itself}		newTag^.winlevel := level_MakelevelInfo;{associate the tag with the window}		SetWRefCon(newWind, longint(newTag));{show the window}		ShowWindow(newWind);{make the controls}		level_MakeScrollInfo(newWind, newTag);{draw it}		DrawLevel(newWind);{resize safely}		Resizelevel(newWind);{return the window}		MakelevelWindow := newWind;	end;	function LoadlevelWindow (levelTitle: str255): WindowPtr;		var			levelResource: Handle;			oldRes: integer;		var			newWind: WindowPtr;			newTag: MRWinTag;			newLevel: MRlevelInfo;			picRect: rect;			winRect: rect;			pr: rect;	begin		oldRes := CurResFile;		UseResFile(gListRes);		levelResource := Get1Resource(kLevelResType, klevelResID);		if (levelResource = nil) then			LoadlevelWindow := MakelevelWindow(levelTitle)		else			begin{make the window}				newWind := GetNewCWindow(wLevel + 1, nil, WindowPtr(-1));				SetPort(newWind);{make the tag}				newTag := level_MakeWinTag(newWind, levelTitle);{make the level itself}				newTag^.winlevel := level_MakelevelInfo;				HLockHi(levelResource);				BlockMove(Ptr(levelResource^), Ptr(newTag^.winlevel^.thelevel), sizeof(levelArray));				HUnlock(levelResource);				ReleaseResource(levelResource);{associate the tag with the window}				SetWRefCon(newWind, longint(newTag));{show the window}				ShowWindow(newWind);{make the controls}				level_MakeScrollInfo(newWind, newTag);{draw it}				DrawLevel(newWind);{resize safely}				Resizelevel(newWind);{return it}				LoadlevelWindow := newWind;			end;		UseResFile(oldRes);	end;	procedure CloselevelWindow (var levelWind: WindowPtr);		var			tag: MRWinTag;	begin{before closing, save}		Savelevel(levelWind);{now close}		tag := MRWinTag(GetWRefCon(levelWind));		level_DestroylevelInfo(tag^.winlevel);		level_DestroyWinTag(tag);		DisposeWindow(levelWind);	end;	procedure MouseOverlevelWindow (levelWind: WindowPtr;									where: point;									mods: integer);		var			tag: MRWinTag;			pr: Rect;			calcSelRect: Rect;	begin{get the tag}		tag := MRWinTag(GetWRefCon(levelWind));{how big is the window?}		pr := levelWind^.portRect;		OffsetRect(pr, -pr.left, -pr.top);		pr.right := pr.right - kFudge;		pr.bottom := pr.bottom - kFudge;{content point?}		if PtInRect(where, pr) then			begin{if ctrl-key is held down, reveal a magnifying glass}{if option-key is held down, reveal the eye-dropper}{otherwise, reveal the current tool}				if (BAND(mods, cmdKey) = cmdKey) and (not tag^.haveSelection) then					begin						if (gLastCursor <> cToggle) then							begin								gCurrentCurs := GetCursor(cToggle);								gLastCursor := cToggle;								SetCursor(gCurrentCurs^^);							end;					end				else					if (BAND(mods, controlKey) = controlKey) then						begin							if (gLastCursor <> cInspect) then								begin									gCurrentCurs := GetCursor(cInspect);									gLastCursor := cInspect;									SetCursor(gCurrentCurs^^);								end;						end  {ctrl mod key}					else if (BAND(mods, optionKey) = optionKey) and (not tag^.haveSelection) then						begin							if (gLastCursor <> cEyedrop) then								begin									gCurrentCurs := GetCursor(cEyedrop);									gLastCursor := cEyedrop;									SetCursor(gCurrentCurs^^);								end;						end {option mod key}					else if tag^.haveSelection then						begin{have selection. first calculate where the selection is onscreen}							calcSelRect := level_SelRectInWindow(tag);							if PtInRect(where, calcSelRect) then								begin									if (gLastCursor <> cArrow) then										begin											gLastCursor := cArrow;											InitCursor;										end;								end							else								begin									if (gLastCursor <> gCurTool) then										begin											gCurrentCurs := GetCursor(gCurTool);											gLastCursor := gCurTool;											SetCursor(gCurrentCurs^^);										end;								end;						end					else						begin							if (gLastCursor <> gCurTool) then								begin									gCurrentCurs := GetCursor(gCurTool);									gLastCursor := gCurTool;									SetCursor(gCurrentCurs^^);								end;						end; {no special mod keys}			end {point not in level window's contents}		else			begin{check to see if it needs to be changed back to the arrow}				if (gLastCursor <> cArrow) then					begin						gLastCursor := cArrow;						InitCursor;					end;			end;	end;	procedure levelWindowClick (levelWind: WindowPtr;									where: point;									mods: integer);		var			pr: rect;			control: ControlHandle;			part: integer;			tag: MRWinTag;	begin{get the rectangle of the window's actual contents (-scrollbars)}		pr := levelWind^.portRect;		pr.right := pr.right - kFudge;		pr.bottom := pr.bottom - kFudge;{okay, first check to see if they clicked in the content area}		if PtInRect(where, pr) then			level_ContentClick(levelWind, where, mods)		else			begin{yikes. time to handle scrollbars.}				tag := MRWinTag(GetWRefCon(levelWind));				part := FindControl(where, levelWind, control);				case part of					inThumb: 						begin							part := TrackControl(control, where, nil);							if (part = inThumb) then								begin									tag^.drawOffscreen := true;									DrawLevel(levelWind);								end; {inThumb again}						end;{thumb}					inUpButton, inDownButton, inPageUp, inPageDown: 						begin							if (control = tag^.vScroll) then								part := TrackControl(control, where, @level_VertAction)							else								part := TrackControl(control, where, @level_HorizAction);						end;{btns}					otherwise						;				end;{case}{end of handle scrollbars.}			end;	end;	procedure Savelevel (levelWind: WindowPtr);		var			resHandle: Handle;			oldHandle: Handle;			tag: MRWinTag;			curRef: integer;			error: OSErr;	begin{get the tag}		tag := MRWinTag(GetWRefCon(levelWind));{make the handle}		error := PtrToHand(Ptr(tag^.winlevel^.thelevel), resHandle, sizeof(levelArray));		if (error = noErr) then			begin				curRef := CurResFile;				UseResFile(gListRes);				oldHandle := Get1Resource(kLevelResType, klevelResID);				if (oldHandle <> nil) then					begin						RmveResource(oldHandle);						UpdateResFile(gListRes);					end;				AddResource(resHandle, kLevelResType, klevelResID, 'Overhead level');				UpdateResFile(gListRes);				ReleaseResource(resHandle);				UseResFile(curRef);			end;	end;	procedure DrawLevel (levelWind: WindowPtr);		var			oldPort: GrafPtr;			tag: MRWinTag;			pr: Rect;			oldClip: RgnHandle;			calcRect: Rect;	begin		GetPort(oldPort);		SetPort(levelWind);{get the tag}		tag := MRWinTag(GetWRefCon(levelWind));{check to see if the offscreen needs to be redrawn}		if (tag^.drawOffscreen) then			level_DrawFullOffscreen(tag);{pop the offscreen onto the onscreen, but snip it correctly}		pr := levelWind^.portRect;		OffsetRect(pr, -pr.left, -pr.top);		pr.right := pr.right - kFudge;		pr.bottom := pr.bottom - kFudge;		CopyOffToOffRect(tag^.levelOff, true, GlevelPtr(levelWind), false, pr, pr);{draw the selection, if any}		if (tag^.haveSelection) then			begin				oldClip := NewRgn;				GetClip(oldClip);				ClipRect(pr);				calcRect := level_SelRectInWindow(tag);				ForeColor(whiteColor);				FrameRect(calcRect);				ForeColor(blackColor);				SetClip(oldClip);				DisposeRgn(oldClip);			end;{draw the controls}		UpdateControls(levelWind, levelWind^.visRgn);{and don't forget the grow thang}		DrawGrowIcon(levelWind);		SetPort(oldPort);	end;	procedure Resizelevel (levelWind: WindowPtr);		const			kScrollbarWidth = 16;			kScrollBarAdjust = kScrollBarWidth - 1;			kScrollBarTweek = 2;		var			tag: MRWinTag;			pr: Rect;			cValue: integer;	begin		tag := MRWinTag(GetWRefCon(levelWind));{before anything, make sure that the window is a multiple of the size of the level items.}{this speeds up scrolling immensely}{get the window's portRect}		pr := levelWind^.portRect;		OffsetRect(pr, -pr.left, -pr.top);		if ((pr.right - kFudge) div klevelItemSize) <> ((pr.right - kFudge) / klevelItemSize) then			pr.right := (((pr.right - kFudge) div klevelItemSize) * klevelItemSize) + kFudge;		if ((pr.bottom - kFudge) div klevelItemSize) <> ((pr.bottom - kFudge) / klevelItemSize) then			pr.bottom := (((pr.bottom - kFudge) div klevelItemSize) * klevelItemSize) + kFudge;		SizeWindow(levelWind, pr.right, pr.bottom, false);{first deal with the piddly stuff - the controls}{hide 'em}		HideControl(tag^.vScroll);		HideControl(tag^.hScroll);{position the controls}		MoveControl(tag^.vScroll, pr.right - kScrollbarAdjust, -1);		SizeControl(tag^.vScroll, kScrollBarWidth, (pr.bottom - pr.top) - (kScrollBarAdjust - kScrollBarTweek));		MoveControl(tag^.hScroll, -1, pr.bottom - kScrollBarAdjust);		SizeControl(tag^.hScroll, (pr.right - pr.left) - (kScrollBarAdjust - kScrollBarTweek), kScrollBarWidth);{now figger out info about iconsdown and across}		tag^.iconsAcross := ((pr.right - kFudge) div klevelItemSize);		tag^.iconsDown := ((pr.bottom - kFudge) div klevelItemSize);{now calc the new control mins and maxes:}		SetCtlMin(tag^.vScroll, 1);		SetCtlMax(tag^.vScroll, kMaxLevelSize - tag^.iconsDown);		SetCtlMin(tag^.hScroll, 1);		SetCtlMax(tag^.hScroll, kMaxLevelSize - tag^.iconsAcross);{and make sure their values fall in range}		cValue := GetCtlValue(tag^.vScroll);		if (cValue > kMaxLevelSize - tag^.iconsDown) then			SetCtlValue(tag^.vScroll, kMaxLevelSize - tag^.iconsDown);		cValue := GetCtlValue(tag^.hScroll);		if (cValue > kMaxLevelSize - tag^.iconsAcross) then			SetCtlValue(tag^.hScroll, kMaxLevelSize - tag^.iconsAcross);{show 'em}		ShowControl(tag^.vScroll);		ShowControl(tag^.hScroll);{now deal with the less pidly stuff - the offscreen}		DestroyGlevel(tag^.levelOff);		pr.right := pr.right - kFudge;		pr.bottom := pr.bottom - kFudge;		tag^.levelOff := MakeGlevelDepth(pr, 8);{must update offscreen}		tag^.drawOffscreen := true;{draw the level}		DrawLevel(levelWind);	end;	procedure levelActivate (levelWind: WindowPtr;									active: Boolean);		var			tag: MRWinTag;	begin		if (levelWind <> nil) then			begin				tag := MRWinTag(GetWRefCon(levelWind));				if (active) then					begin						HiliteControl(tag^.vScroll, 0);						HiliteControl(tag^.hScroll, 0);						HiliteWindow(levelWind, true);					end				else					begin						HiliteControl(tag^.vScroll, 255);						HiliteControl(tag^.hScroll, 255);						HiliteWindow(levelWind, false);					end;				DrawLevel(levelWind);			end;	end;	procedure SetDrawIcon (levelWind: WindowPtr;									drawIcon: Point);		var			tag: MRWinTag;	begin		tag := MRWinTag(GetWRefCon(levelWind));		tag^.drawIcon := drawIcon;	end;	procedure DrawCurrentMapIcon (levelWind: WindowPtr;									drawRect: Rect);		var			tag: MRWinTag;			currentPort: GrafPtr;	begin		tag := MRWinTag(GetWRefCon(levelWind));		GetPort(currentPort);		EraseRect(drawRect);		InsetRect(drawRect, 8, 8);		level_DrawSingleIcon(tag^.pathOff, GlevelPtr(currentPort), drawRect, tag^.drawIcon);	end;	procedure SelectlevelIcon (levelWind: WindowPtr);		procedure AdjustRect (var r: rect);			var				fitInRect: Rect;		begin{where can we fit?}			fitInRect := screenBits.bounds;			fitInRect.top := fitInRect.top + 25;{adjust a rectangle in global coords to fit inside the screen}			if not PtInRect(r.botRight, fitInRect) then				begin					if r.bottom > fitInRect.bottom then						OffsetRect(r, 0, fitInRect.bottom - r.bottom);					if r.right > fitInRect.right then						OffsetRect(r, fitInRect.right - r.right, 0);				end;			if not PtInRect(r.topLeft, fitInRect) then				begin					if (r.top < fitInRect.top) then						OffsetRect(r, 0, fitInRect.top - r.top);					if (r.left < fitInRect.left) then						OffsetRect(r, fitInRect.left - r.left, 0);				end;		end;		const			kSelWindSeparation = 4;			kSelWindStart = 4;			kSelWindAdjust = -10;		function SelPointFromLoc (p: Point): Point;			var				retPoint: Point;		begin			p.h := p.h - kSelWindStart;			p.v := p.v - kSelWindStart;			p.h := p.h div (klevelItemSize + kSelWindSeparation);			p.v := p.v div (klevelItemSize + kSelWindSeparation);			retPoint := p;			SelPointFromLoc := retPoint;		end;		function FrameRectFromLoc (p: Point): Rect;			var				retRect: Rect;				locPlace: Point;				curPort: GrafPtr;		begin			GetPort(curPort);			if PtInRect(p, curPort^.portRect) then				begin					locPlace := SelPointFromLoc(p);					SetRect(retRect, 0, 0, klevelItemSize, klevelItemSize);					InsetRect(retRect, -2, -2);					OffsetRect(retRect, kSelWindStart, kSelWindStart);					OffsetRect(retRect, locPlace.h * (klevelItemSize + kSelWindSeparation), locPlace.v * (klevelItemSize + kSelWindSeparation));				end			else				SetRect(retRect, -1, -1, -1, -1);			FrameRectFromLoc := retRect;		end;		var			tag: MRWinTag;			palWind: GrafPtr;			selectWind: WindowPtr;			iconsH, iconsV: integer;			picRect: Rect;			selWindRect: Rect;			mouseLoc: Point;			drawIconPoint: Point;			drawIconRect: Rect;			drawH, drawV: integer;			selRect: Rect;			lastSelRect: Rect;			selPoint: Point;	begin		GetPort(palWind);{get the tag}		tag := MRWinTag(GetWRefCon(levelWind));{figure out how many icons there are in each direction inside the PICT itself}		picRect := GetPRect(pLevel);		OffsetRect(picRect, -picRect.left, -picRect.top);		picRect.right := picRect.right - klevelItemStart;		picRect.bottom := picRect.bottom - klevelItemStart;		iconsH := picRect.right div (klevelItemSize + klevelItemSeparation);		iconsV := picRect.bottom div (klevelItemSize + klevelItemSeparation);{now create a window with particular spacing properties}		SetRect(selWindRect, 0, 0, kSelWindStart + (iconsH * (klevelItemSize + kSelWindSeparation)), kSelWindStart + (iconsV * (klevelItemSize + kSelWindSeparation)));		OffsetRect(selWindRect, kSelWindAdjust, kSelWindAdjust);		GetMouse(mouseLoc);		LocalToGlobal(mouseLoc);		OffsetRect(selWindRect, mouseLoc.h, mouseLoc.v);{attempt to make the user's mouse centered over the currently selected icon}		selPoint := tag^.drawIcon;		selPoint.h := kSelWindAdjust + 8 + (selPoint.h * (klevelItemSize + kSelWindSeparation));		selPoint.v := kSelWindAdjust + 8 + (selPoint.v * (klevelItemSize + kSelWindSeparation));		OffsetRect(selWindRect, -selPoint.h, -selPoint.v);{fit the window to the screen}		AdjustRect(selWindRect);{because things are funky.}		iconsH := iconsH - 1;		iconsV := iconsV - 1;{actually make the window}		selectWind := NewCWindow(nil, selWindRect, '', TRUE, altDBoxProc, WindowPtr(-1), FALSE, 0);		ShowWindow(selectWind);		SetPort(selectWind);{now prepare to draw the window's contents - the icons}		SetRect(drawIconRect, 0, 0, klevelItemSize, klevelItemSize);		OffsetRect(drawIconRect, kSelWindStart, kSelWindStart);{draw 'em}		for drawH := 0 to iconsH do			begin				for drawV := 0 to iconsV do					begin						drawIconPoint.h := drawH;						drawIconPoint.v := drawV;						level_DrawSingleIcon(tag^.pathOff, GlevelPtr(selectWind), drawIconRect, drawIconPoint);						OffsetRect(drawIconRect, 0, kSelWindSeparation + klevelItemSize);					end;				drawIconRect.top := kSelWindStart;				drawIconRect.bottom := drawIconRect.top + klevelItemSize;				OffsetRect(drawIconRect, kSelWindSeparation + klevelItemSize, 0);			end;{track the user's choice of map things.}		GetMouse(mouseLoc);		selRect := FrameRectFromLoc(mouseLoc);		ForeColor(blueColor);		FrameRect(selRect);		ForeColor(blackColor);		lastSelRect := selRect;		while Button do			begin				GetMouse(mouseLoc);				selRect := FrameRectFromLoc(mouseLoc);				if EmptyRect(selRect) then					begin						selPoint.h := -1;						selPoint.v := -1;						ForeColor(whiteColor);						FrameRect(lastSelRect);						ForeColor(blackColor);					end				else if ((selRect.top <> lastSelRect.top) or (selRect.left <> lastSelRect.left)) then					begin						ForeColor(whiteColor);						FrameRect(lastSelRect);						ForeColor(blueColor);						FrameRect(selRect);						ForeColor(blackColor);						selPoint := SelPointFromLoc(mouseLoc);					end;				lastSelRect := selRect;			end;		DisposeWindow(selectWind);{if the user picked an icon, set it}		if (selPoint.h >= 0) and (selPoint.h <= iconsH) and (selPoint.v >= 0) and (selPoint.v <= iconsV) then			begin{adjust for level}				if (selPoint.h > 3) and (selPoint.h < 6) and (selPoint.v < 4) then					selPoint.h := 3;{adjust for diamond}				if (selPoint.h > 6) and (selPoint.v < 4) then					selPoint.h := 6;{set the selpt}				tag^.drawIcon := selPoint;			end;		SetPort(palWind);	end;	function levelPaletteUpdate (levelWind: WindowPtr): Boolean;		var			tag: MRWinTag;	begin		tag := MRWinTag(GetWRefCon(levelWind));		levelPaletteUpdate := tag^.palUpdate;		tag^.palUpdate := false;	end;	procedure ZerolevelSelection (levelWind: WindowPtr);		var			tag: MRWinTag;	begin{get the tag}		tag := MRWinTag(GetWRefCon(levelWind));{no selection}		tag^.haveSelection := false;		if (tag^.copylevel <> nil) then			begin				DisposePtr(Ptr(tag^.copylevel));				tag^.copylevel := nil;			end;{update screen}		DrawLevel(levelWind);	end;	procedure levelKey (levelWind: WindowPtr;									theKey: char);		var			tag: MRWinTag;			h, v: integer;	begin		tag := MRWinTag(GetWRefCon(levelWind));		if (theKey = char(8)) and (tag^.haveSelection) then			begin{user wants to selection-fill, since they pressed the delete key}				if (tag^.copylevel <> nil) then					begin{user wants to cancel a copy operation}						level_CopyArea(tag^.copylevel, tag^.winlevel^.thelevel, tag^.selectionRect, tag^.selectionRect);						DisposePtr(Ptr(tag^.copylevel));						tag^.copylevel := nil;						tag^.haveSelection := false;						tag^.drawOffscreen := true;						DrawLevel(levelWind);					end				else if (level_ChoiceWarning('Are you sure you want to fill this entire selection with the current icon?')) then					begin						for h := tag^.selectionRect.left to tag^.selectionRect.right - 1 do							for v := tag^.selectionRect.top to tag^.selectionRect.bottom - 1 do								tag^.winlevel^.thelevel^[h, v].p := tag^.drawIcon;						tag^.drawOffscreen := true;						DrawLevel(levelWind);					end;			end		else if (theKey >= char(28)) and (theKey <= char(31)) and (tag^.haveSelection) then			begin{user pressed an arrow key and wants to move the selection by one grid square}{28 to 31 -> left,right,up,down}				SysBeep(5);			end;	end;	procedure levelPaste (levelWind: WindowPtr);		var			tag: MRWinTag;			hCent, vCent: integer;			dropRect: Rect;			fromRect: Rect;	begin		tag := MRWinTag(GetWRefCon(levelWind));{calc place to drop it down}		hCent := GetCtlValue(tag^.hScroll) + (tag^.iconsAcross div 2);		vCent := GetCtlValue(tag^.vScroll) + (tag^.iconsDown div 2);		vCent := vCent - ((tag^.selectionRect.bottom - tag^.selectionRect.top) div 2);		hCent := hCent - ((tag^.selectionRect.right - tag^.selectionRect.left) div 2);		dropRect := tag^.selectionRect;		OffsetRect(dropRect, -dropRect.left, -dropRect.top);		OffsetRect(dropRect, hCent, vCent);{if there is no copylevel, we've gotsta make one}		if (tag^.copylevel = nil) then			begin				tag^.copylevel := levelArrayPtr(NewPtrClear(sizeof(levelArray)));				BlockMove(Ptr(tag^.winlevel^.thelevel), Ptr(tag^.copylevel), sizeof(levelArray));				tag^.origSelRect := tag^.selectionRect;			end;		fromRect := tag^.origSelRect;		tag^.selectionRect := dropRect;{copy portion of level}		level_CopyArea(tag^.copylevel, tag^.winlevel^.thelevel, tag^.origSelRect, tag^.selectionRect);		tag^.drawOffscreen := true;{draw it}		DrawLevel(levelWind);	end;	function levelEditHilites (levelWind: WindowPtr): Boolean;		var			tag: MRWinTag;	begin		tag := MRWinTag(GetWRefCon(levelWind));		levelEditHilites := tag^.haveSelection;	end;end.
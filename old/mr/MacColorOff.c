// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MacColorOff.c// Auth: Dave Peck// Date: 8/5/96// Desc: Offscreen utility routines#include "MacColorOff.h"#define GENERIC_ERROR 			-1// Make an 8-bit GWorldOSErr MacMakeGWorld( 	Rect 		worldRect, 		// Rectangle of the new world	GWorldPtr 	*worldPtr 		// A pointer to the new world){	GrafPtr		oldGrafPort;	// Previous graphics port	GWorldPtr	oldGWorld;		// Old GWorld	GDHandle	oldGDHandle;	// Old GDHandle	OSErr		error;			// Generic error.			// Check input	if ( worldPtr == NULL )		return GENERIC_ERROR;			// Grab the current graphics port information	GetPort( &oldGrafPort );	GetGWorld( &oldGWorld, &oldGDHandle );		// Make the new world.	error = NewGWorld( worldPtr, 8, &worldRect, NULL, oldGDHandle, 0 );	if ( error != noErr )		return error;			// Success 	return noErr;}// Make an n-bit GWorld ( if n=0, make a GWorld with current bit depth )OSErr MacMakeGWorldDepth( 	Rect 			worldRect, 	// The world's rectangle	int 			depth, 		// The Depth	GWorldPtr 		*worldPtr 	// The GWorldPtr){	GrafPtr		oldGrafPort;	// Previous graphics port	GWorldPtr	oldGWorld;		// Old GWorld	GDHandle	oldGDHandle;	// Old GDHandle	OSErr		error;			// Generic error.			// Check input	if ( worldPtr == NULL )		return GENERIC_ERROR;			// Grab the current graphics port information	GetPort( &oldGrafPort );	GetGWorld( &oldGWorld, &oldGDHandle );		// Make the new world.	error = NewGWorld( worldPtr, depth, &worldRect, NULL, oldGDHandle, 0 );	if ( error != noErr )		return error;			// Success	return noErr;}// Destroy an unneeded GWorld.void DestroyGWorld( GWorldPtr *worldPtr ){	if ( worldPtr != NULL )	{		UnlockPixels( (*worldPtr)->portPixMap );		DisposeGWorld( *worldPtr );		*worldPtr = NULL;	}}// Copy data from the given GWorld directly to the given window. The rect is // the position where the world data should be positioned in the window; the // entire world is copied in this routine.void CopyEntireWorld( GWorldPtr world, WindowPtr window, Rect rectToCopyTo ){	Boolean		lockWorked;		// TRUE if the LockPixels call worked O.K.		// Input Check	if ( ( world == NULL ) || ( window == NULL ) )		return;			// Lock pixels in the port pix map for safe keeping while drawing. (They are	// a handle, so we must do this in order for drawing to be guaranteed to work.)	lockWorked = LockPixels( world->portPixMap );	if ( lockWorked == false )		return;			// Do the dirty deed.	CopyBits( &( ((GrafPtr) world)->portBits ), 	// Bit Map to copy from			  &( ((GrafPtr) window)->portBits ), 	// Bit Map to copy to			  &( world->portRect ),					// The rectangle to copy from (all of world)			  &rectToCopyTo,						// Rectangle, in "window"'s coordinates, to copy to			  srcCopy,								// Method of copying; a good 'ol copy works fine here.			  NULL );								// No Mask region.		// Now just unlock the pixels and pretend life is happy.	UnlockPixels( world->portPixMap );}// CopyWorldBits copies data from "fromRect" of the World to "toRect" of the Windowvoid CopyWorldBits( GWorldPtr world, WindowPtr window, Rect fromRect, Rect toRect ){	Boolean		lockWorked;		// TRUE if the LockPixels call worked O.K.		// Input Check	if ( ( world == NULL ) || ( window == NULL ) )		return;			// Lock pixels in the port pix map for safe keeping while drawing. (They are	// a handle, so we must do this in order for drawing to be guaranteed to work.)	lockWorked = LockPixels( world->portPixMap );	if ( lockWorked == false )		return;			// Do the dirty deed.	CopyBits( &( ((GrafPtr) world)->portBits ), // Bit Map to copy from			  &( ((GrafPtr) window)->portBits ),// Bit Map to copy to			  &fromRect,						// The rectangle to copy from 			  &toRect,							// Rectangle, in "window"'s coordinates, to copy to			  srcCopy,							// Method of copying; a good 'ol copy works fine here.			  NULL );							// No Mask region.		// Now just unlock the pixels and pretend life is happy.	UnlockPixels( world->portPixMap );}void CopyOffToOff( GWorldPtr fromWorld, Boolean lockFrom,				   GWorldPtr toWorld, Boolean lockTo,				   Rect fromToRect ){	if (lockFrom)		(void) LockPixels( fromWorld->portPixMap );	if (lockTo)		(void) LockPixels( toWorld->portPixMap );			CopyBits( &( ((GrafPtr) fromWorld)->portBits ), // Bit Map to copy from			  &( ((GrafPtr) toWorld)->portBits ),// Bit Map to copy to			  &fromToRect,						// The rectangle to copy from 			  &fromToRect,							// Rectangle, in "window"'s coordinates, to copy to			  srcCopy,							// Method of copying; a good 'ol copy works fine here.			  NULL );							// No Mask region.	if (lockFrom)		(void) UnlockPixels( fromWorld->portPixMap );	if (lockTo)		(void) UnlockPixels( toWorld->portPixMap );}void CopyOffToOffRect( GWorldPtr fromWorld, Boolean lockFrom,				   GWorldPtr toWorld, Boolean lockTo,				   Rect fromRect, Rect toRect ){	if (lockFrom)		(void) LockPixels( fromWorld->portPixMap );	if (lockTo)		(void) LockPixels( toWorld->portPixMap );			CopyBits( &( ((GrafPtr) fromWorld)->portBits ), // Bit Map to copy from			  &( ((GrafPtr) toWorld)->portBits ),// Bit Map to copy to			  &fromRect,						// The rectangle to copy from 			  &toRect,							// Rectangle, in "window"'s coordinates, to copy to			  srcCopy,							// Method of copying; a good 'ol copy works fine here.			  NULL );							// No Mask region.	if (lockFrom)		(void) UnlockPixels( fromWorld->portPixMap );	if (lockTo)		(void) UnlockPixels( toWorld->portPixMap );}// CopyBitMapToOffscrreen copies a bitmap data structure onto a GWorld. It copies// the entire bitmap data structure, and put is in the "toRect" of the GWorld.void CopyBitMapToOffscreen( BitMap theBitMap, GWorldPtr world, Rect toRect ){	Boolean		lockWorked;		// TRUE if locking pixels worked			// Input Check	if ( world == NULL )		return;			// Lock the pixels before drawing to them	lockWorked = LockPixels( world->portPixMap );	if ( lockWorked == false )		return;			// Now do the copy.	CopyBits( &theBitMap,					// Bit Map to copy from			  &( ((GrafPtr)world)->portBits ),// World to copy to			  &( theBitMap.bounds ),		// Bounds of the bit map			  &toRect,						// Rectangle to copy to			  srcCopy,						// Copy the info directly			  NULL );						// No mask required			  	// Unlock the pixels	UnlockPixels( world->portPixMap );}// CopyOffscreenToBitMap - reverse of the above, copies a portion of a GWorld// onto an entire BitMap ( "fromRect" specifies rectangle to copy from. )void CopyOffscreenToBitMap( GWorldPtr world, BitMap theBitMap, Rect fromRect ){	Boolean			lockWorked;				// TRUE if locking the pixel map worked		// Check Input	if ( world == NULL )		return;			// Lock the world's pixmap	lockWorked = LockPixels( world->portPixMap );	if ( lockWorked == false )		return;			// Now copy.	CopyBits( &(((GrafPtr)world)->portBits),		// The world's bit map			  &theBitMap,							// Bit map to copy to			  &fromRect,							// World rectangle to copy to			  &theBitMap.bounds,					// Rectangle to copy into			  srcCopy,								// Mode of copy - straight copy			  NULL );								// No mask region required			  	// And unlock the pixels.	UnlockPixels( world->portPixMap );}// CopyOffscreenToCurrent - copies the offscreen to the currently active window/dialog,// using, if desired, a mask region.void CopyOffscreenToCurrent( GWorldPtr world, Rect fromRect, Rect toRect, RgnHandle theRgn ){	Boolean			lockWorked;				// TRUE if locking the pixel map worked	GWorldPtr		curGW;	GDHandle		curGD;		// Check Input	if ( world == NULL )		return;			// Lock the world's pixmap	lockWorked = LockPixels( world->portPixMap );	if ( lockWorked == false )		return;		// Get the current graphics port	//GetPort( &currentGPtr );	GetGWorld( &curGW, &curGD );		// Now copy.	CopyBits( &(((GrafPtr)world)->portBits),		// The world's bit map			  //&(currentGPtr->portBits),				// Bit map to copy to			  &(((GrafPtr)curGW)->portBits),			  &fromRect,							// World rectangle to copy from			  &toRect,								// Rectangle to copy into			  srcCopy,								// Mode of copy - straight copy			  theRgn );								// The Mask region (theRgn==NULL if none)			  	// And unlock the pixels.	UnlockPixels( world->portPixMap );}// Draw a picture to a world.void DrawPictureToWorld( GWorldPtr world, PicHandle picture ){	Boolean			lockWorked;				// TRUE if locking the pixel map worked	GWorldPtr		oldWorld;				// Older world to remembr	GDHandle		oldGD;					// older GD, whatever that is.			// Input check	if ( ( world == NULL ) || ( picture == NULL ) )		return;	// Lock the world's pixmap	lockWorked = LockPixels( world->portPixMap );	if ( lockWorked == false )		return;			// Remember our current port	GetGWorld( &oldWorld, &oldGD );		// And Set The port for drawing.	SetGWorld( world, NULL );		// Now draw the picture...	DrawPicture( picture, &((*picture)->picFrame) );			  	// Set the port back.	SetGWorld( oldWorld, oldGD );		// And unlock the pixels.	UnlockPixels( world->portPixMap );		} 
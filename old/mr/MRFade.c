// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRFade.c// Auth: Dave Peck// Date: 6/10/97// Desc: Abstraction layer for fading code. If I ever write my own or find a better//		 lib, I'll be able to change these w/out affection the rest of the program!// ----------------------------------------------------------------// Includes// ----------------------------------------------------------------// Currently use Matt Slot's color gamma fader.#include <ColorGamma.h>#include "MRFade.h"#include "fade.h"#include "MacIncludes.h"// ----------------------------------------------------------------// Constants// ----------------------------------------------------------------// ----------------------------------------------------------------// Data Structures// ----------------------------------------------------------------// ----------------------------------------------------------------// Global Data// ----------------------------------------------------------------Boolean  fade_screenIsFaded;Boolean  fade_fadesAreInited;GammaRef fade_oldMonitorState;Boolean	 fade_disableAll;RGBColor fade_whiteColor;// ----------------------------------------------------------------// Function Prototypes// ----------------------------------------------------------------// ----------------------------------------------------------------// Functions// ----------------------------------------------------------------// Initialize the fade routines. Returns false if failed.Boolean InitFades() {	// Pretty easy, no?	fade_screenIsFaded = false;		fade_fadesAreInited = false;	fade_disableAll = MR_DISABLE_ALL_FADES;		// Check to see if fading will work.	if ( StartFading( &fade_oldMonitorState ) == noErr )		fade_fadesAreInited = true;		fade_whiteColor.red = 65535;	fade_whiteColor.green = 65535;	fade_whiteColor.blue = 65535;		return fade_fadesAreInited;}// Deinit the fade routines.void CleanUpFades() {	if ( fade_fadesAreInited ) {		if ( fade_screenIsFaded )			FadeIn();		StopFading( fade_oldMonitorState, true );	}}// Returns true if so.Boolean ScreenIsFaded() {	return fade_screenIsFaded;}void FadeOutToColor( RGBColor* color ) {	if ( ( fade_fadesAreInited ) && (!fade_disableAll) ) {		FadeToColor( color, kNumStepsInFade, quadraticFade );		fade_screenIsFaded = true;	}}// Fade to white. Only operates if faded in previously.void FadeOutToWhite() {	if ( ( fade_fadesAreInited ) && (!fade_disableAll) ) {		FadeToColor( &fade_whiteColor, kNumStepsInFade, quadraticFade );		fade_screenIsFaded = true;	}}// Fade to black. Only operates if faded in previously.void FadeOut() {	if ( ( fade_fadesAreInited ) && (!fade_disableAll) && ( !fade_screenIsFaded ) ) {		FadeToBlack( kNumStepsInFade, quadraticFade );		fade_screenIsFaded = true;	}}// Fade from black. Only operates if faded out previously.void FadeIn() {	if ( ( fade_fadesAreInited ) && (!fade_disableAll) && ( fade_screenIsFaded ) ) {		FadeToGamma( fade_oldMonitorState, kNumStepsInFade, inverseQuadraticFade );		fade_screenIsFaded = false;	}}// Call to fade straight to black (no intermed. states)void FadeOutImmediate() {	if ( ( fade_fadesAreInited ) && (!fade_disableAll) && ( !fade_screenIsFaded ) ) {		FadeToBlack( 2, linearFade );		fade_screenIsFaded = true;	}}// And to fade straight from black...void FadeInImmediate() {	if ( ( fade_fadesAreInited ) && (!fade_disableAll) && ( !fade_screenIsFaded ) ) {		FadeToGamma( fade_oldMonitorState, 2, linearFade );		fade_screenIsFaded = false;	}}void DisableAllFades() {	fade_disableAll = true;}
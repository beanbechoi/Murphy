// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRResources.c// Auth: Dave Peck// Date: 6/12/97// Desc: Utilities for handling resources/multiple resource files.// ----------------------------------------------------------------// Includes// ----------------------------------------------------------------#include "MRResources.h"#include "MacIncludes.h"#include <string.h>// ----------------------------------------------------------------// Constants// ----------------------------------------------------------------#define kMaxStackSize 	45// ----------------------------------------------------------------// Data Structures// ----------------------------------------------------------------// ----------------------------------------------------------------// Global Data// ----------------------------------------------------------------short res_mainResFile;short res_aquatronResFile;short res_generalResFile;short res_playersResFile;short res_picturesResFile;short res_infotronResFile;short res_deathtronResFile;short res_savanatronResFile;short res_worldResFile;short res_fileRefNumStack[ kMaxStackSize ];int   res_currentFileRefNumIndex;short res_gfxResAlias;short res_sndResAlias;short res_terrainResAlias;// ----------------------------------------------------------------// Function Prototypes// ----------------------------------------------------------------// ----------------------------------------------------------------// Functions// ----------------------------------------------------------------// Internal function: push a res file ref num onto the stack:void Res_PushRefNum( short refNum ) {	// Oh boy:	if ( res_currentFileRefNumIndex < (kMaxStackSize-1) )		res_fileRefNumStack[ ++res_currentFileRefNumIndex ] = refNum;	// else some very bad error condition, like a box stating how	// poorly MR was programmed and proceeding to allow the player to	// flonk the programmer squarely in the nape of the neck.}// Internal function: pop a res file ref num off of stack; return -1 if there // is none:short Res_PopRefNum() {	if ( res_currentFileRefNumIndex == -1 )		return -1;	else		return res_fileRefNumStack[ res_currentFileRefNumIndex-- ];}// Choose a resource file; balance these calls with a call to MRRestoreResFile();void MRWorldResFile() {	Res_PushRefNum( CurResFile() );	UseResFile( res_worldResFile );}void MRMainResFile() {	Res_PushRefNum( CurResFile() );	UseResFile( res_mainResFile );}void MRAquatronResFile() {	Res_PushRefNum( CurResFile() );	UseResFile( res_aquatronResFile );}void MRGeneralResFile() {	Res_PushRefNum( CurResFile() );	UseResFile( res_generalResFile );}void MRPlayersResFile() {	Res_PushRefNum( CurResFile() );	UseResFile( res_playersResFile );}void MRPicturesResFile() {	Res_PushRefNum( CurResFile() );	UseResFile( res_picturesResFile );}void MRInfotronResFile() {	Res_PushRefNum( CurResFile() );	UseResFile( res_infotronResFile );}void MRDeathtronResFile() {	Res_PushRefNum( CurResFile() );	UseResFile( res_deathtronResFile );}void MRSavanatronResFile() {	Res_PushRefNum( CurResFile() );	UseResFile( res_savanatronResFile );}void MRGfxAlias() {	Res_PushRefNum( CurResFile() );	UseResFile( res_gfxResAlias );}void MRSndAlias() {	Res_PushRefNum( CurResFile() );	UseResFile( res_sndResAlias );}void MRTerrainAlias() {	Res_PushRefNum( CurResFile() );	UseResFile( res_terrainResAlias );}// Use this routine to balance previous calls. Very important.void MRRestoreResFile() {	short oldResFile = Res_PopRefNum();		// Do nothing if we've popped too many times.	if ( oldResFile != -1 )		UseResFile( oldResFile );}// Initialize MR Resource Files; prepare to use them.// Return false on failure.Boolean MRResourcesInit() {	// Easy as pie. Find 'em. Load 'em.	res_mainResFile = CurResFile();		// Yes, this works, but OpenResFile isn't exactly glamarous.	res_aquatronResFile = OpenResFile( "\p:MR Data:Aquatron");	res_playersResFile = OpenResFile( "\p:MR Data:Players");	res_picturesResFile = OpenResFile( "\p:MR Data:Interface");	res_generalResFile = res_picturesResFile;	res_infotronResFile = OpenResFile( "\p:MR Data:Infotron");	res_deathtronResFile = OpenResFile( "\p:MR Data:Deathtron");	res_savanatronResFile = OpenResFile( "\p:MR Data:Savanatron");	res_worldResFile = OpenResFile("\p:MR Data:World");		// Reset file:	UseResFile( res_mainResFile );		// Check:	if ( (res_aquatronResFile == -1 ) ||		 (res_generalResFile == -1 ) ||		 (res_playersResFile == -1 ) ||		 (res_picturesResFile == -1 ) ||		 (res_infotronResFile == -1 ) ||		 (res_deathtronResFile == -1 ) ||		 (res_savanatronResFile == -1 ) ||		 (res_worldResFile == -1) ) {		 		 // Failure!		 return false;	}	// set up the aliases	res_gfxResAlias = res_generalResFile;	res_sndResAlias = res_generalResFile;		// Init the stack:	res_currentFileRefNumIndex = -1;		// Success!	return true;}// modify the gfx aliasvoid MRSetGfxAlias() {	res_gfxResAlias = CurResFile();}void MRSetSndAlias() {	res_sndResAlias = CurResFile();}void MRSetTerrainAlias( short levelWorld ) {	// default setting	res_terrainResAlias = res_infotronResFile;		if ( levelWorld == 1 )		res_terrainResAlias = res_aquatronResFile;	else if ( levelWorld == 2 )		res_terrainResAlias = res_savanatronResFile;	else if ( levelWorld == 3 )		res_terrainResAlias = res_deathtronResFile;}void MRRestoreGfxAlias() {	res_gfxResAlias = res_generalResFile;}void MRRestoreSndAlias() {	res_sndResAlias = res_generalResFile;}// Clean  up usage of MR Resource Files.void MRResourcesClose() {	// Check 'em all, close 'em all.	if (res_aquatronResFile != -1 )		CloseResFile( res_aquatronResFile );	if (res_generalResFile != -1 )		CloseResFile( res_generalResFile );	if (res_playersResFile != -1 )		CloseResFile( res_playersResFile );	if (res_picturesResFile != -1 )		CloseResFile( res_picturesResFile );	if (res_infotronResFile != -1 )		CloseResFile( res_infotronResFile );	if (res_deathtronResFile != -1 )		CloseResFile( res_deathtronResFile );	if (res_savanatronResFile != -1 )		CloseResFile( res_savanatronResFile );		// if debugging, alert the programmer if the 	// stack still has stuff on it.	if ((MR_RES_DEBUG==DEBUG_ON) && (res_currentFileRefNumIndex!=-1)) {		SysBeep(5);		SysBeep(5);		SysBeep(5);	}		// Back to the original res file:	UseResFile( res_mainResFile );}// Don't be silly, you code-reader you. This does the obvious.// Make sure you're in the right resfile before calling!Boolean MRResourceExists( ResType resourceType,						  int resourceID ) {	Handle		someResource = NULL;		// Resource to test against.	OSErr		theError;		// Just do a simple check.	someResource = Get1Resource( resourceType, resourceID );	if ( someResource == NULL ) {		// Get the particular problem...		theError = ResError();				if ( ( theError == resNotFound ) || ( theError == noErr ) )			// Oops, wherediditgo?			return false;		else			// It exists, but it is too big, most likely.			return true;	}		// Don't need it.	ReleaseResource( someResource );		// Yep.	return true;}// Don't be silly, you code-reader you. This does the obvious.// Make sure you're in the right resfile before calling!Boolean MRResourceNameExists( ResType resourceType,						  char* resourceName ) {	Handle		someResource = NULL;		// Resource to test against.	OSErr		theError;	char		cResName[256];	StringPtr	pResName;		strcpy( cResName, resourceName );	pResName = C2PStr( cResName );		// Just do a simple check.	someResource = Get1NamedResource( resourceType, pResName );	if ( someResource == NULL ) {		// Get the particular problem...		theError = ResError();				if ( ( theError == resNotFound ) || ( theError == noErr ) )			// Oops, wherediditgo?			return false;		else			// It exists, but it is too big, most likely.			return true;	}		// Don't need it.	ReleaseResource( someResource );		// Yep.	return true;}// Blindly save data into resource of given type & ID,// even if something existed there beforehand.// Return false if failed.// Make sure the right resfile is up front before doing this.Boolean MROverwriteResource( ResType resourceType,							 int resourceID,							 Handle resourceData,							 char* resourceName ) {						 	// First, ensure non-null handle.	if ( resourceData == NULL )		return false;		// Now check if it exists:	if ( MRResourceExists( resourceType, resourceID ) ) {		Handle someResource;				// Get it.		someResource = Get1Resource( resourceType, resourceID );				// Remove it:		RemoveResource( someResource );				UpdateResFile( CurResFile() );	}		// Okay, it doesn't exist, so now add it:	AddResource( resourceData, resourceType, resourceID, C2PStr(resourceName) );		// And update:	UpdateResFile( CurResFile() );		// Good to go.	return true;}// more blind saving of data.Boolean MROverwriteResourceName( ResType resourceType,								 Handle resourceData,							 	 char* resourceName ) {	char	cResName[256];	StringPtr pResName;		// First, ensure non-null handle.	if ( resourceData == NULL )		return false;		strcpy( cResName, resourceName );	pResName = C2PStr(cResName);		// Now check if it exists:	if ( MRResourceNameExists( resourceType, resourceName ) ) {		Handle someResource;				// Get it.		someResource = Get1NamedResource( resourceType, pResName );				// Remove it:		RemoveResource( someResource );	}		// Okay, it doesn't exist, so now add it:	AddResource( resourceData, resourceType, Unique1ID(resourceType), pResName );		// And update:	UpdateResFile( CurResFile() );		// Good to go.	return true;}
// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: main.c// Auth: Dave Peck// Init: 6/10/97// Desc: MR mainline// ----------------------------------------------------------------// Includes// ----------------------------------------------------------------// Spriteworld includes, to use the pixel blitters.#include <SWIncludes.h>#include "SWGameUtils.h"#include "SWApplication.h"// MR Includes#include "main.h"#include "MRInit.h"#include "MRError.h"#include "MRFade.h"#include "MRSound.h"#include "MRGfxUtils.h"#include "MRInterface.h"#include "MRRegistration.h"#include "MRMap.h"#include "MRPlay.h"#include "MRLoop.h"#include "profiler.h"#include <stdio.h>// ----------------------------------------------------------------// Constants// ----------------------------------------------------------------// ----------------------------------------------------------------// Data Structures// ----------------------------------------------------------------WindowPtr	global_mainWind;// ----------------------------------------------------------------// Function Prototypes// ----------------------------------------------------------------// The big cheeze.void main();// ----------------------------------------------------------------// Functions// ----------------------------------------------------------------void ExpirationExit(int month, int day, int year) {	char outString[256];		sprintf(outString, "Sorry, but this development copy of MR expired on %d/%d/%d.", month, day, year );	ParamText( C2PStr(outString), "\p", "\p", "\p" );		SysBeep(5);		(void)StopAlert(300, NULL);		ExitToShell();}// Starting up stuff goes here:void StartUpMR() {	// Initialize Mac Toolbox	Initialize( kNumMasters );	InitMemoryDebug( "_mr_mem_dbg_" );		// sorry, but the expiration date has been passed!	{		DateTimeRec 	theDate;				GetTime( &theDate );				//ExpirationExit( theDate.month, theDate.day, theDate.year );	/*			// not after this date!		if ( theDate.year > 1998 )			ExpirationExit(1,1,98);		if ( theDate.year <= 1998 && theDate.month > 12 )			ExpirationExit(1,1,98);		if ( theDate.year == 1997 && theDate.month == 12 && theDate.day > 1 )			ExpirationExit(1,1,98);				// not before this date!		if ( theDate.year < 1997 )			ExpirationExit(1,1,98);		if ( theDate.year == 1997 && theDate.month < 10 )			ExpirationExit(1,1,98);		if ( theDate.year == 1997 && theDate.month == 10 && theDate.day < 2 )			ExpirationExit(1,1,98);		*/				// okie, all is good!	}		DevelopmentNotice();	// Are the necessary datafiles available?	// This also inits the MR resources manager, which has to come before	// most everything else.	if ( !CheckForDataFiles() )		StartupError( "one or more of the required datafiles could not be found!" );		// Can we run on this machine?	if ( !CheckMachineAbilities() )		StartupError( FailureReason() );		// Wow. We can! Now initialize Murphy's Revenge.	// This inits all sub-packages.	if ( !InitMurphysRevenge() )		StartupError( FailureReason() );}// introducing mrvoid IntroSequence() {	PaletteHandle phand;	RGBColor fadeColor;		// hide that control strip!		HideControlStrip();	// if the user wants, this will change the monitor's resolution.	// they won't see it happen, since the monitor will be faded.	if ( !VideoSettingsQuery() )		ExitToShell();		global_mainWind = MakeMonitorWind();	(void) HideMenuBar( global_mainWind );	ForeColor( whiteColor );	FillRect( &global_mainWind->portRect, &qd.black );	ForeColor( blackColor );	HideCursor();	DrawPictureIDCentered( kRedLineLogoPict, global_mainWind->portRect );	Rect funRect = RectFromPictureID( kRedLineLogoPict );	//CenterRect( &funRect, &(global_mainWind->portRect) );	//InsetRect( &funRect, -2, -2 );	//FrameRect( &funRect );	FadeIn();		// wait 2 seconds or until mouse is clicked	DelayMouseTime( 2 );		// do the MR title graphic	fadeColor.red = 24320;	fadeColor.green = 36864;	fadeColor.blue = 45312;	FadeOutToColor( &fadeColor );	PlayMusic( kInterfaceMusic, true );	MRPal( global_mainWind, &phand );	KeepMusicGoing();	RGBForeColor( &fadeColor );	FillRect( &global_mainWind->portRect, &qd.black );	ForeColor( blackColor );	DrawPictureIDCentered( kSplashScreenPict, global_mainWind->portRect );	KeepMusicGoing();	FadeIn();		// wait	DelayMouseTimeMusic( 5 );		FadeOut();	FillRect( &global_mainWind->portRect, &qd.black );			// balance cursor calls	ShowCursor();	// restore the color table	DisposePalette( phand );	RestoreWindowColors( global_mainWind );		FillRect( &global_mainWind->portRect, &qd.black );		FadeOutImmediate();}void ExitSequence() {	FadeOut();		(void) ShowMenuBar( global_mainWind );	DisposeWindow( global_mainWind );	//RevertResolution();	ShowControlStrip();	FlushEvents( everyEvent, 0 );}Boolean PlayLoop( int levelIndex ) {	Boolean		finished = false;	int			result;	while ( !finished ) {		// run the current game level with 		// the current player. Data about the player/level/prefs		// is attached to the actual mainWind. Yes, it is yucky,		// but you should have seen how yucky Infotron was.		// Now *there's* a stinker.		result = RunGameLevel( global_mainWind, levelIndex );		// game level completed, but what next?		switch ( result ) {			case kPlayErrorReturn:				return true;				break;						case kPlayQuitReturn:				return true;				break;							case kBackToMapReturn:				return false;				break;						case kPlayAgainReturn:				break;		}	}		return true;}Boolean MapLoop() {	Boolean		finished = false;	int			result;		while ( !finished ) {		// run the map room!		result = RunMapRoom( global_mainWind );		// map room completed, but what next?		switch ( result ) {			case kMapErrorReturn:				return true;				break;						case kMapQuitReturn:				return true;				break;							case kMapBackReturn:				return false;							default:				if ( result > kMapPlayReturn )					finished = PlayLoop( result - kMapPlayReturn );		}	}		return true;}void InterfaceLoop() {	Boolean		finished = false;	int			result;		// loop through interface, map room, and game play.	while (!finished) {		// run the interface		result = RunInterface( global_mainWind );				// interface exited, but to where?		switch ( result ) {					// need to quit MR.			case kErrorReturn:			case kQuitReturn:				finished = true;				break;							// the user clicked "start"			case kMapRoomReturn:				finished = MapLoop();				break;		}	}}// This is da big cheeze.void main() {		//(void) ProfilerInit( collectDetailed, bestTimeBase, 2048, 32 );		// Get ready:	StartUpMR();		// the intro sounds/fx.	IntroSequence();		// check registration	if (!MRIsRegistered())		DoRegistrationDialog();			// play that sucker.	InterfaceLoop();		ExitSequence();		// Deinit & quit:	CleanUpForExit();		// the balancing (Init) call is in StartUpMR().	EndMemoryDebug( true );		//(void) ProfilerDump( C2PStr("_mr_profile_data") );	//ProfilerTerm();}
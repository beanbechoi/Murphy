// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRMemoryDebug.c// Auth: Dave Peck// Date: 7/2/98// Desc: Catch big memory problems. Granted, this isn't even a somewhat smart//       approach to memory profiling/debugging, but it is useful to catch some//       very common bugs.// -----------------------------------------------------------------------------// Includes// -----------------------------------------------------------------------------#include "MRMemoryDebug.h"#include <string.h>#include <stdio.h>// -----------------------------------------------------------------------------// Constants// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Data Structures// -----------------------------------------------------------------------------// Contains a linked list of files and statistics for each named memory fence// or file.typedef struct _dbg_finfo_t {	Ptr		next;	long	totPtrAlloc, totHndAlloc;	long	maxPtrAlloc, maxHndAlloc;	long	ptrAlloc;	long	ptrAllocCount;	long	ptrDeallocCount;	long	handAlloc;	long	handAllocCount;	long	handDeallocCount;	char*	fileName;};typedef struct _dbg_finfo_t _dbg_finfo_t;typedef _dbg_finfo_t *_dbg_p;// -----------------------------------------------------------------------------// Global Data// -----------------------------------------------------------------------------char*	_dbg_dumpFileName;_dbg_p  _dbg_memInfo;// -----------------------------------------------------------------------------// Function Prototypes// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Functions// -----------------------------------------------------------------------------char* __dbg_AllocString( char* init ) {	char* newString = NewPtrClear( sizeof(char) * (strlen(init) + 3) );		strcpy( newString, init );		return newString;}_dbg_p __dbg_AllocFileNode( char* fileName ) {	_dbg_p fileNode;		fileNode = (_dbg_p) NewPtrClear( sizeof( _dbg_finfo_t ) );	fileNode->fileName = __dbg_AllocString( fileName );		return fileNode;}void __dbg_DisposeFileNode( _dbg_p fileNode ) {	if ( fileNode ) {		if ( fileNode->fileName )			DisposePtr( (Ptr) fileNode->fileName );		DisposePtr( (Ptr) fileNode );	}}void __dbg_DisposeNodeList( _dbg_p nodeList ) {	_dbg_p deadNode;		while ( nodeList ) {		deadNode = nodeList;		nodeList = (_dbg_p) nodeList->next;		__dbg_DisposeFileNode( deadNode );	}}_dbg_p	__dbg_FindNodeName( _dbg_p nodeList, char* nodeName ) {	_dbg_p prevNode = NULL;		while ( nodeList ) {		if ( !strcmp( nodeName, nodeList->fileName ) )			return nodeList;		prevNode = nodeList;		nodeList = (_dbg_p) nodeList->next;	}		if ( prevNode ) {		prevNode->next = (Ptr) __dbg_AllocFileNode( nodeName );		return (_dbg_p) prevNode->next;	}		return NULL;}void __dbg_DumpMemInfo( FILE* f, _dbg_p nodeList ) {	_dbg_p glob = nodeList;	fprintf( f, "%s:\n", glob->fileName );	fprintf( f, "    Bytes leaked by Pointers:     %ld\n", glob->ptrAlloc );	fprintf( f, "    Bytes leaked by Handles:      %ld\n", glob->handAlloc );	fprintf( f, "    Max Pointer Bytes at a time:  %ld\n", glob->maxPtrAlloc );	fprintf( f, "    Max Handle Bytes at a time:   %ld\n", glob->maxHndAlloc );	fprintf( f, "    Overall Ptr Bytes alloc'd:    %ld\n", glob->totPtrAlloc );	fprintf( f, "    Overall Hnd Bytes alloc'd:    %ld\n", glob->totHndAlloc );	fprintf( f, "    Total NewPointer calls:       %ld\n", glob->ptrAllocCount );	fprintf( f, "    Total DisposePtr calls:       %ld\n", glob->ptrDeallocCount);	fprintf( f, "    Total NewHandle calls:        %ld\n", glob->handAllocCount );	fprintf( f, "    Total DisposeHnd calls:       %ld\n\n", glob->handDeallocCount);}void __dbg_IncrementNodeValues( _dbg_p nodeList, char* nodeName, Boolean incrementGlobal,								long ptrAlloc, long ptrAllocCnt, long ptrDeallocCnt,								long handAlloc, long handAllocCnt, long handDeallocCnt ) {		_dbg_p changeNode = __dbg_FindNodeName( nodeList, nodeName );	changeNode->ptrAlloc += ptrAlloc;	changeNode->ptrAllocCount += ptrAllocCnt;	changeNode->ptrDeallocCount += ptrDeallocCnt;	changeNode->handAlloc += handAlloc;	changeNode->handAllocCount += handAllocCnt;	changeNode->handDeallocCount += handDeallocCnt;		if ( ptrAlloc > 0 ) 		changeNode->totPtrAlloc += ptrAlloc;	if ( changeNode->ptrAlloc > changeNode->maxPtrAlloc )		changeNode->maxPtrAlloc = changeNode->ptrAlloc;	if ( handAlloc > 0 ) 		changeNode->totHndAlloc += handAlloc;	if ( changeNode->handAlloc > changeNode->maxHndAlloc )		changeNode->maxHndAlloc = changeNode->handAlloc;	changeNode = __dbg_FindNodeName( nodeList, "Global Memory Usage" );	changeNode->ptrAlloc += ptrAlloc;	changeNode->ptrAllocCount += ptrAllocCnt;	changeNode->ptrDeallocCount += ptrDeallocCnt;	changeNode->handAlloc += handAlloc;	changeNode->handAllocCount += handAllocCnt;	changeNode->handDeallocCount += handDeallocCnt;	if ( ptrAlloc > 0 ) 		changeNode->totPtrAlloc += ptrAlloc;	if ( changeNode->ptrAlloc > changeNode->maxPtrAlloc )		changeNode->maxPtrAlloc = changeNode->ptrAlloc;	if ( handAlloc > 0 ) 		changeNode->totHndAlloc += handAlloc;	if ( changeNode->handAlloc > changeNode->maxHndAlloc )		changeNode->maxHndAlloc = changeNode->handAlloc;}void __dbg_SetReportItem( DialogPtr dlog, short itemNum, long value ) {	char outString[256];	short itemType;	Handle item;	Rect box;			GetDialogItem( dlog, itemNum, &itemType, &item, &box );	sprintf( outString, "%ld", value );	SetDialogItemText( item, C2PStr(outString) );}void __dbg_DangerousErrorDlog( char* error, char* fileName, int lineNo ) {	DialogPtr errorDialog = GetNewDialog( DBG_DISPOSE_DLOG_ID, NULL, (WindowPtr) -1 );		char errorStr[256];	char fileNameStr[256];	char outLineStr[256];	short itemHit = -1;		sprintf( errorStr, "Error Code: %s", error );	sprintf( fileNameStr, "File Name: %s", fileName );	sprintf( outLineStr, "Line Number: %d", lineNo );		ParamText( C2PStr(errorStr), C2PStr(fileNameStr), C2PStr(outLineStr), "\p" );		SysBeep( 5 );	ShowWindow( (WindowPtr) errorDialog );		while ( itemHit != 1 ) 		ModalDialog( NULL, &itemHit );			DisposeDialog( errorDialog );}void _dbg_InitMemoryDebug( char* dumpFileName ) {	_dbg_dumpFileName = NULL;		if ( dumpFileName ) {		_dbg_dumpFileName = (char*) NewPtrClear( sizeof(char) * (strlen( dumpFileName ) + 3) );		strcpy( _dbg_dumpFileName, dumpFileName );	}	_dbg_memInfo = __dbg_AllocFileNode( "Global Memory Usage" );}void _dbg_EndMemoryDebug( Boolean reportLeaks, char* fileName, int lineNo ) {	// this will eventually kill the ptr alloc'd hash table.		if ( _dbg_dumpFileName ) {		FILE* f = fopen( _dbg_dumpFileName, "wa" );				if ( f ) {			fprintf( f, "Memory debugging info generated by MemoryDebug by Dave Peck.\n" );			fprintf( f, "Memory usage stats generated from file %s, line %d.\n\n",						fileName, lineNo );							_dbg_p travNode = _dbg_memInfo;			while ( travNode ) {				__dbg_DumpMemInfo( f, travNode );				travNode = (_dbg_p) travNode->next;			}					(void) fclose( f );		}				DisposePtr( (Ptr) _dbg_dumpFileName );	}	if ( reportLeaks ) {		DialogPtr leakDialog = GetNewDialog( DBG_REPORT_DLOG_ID, NULL, (WindowPtr) -1L );		short itemHit = 0;		Boolean finished = false;				if ( leakDialog == NULL )			return;				// init the dialog, and set all output infos		_dbg_p glob = __dbg_FindNodeName( _dbg_memInfo, "Global Memory Usage" );		__dbg_SetReportItem( leakDialog, 2, glob->ptrAlloc );		__dbg_SetReportItem( leakDialog, 3, glob->ptrAllocCount );		__dbg_SetReportItem( leakDialog, 4, glob->ptrDeallocCount );		__dbg_SetReportItem( leakDialog, 5, glob->handAlloc );		__dbg_SetReportItem( leakDialog, 6, glob->handAllocCount );		__dbg_SetReportItem( leakDialog, 7, glob->handDeallocCount );		ShowWindow( (WindowPtr) leakDialog );				while (itemHit != 1)			ModalDialog( NULL, &itemHit );					DisposeDialog( leakDialog );	}		// kill memdebug data	__dbg_DisposeNodeList( _dbg_memInfo );}Ptr _dbg_NewPtr( Size size, char* fileName, int lineNo ) {	__dbg_IncrementNodeValues( _dbg_memInfo, fileName, true,							   (long) size, 1, 0,							   0, 0, 0 );	return NewPtr( size );}Ptr _dbg_NewPtrClear( Size size, char* fileName, int lineNo ) {	__dbg_IncrementNodeValues( _dbg_memInfo, fileName, true,							   (long) size, 1, 0,							   0, 0, 0 );	return NewPtrClear( size );}void _dbg_DisposePtr( Ptr ptr, char* fileName, int lineNo ) {	if ( ptr ) {		__dbg_IncrementNodeValues( _dbg_memInfo, fileName, true,								   -((long) GetPtrSize(ptr)), 0, 1,								   0, 0, 0 );		DisposePtr( ptr );	} else {		// set your debugger to stop here.		__dbg_DangerousErrorDlog( "Null Pointer Dealloc", fileName, lineNo );	}}Handle _dbg_NewHandle( Size size, char* fileName, int lineNo ) {	__dbg_IncrementNodeValues( _dbg_memInfo, fileName, true,							   0, 0, 0,							   (long) size, 1, 0 );	return NewHandle( size );}Handle _dbg_NewHandleClear( Size size, char* fileName, int lineNo ) {	__dbg_IncrementNodeValues( _dbg_memInfo, fileName, true,							   0, 0, 0,							   (long) size, 1, 0 );	return NewHandleClear( size );}void _dbg_DisposeHandle( Handle hand, char* fileName, int lineNo ) {	if ( hand ) {		__dbg_IncrementNodeValues( _dbg_memInfo, fileName, true,								   0, 0, 0,								   -((long) GetHandleSize(hand)), 0, 1 );		DisposeHandle( hand );	} else {		// also put a stop here		__dbg_DangerousErrorDlog( "Null Handle Dealloc", fileName, lineNo );	}}
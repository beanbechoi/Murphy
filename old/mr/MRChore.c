// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRChore.c// Auth: Dave Peck// Date: 7/3/98// Desc: Better chores for fewer bores// -----------------------------------------------------------------------------// Includes// -----------------------------------------------------------------------------#include "MRPlayCommon.h"#include "MRChore.h"// -----------------------------------------------------------------------------// Constants// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Data Structures// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Global Data// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Function Prototypes// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Functions// -----------------------------------------------------------------------------// Low-level allocation and deallocation routinesMRChore _chore_Alloc() {	MRChore theChore = (MRChore) DBG_NewPtrClear( sizeof ( struct MRChoreStruct ) );		return theChore;}void _chore_Dealloc( MRChore *oldChore ) {	// do special chore-type deallocing here.	if ( (*oldChore)->deallocProc )		(* ((MRChoreDeallocPtr)(*oldChore)->deallocProc) ) ( *oldChore );		// get rid of the chore itself.	DBG_DisposePtr( (Ptr) (*oldChore) );	*oldChore = NULL;}MRChore _chore_AllocCommon( LevelCBInfo cbData,		  			        Point loc,					        short choreType,					        MRChoreProcessPtr processProc ) {	MRChore chore = _chore_Alloc();		chore->cb = cbData;	chore->loc = loc;	chore->choreType = choreType;	chore->processProc = (Ptr) processProc;		return chore;}MRChore _chore_AllocCommonHV( LevelCBInfo cbData,		  			          short h, short v,					          short choreType,					          MRChoreProcessPtr processProc ) {	MRChore chore = _chore_Alloc();		chore->cb = cbData;	chore->loc.h = h;	chore->loc.v = v;	chore->choreType = choreType;	chore->processProc = (Ptr) processProc;		return chore;}// Chore processing routinesBoolean _process_Explosion( MRChore theChore ) {	LevelCBInfo		cb 			= theChore->cb;	short			tileID		= cb->tiles[theChore->loc.v][theChore->loc.h];	Boolean			shouldEnq	= true;	long			elapsedTime = TickCount() - theChore->lastTime;		if ( elapsedTime < kExplDelayTicks )		return true;			DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, theChore->info.expl.explTileID );	if ( theChore->info.expl.shouldIgnite ) 		if ( theChore->info.expl.explTileID == kIgniteExplTile )			IgniteExplosion( cb, theChore->loc );	(theChore->info.expl.explTileID) += 1;	if ( theChore->info.expl.explTileID > kLastExplTile ) {		DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, kBlankTile );		return false;	}		theChore->lastTime = TickCount();	return shouldEnq;}Boolean _process_QuarkExplosion( MRChore theChore ) {	LevelCBInfo		cb 			= theChore->cb;	short			tileID		= cb->tiles[theChore->loc.v][theChore->loc.h];	Boolean			shouldEnq	= true;	long			elapsedTime = TickCount() - theChore->lastTime;		if ( elapsedTime < kExplDelayTicks )		return true;			DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, theChore->info.expl.explTileID );	if ( theChore->info.expl.shouldIgnite ) 		if ( theChore->info.expl.explTileID == theChore->info.expl.igniteTileID )			IgniteQuarkExplosion( cb, theChore->loc );	(theChore->info.expl.explTileID) -= 1;	if ( theChore->info.expl.explTileID < kFirstZapInfotronTile ) {		DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, kInfotronTile );		CheckForMotions( cb, theChore->loc.v, theChore->loc.h );		return false;	}		theChore->lastTime = TickCount();	return shouldEnq;}Boolean _process_Exit( MRChore theChore ) {	LevelCBInfo		cb 			= theChore->cb;	short			tileID		= cb->tiles[theChore->loc.v][theChore->loc.h];	Boolean			shouldEnq	= true;	long			elapsedTime = TickCount() - theChore->lastTime;	if ( elapsedTime < kExitDelayTicks )		return true;			DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, theChore->info.exit.exitID );	(theChore->info.exit.exitID) += 1;	if ( theChore->info.exit.exitID > kLastExitTile )		return false;			theChore->lastTime = TickCount();	return shouldEnq;}Boolean _process_Laser( MRChore theChore ) {	LevelCBInfo		cb 			= theChore->cb;	short			tileID		= cb->tiles[theChore->loc.v][theChore->loc.h];	Boolean			shouldEnq	= true;	long			elapsedTime = TickCount() - theChore->lastTime;		PieceKind 		theKind;		if ( theChore->info.laser.mode == kLaserInitMode ) {		// explode space if necessary		GetPieceKindFromLoc( cb, &theKind, theChore->loc.v, theChore->loc.h );		if ( theKind.isIgnitable ) {			// start ignition!			StartExplosion( cb, theChore->loc, true );		} else if ( theKind.isOliver )			KillOliver( cb->oliverSprite, false );		else if ( theKind.isExplodable && 				  theKind.tileID != kBlankTile &&				  !( theKind.tileID > kLaserTile &&				     theKind.tileID < kLaserEmptyPiece ) &&				  !( theKind.tileID > kLaserEmptyPiece && 				     theKind.tileID <= kBLTRLaserBackMirrorLightPiece )) {			StartExplosion( cb, theChore->loc, false );		}				// Draw appropriate piece.		theChore->info.laser.oldTile = theKind.tileID;				if ( theKind.tileID == kForeMirrorTile ||		     theKind.tileID == kTLLaserForeMirrorLightPiece ||		     theKind.tileID == kBRLaserForeMirrorLightPiece ) {			// /						theChore->info.laser.oldTile = kForeMirrorTile;						// going right or down:			if ( theChore->info.laser.deltaH == 1 ||				 theChore->info.laser.deltaV == 1 )				DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, 							   kTLLaserForeMirrorLightPiece );							 			else				DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, 							   kBRLaserForeMirrorLightPiece );							 						// swapping and negating deltas has mirror effect for foremirror.			short oldDH = theChore->info.laser.deltaH;			theChore->info.laser.deltaH = -(theChore->info.laser.deltaV);			theChore->info.laser.deltaV = -(oldDH);		} else if ( theKind.tileID == kBackMirrorTile ||					theKind.tileID == kBLLaserBackMirrorLightPiece ||					theKind.tileID == kTRLaserBackMirrorLightPiece ) {			// \						theChore->info.laser.oldTile = kBackMirrorTile;						// going left or down:			if ( theChore->info.laser.deltaH == -1 ||				 theChore->info.laser.deltaV == 1 )				DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, 							   kTRLaserBackMirrorLightPiece );							 			else				DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, 							   kBLLaserBackMirrorLightPiece );							 						// swapping deltas has mirror effect for backmirror			short oldDH = theChore->info.laser.deltaH;			theChore->info.laser.deltaH = theChore->info.laser.deltaV;			theChore->info.laser.deltaV = oldDH;		} else {			theChore->info.laser.oldTile = kBlankTile;						if ( theChore->info.laser.deltaV != 0 )				DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, 							   kUDLaserLightPiece );			else				DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, 							   kRLLaserLightPiece );		}				// change mode		theChore->info.laser.mode = kLaserDrawnMode;		theChore->lastTime = TickCount();	} else if ( theChore->info.laser.mode == kLaserDrawnMode &&				elapsedTime > kLaserAfterDrawTicks ) {		// time to spread.		ActivateSingleLaser( cb, theChore->loc.v, theChore->loc.h,							 theChore->info.laser.deltaV, 							 theChore->info.laser.deltaH );				theChore->info.laser.mode = kLaserSpreadMode;		theChore->lastTime = TickCount();	} else if ( theChore->info.laser.mode == kLaserSpreadMode &&				elapsedTime > kLaserAfterSpreadTicks ) {		// restore to orig space space, deq		DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h,					   theChore->info.laser.oldTile );		return false;	}		return shouldEnq;}Boolean _process_Bug( MRChore theChore ) {	LevelCBInfo		cb 			= theChore->cb;	short			tileID		= cb->tiles[theChore->loc.v][theChore->loc.h];	Boolean			shouldEnq	= true;	long			elapsedTime = TickCount() - theChore->lastTime;		// first make sure that the bug hasn't been eaten over by oliver, an explosion, etc.	if (( tileID != kCircuitTile ) && !(( tileID >= kFirstBugTile) && (tileID<=kLastBugTile)))		return false;		// check to see if the bug should animate.	if (( theChore->info.bug.isZapping ) && (elapsedTime >= kBugAnimDelayTicks)) {		tileID += 1;		theChore->lastTime = TickCount();		if ( tileID > kLastBugTile ) {			tileID = kCircuitTile;			theChore->info.bug.isZapping = false;			theChore->info.bug.isWaiting = true;			theChore->lastTime = TickCount() + kBugZapDelayTime + (15*GetRandom(0,16));		}		DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, tileID );	} 		// okay, what if it is waiting instead?	else if (( theChore->info.bug.isWaiting) && (elapsedTime > 0)) {		theChore->info.bug.isZapping = true;		theChore->info.bug.isWaiting = false;		DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, kFirstBugTile );		PlaySoundIDStereo( kBugZapSnd, ProximityToOliver( cb, theChore->loc),						   ProximityPanning( cb, theChore->loc ) );		theChore->lastTime = TickCount();							}		// the bug hasn't been initalized yet...	else if ( !(theChore->info.bug.isWaiting) && !(theChore->info.bug.isZapping) ) {		theChore->info.bug.isWaiting = true;		theChore->lastTime = TickCount() + kBugZapDelayTime + (15*GetRandom(0,16));	}		return shouldEnq;}Boolean _process_Zap( MRChore theChore ) {	LevelCBInfo		cb 			= theChore->cb;	short			tileID		= cb->tiles[theChore->loc.v][theChore->loc.h];	Boolean			shouldEnq	= true;	long			elapsedTime = TickCount() - theChore->lastTime;		if ( elapsedTime  < kZapDelayTicks )		return true;			DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, theChore->info.zap.curTile );	if ( theChore->info.zap.curTile == kBlankTile ) {		EatPiece( cb, theChore->info.zap.origTile );		return false;	}		(theChore->info.zap.curTile) += 1;	if ( theChore->info.zap.curTile > theChore->info.zap.lastTile )		theChore->info.zap.curTile = kBlankTile;			theChore->lastTime = TickCount();	return shouldEnq;}Boolean _process_RedDiskBlink( MRChore theChore ) {	LevelCBInfo		cb 			= theChore->cb;	short			tileID		= cb->tiles[theChore->loc.v][theChore->loc.h];	Boolean			shouldEnq	= true;	long			elapsedTime = TickCount() - theChore->lastTime;		if ( elapsedTime < kRDBlinkDelayTicks )		return true;	DrawLevelTile( cb->sw, theChore->loc.v, theChore->loc.h, theChore->info.rdBlink.curTile );	(theChore->info.rdBlink.curTile) += 1;	if ( theChore->info.rdBlink.curTile > kLastRDBlinkTile )		theChore->info.rdBlink.curTile = kFirstRDBlinkTile;	theChore->info.rdBlink.blinkCount += 1;	if ( theChore->info.rdBlink.blinkCount == kRDBlinkCount ) {		StartExplosion( cb, theChore->loc, true );		return false;	}		theChore->lastTime = TickCount();	return shouldEnq;}// High level chore allocation routines.void AllocChore_Explosion( LevelCBInfo cb,						   Point loc,						   short explTileID,						   Boolean shouldIgnite,						   short igniteTileID ) {		MRChore chore = _chore_AllocCommon( cb, loc, 											kExplChoreType, _process_Explosion );	chore->info.expl.explTileID = explTileID;	chore->info.expl.shouldIgnite = shouldIgnite;	chore->info.expl.igniteTileID = igniteTileID;		Enq( cb->chores, chore );}void AllocChore_QuarkExplosion( LevelCBInfo cb,						   		Point loc,						   		short explTileID,						   		Boolean shouldIgnite,						   		short igniteTileID ) {		MRChore chore = _chore_AllocCommon( cb, loc, 											kQuarkExplChoreType, _process_QuarkExplosion );	chore->info.expl.explTileID = explTileID;	chore->info.expl.shouldIgnite = shouldIgnite;	chore->info.expl.igniteTileID = igniteTileID;		Enq( cb->chores, chore );}void AllocChore_Exit( LevelCBInfo cb,					  short v, short h,					  short exitTileID ) {					  	MRChore chore = _chore_AllocCommonHV( cb, h, v, kExitChoreType, _process_Exit );		chore->info.exit.exitID = exitTileID;		Enq( cb->chores, chore );}void AllocChore_Laser( LevelCBInfo cb,					   short v, short h,					   short dv, short dh ) {					   	MRChore chore = _chore_AllocCommonHV( cb, h + dh, v + dv,										  kLaserChoreType, _process_Laser );		chore->info.laser.mode = kLaserInitMode;	chore->info.laser.deltaV = dv;	chore->info.laser.deltaH = dh;		Enq( cb->chores, chore );}void AllocChore_Bug( LevelCBInfo cb,					 short h, short v ) {	MRChore chore = _chore_AllocCommonHV( cb, h, v, 										  kBugChoreType, _process_Bug );		Enq( cb->chores, chore );}void AllocChore_Zap( LevelCBInfo cb,					 short h, short v,					 short origTile ) {					 	MRChore chore = _chore_AllocCommonHV( cb, h, v,										  kZapChoreType, _process_Zap );		chore->info.zap.origTile = origTile;		switch ( origTile ) {		case kInfotronTile:			chore->info.zap.curTile = kFirstZapInfotronTile;			chore->info.zap.lastTile = kLastZapInfotronTile;			break;					case kRedDiskTile:			chore->info.zap.curTile = kFirstZapRedDiskTile;			chore->info.zap.lastTile = kLastZapRedDiskTile;			break;					case kCircuitTile:			chore->info.zap.curTile = kFirstZapCircuitTile;			chore->info.zap.lastTile = kLastZapCircuitTile;			break;				default:			break;	}		Enq( cb->chores, chore );}void AllocChore_RedDiskBlink( LevelCBInfo cb,							  Point loc,							  short curTile ) {							  	MRChore chore = _chore_AllocCommon( cb, loc, 										kRDBlinkChoreType, _process_RedDiskBlink );		chore->info.rdBlink.curTile = curTile;		Enq( cb->chores, chore );}void DeallocChore( MRChore *theChore ) {	_chore_Dealloc( theChore );}
// Murphy's Revenge// (c)1997 Q Software / Dave Peck, All Rights Reserved// This source code is confidential and proprietary, and may not be reproduced// or utilized by anyone without the express written permission of Q Software.// File: MRPlayCommon.c// Auth: Dave Peck// Date: 7/3/98// Desc: Common functions, constants, and structures for playing a level// -----------------------------------------------------------------------------// Includes// -----------------------------------------------------------------------------#include "MRPlayCommon.h"#include "MRChore.h"#include "MRPlaySprite.h"// -----------------------------------------------------------------------------// Constants// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Data Structures// -----------------------------------------------------------------------------DrawProcPtr _OFFDRAWPROC, _ONDRAWPROC, _TILEDRAWPROC, _SPRITEDRAWPROC;DrawProcPtr _OFFDRAWPROCINT, _ONDRAWPROCINT, _TILEDRAWPROCINT, _SPRITEDRAWPROCINT;// -----------------------------------------------------------------------------// Global Data// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Function Prototypes// -----------------------------------------------------------------------------// -----------------------------------------------------------------------------// Functions// -----------------------------------------------------------------------------void GetPieceKindFromLoc( LevelCBInfo cb, PieceKind *theKind, short row, short col ) {	short tileID = cb->tiles[row][col];		GetPieceKind( theKind, tileID );	theKind->tileID = tileID;		if ( tileID == kPhantomTile ) {		theKind->moverSprite = FindMoverAtLocation( cb, row, col );		if ( theKind->moverSprite ) {			MRSpriteTag theTag = (MRSpriteTag) theKind->moverSprite->userData;			theKind->isQuark = ( theTag->spriteType == kQuarkSpriteType );			theKind->isIgnitable = true;		} else if ( cb->oliverSprite ) {			MRSpriteTag theTag = (MRSpriteTag) cb->oliverSprite->userData;						if ( theTag->loc.v == row && theTag->loc.h == col )				theKind->isOliver = true;		}	}}void GetPieceKind( PieceKind *theKind, short tileID ) {	// default settings	theKind->isPassable = false;	theKind->isRounded = false;	theKind->isExplodable = true;	theKind->isIgnitable = false;	theKind->isPort = false;	theKind->isDeadly = false;	theKind->isElectric = false;			// it's electric!	theKind->isEdible = false;	theKind->isPushable = false;	theKind->canFall = false;	theKind->canRoll = false;	theKind->fallRowDelta = 1;	theKind->isQuark = false;	theKind->moverSprite = NULL;	theKind->isOliver = false;		// special settings	switch (tileID) {		case kCircuitTile:			theKind->isEdible = true;			// purposeful break-thru.					case kBlankTile:			theKind->isPassable = true;			break;				case kBlankChipTile:			theKind->isPushable = true;			theKind->isRounded = true;			break;				case kChipTile:		case kTopChipTile:		case kBottomChipTile:		case kLeftChipTile:		case kRightChipTile:			theKind->isRounded = true;			break;					case kInfotronTile:			theKind->isPassable = true;			theKind->isEdible = true;			theKind->canFall = true;			theKind->canRoll = true;			theKind->isRounded = true;			break;					case kGreenDiskTile:			theKind->isIgnitable = true;			theKind->isPushable = true;			theKind->canFall = true;			break;				case kRedDiskTile:			theKind->isEdible = true;			theKind->isPassable = true;			break;					case kGoldDiskTile:			theKind->isPushable = true;			break;					case kPhaseTermTile:			theKind->isExplodable = true;			break;					case kFullPhaseTile:			theKind->isExplodable = false;			break;					case kTerminalTile:			theKind->isExplodable = false;			break;			case kUpZonkTile:			theKind->fallRowDelta = -1;			//purposeful break-thru					case kZonkTile:			theKind->canFall = true;			theKind->canRoll = true;			theKind->isRounded = true;			// purposeful break-thru.				case kYellowDiskTile:			theKind->isPushable = true;			break;			case kLastExitTile:			theKind->isPassable = true;			break;							case kLaserPowerTile:		case kForeMirrorTile:		case kBackMirrorTile:		case kLaserEmptyPiece:			theKind->isPushable = true;			break;					default:			break;	}		if (( tileID >= kFirstZapInfotronTile ) && ( tileID <= kLastZapInfotronTile )) {		theKind->isExplodable = false;	}		else if (( tileID >= kFirstExplTile ) && ( tileID <= kLastExplTile )) {		theKind->isExplodable = false;		theKind->isDeadly = true;	}		else if (( tileID >= kTopLeftBorderTile ) && ( tileID <= kBottomRightBorderTile ))		theKind->isExplodable = false;			else if (( tileID >= kFirstHardwareTile ) && ( tileID <= kLastHardwareTile ))		theKind->isExplodable = false;		else if (( tileID >= kLeftPortTile ) && ( tileID <= kFourWayPortTile )) {		theKind->isPort = true;		theKind->isExplodable = true;	}		else if (( tileID >= kFirstBugTile ) && ( tileID <= kLastBugTile )) {		theKind->isPassable = true;		theKind->isDeadly = true;		theKind->isElectric = true;	}}Boolean Blank_CheckFall( LevelCBInfo cb, short row, short col, short rowDelta ) {	short tileID = cb->tiles[row][col];	PieceKind theKind;		GetPieceKind( &theKind, tileID );	if ( theKind.canFall && theKind.fallRowDelta == rowDelta ) {		MakeSprite_Fall( cb, row, col, rowDelta );		return true;	}		return false;}Boolean Blank_CheckRoll( LevelCBInfo cb, short row, short col, short rowDelta ) {	short tileID;	PieceKind theKind;	// what if some pieces above can roll?	tileID = cb->tiles[row][col];	if ( tileID == kBlankTile ) {			// there's a chance. what about the one up & to the left?		tileID = cb->tiles[row][col-1];		GetPieceKind( &theKind, tileID );		if ( theKind.canRoll && theKind.fallRowDelta == rowDelta ) {			// has to be rounded underneath the piece that can roll:			tileID = cb->tiles[row+rowDelta][col-1];			GetPieceKind( &theKind, tileID );			if ( theKind.isRounded ) {				MakeSprite_Roll( cb, row, col-1, 1, rowDelta );				return true;			}		}				// what about to the right?		tileID = cb->tiles[row][col+1];		GetPieceKind( &theKind, tileID );		if ( theKind.canRoll && theKind.fallRowDelta == rowDelta ) {			// has to be rounded underneath the piece that can roll:			tileID = cb->tiles[row+rowDelta][col+1];			GetPieceKind( &theKind, tileID );			if ( theKind.isRounded  ) {				MakeSprite_Roll( cb, row, col+1, -1, rowDelta );				return true;			}		}			}	// if blankTile-for-rollcheck		return false;}Boolean Blank_CheckSideRoll( LevelCBInfo cb, short row, short col, 							 short colDelta ) {	short tileID;	PieceKind theKind;	// also possible to roll are pieces directly beside where you blanked:	tileID = cb->tiles[row][col + colDelta];	GetPieceKind( &theKind, tileID );	if ( theKind.canRoll ) {		// okay, but is the piece below a blank?		tileID = cb->tiles[row+theKind.fallRowDelta][col];		if ( tileID == kBlankTile ) {			short fallRowDelta = theKind.fallRowDelta;						// yes, so is the piece below & left rounded?			tileID = cb->tiles[row+theKind.fallRowDelta][col + colDelta];			GetPieceKind( &theKind, tileID );			if ( theKind.isRounded ) {				//PlaySoundID( 500 );				MakeSprite_Roll( cb, row, col+colDelta, 								 -colDelta, fallRowDelta );				return true;			}		}	}		return false;}void DrawLevelTile( SpriteWorldPtr sw, short row, short col, short tileID ) {	// this routine serves as a hook for drawing graphics.	// first, it passes on the call straight to the drawTile routine.	SWDrawTile( sw, row, col, tileID );		// if they just drew a blank space, some piece might be waiting to roll...	// ...or fall, so we've got to check.	if ( tileID == kBlankTile ) {		LevelCBInfo cb = (LevelCBInfo)sw->userData;		MRSpriteTag oliverTag = (MRSpriteTag)cb->oliverSprite->userData;				// before any checks are made, we must ensure that oliver isn't		// on the blank spot (otherwise we can't do this!)		if ( (row == oliverTag->loc.v) && (col == oliverTag->loc.h) )			return;				if ( Blank_CheckFall( cb, row-1, col, 1 ) )			return;		if ( Blank_CheckFall( cb, row+1, col, -1) )			return;		if ( Blank_CheckRoll( cb, row-1, col, 1 ) )			return;		if ( Blank_CheckRoll( cb, row+1, col, -1 ) )			return;		if ( Blank_CheckSideRoll( cb, row, col, -1 ) )			return;		if ( Blank_CheckSideRoll( cb, row, col, 1 ) )			return;		} // if blankTile for all checks.}void StartExplosion( LevelCBInfo cb, Point loc, Boolean shouldIgnite ) {	MRChore	theExplChore = NULL;	PieceKind	theKind;		// only explode if the piece where you are is explodable	GetPieceKindFromLoc( cb, &theKind, loc.v, loc.h );		// must explode quarks correctly.	if ( shouldIgnite && theKind.isQuark ) {		StartQuarkExplosion( cb, loc, shouldIgnite );		return;	}		if ( theKind.isExplodable ) {		AllocChore_Explosion( cb, loc, kFirstExplTile, shouldIgnite,							  kIgniteExplTile );		// ensure nothing else explodes or even goes here:		DrawLevelTile( cb->sw, loc.v, loc.h, kFirstExplTile );				if ( shouldIgnite )			PlaySoundIDStereo( kExplodeSnd, ProximityToOliver( cb, loc ),							   ProximityPanning( cb, loc ) );		if ( theKind.moverSprite ) {			MRSpriteTag theTag = (MRSpriteTag) theKind.moverSprite->userData;						// must dispose of the sprite tag			if ( theTag ) {				// must dispose of the sprite tag				DBG_DisposePtr( (Ptr) theTag );				theKind.moverSprite->userData = NULL;				SWRemoveSpriteFromAnimation( cb->sw, theKind.moverSprite, true );			}		}				if ( theKind.isOliver )			KillOliver( cb->oliverSprite, false );						}}void StartQuarkExplosion( LevelCBInfo cb, Point loc, Boolean shouldIgnite ) {	MRChore	theExplChore = NULL;	PieceKind	theKind;		// only explode if the piece where you are is explodable	GetPieceKindFromLoc( cb, &theKind, loc.v, loc.h );		// chain the explosion over to something that isn't a quark.	if ( shouldIgnite && !theKind.isQuark ) {		StartExplosion( cb, loc, shouldIgnite );		return;	}		if ( theKind.isExplodable ) {		AllocChore_QuarkExplosion( cb, loc, kLastZapInfotronTile,								   shouldIgnite, kZapInfotronTile25 );		// ensure nothing else explodes or even goes here:		DrawLevelTile( cb->sw, loc.v, loc.h, kLastZapInfotronTile );		if ( shouldIgnite )			PlaySoundIDStereo( kQuarkExplodeSnd, ProximityToOliver( cb, loc ),							   ProximityPanning( cb, loc ) );					if ( theKind.moverSprite ) {			MRSpriteTag theTag = (MRSpriteTag) theKind.moverSprite->userData;						if ( theTag ) {				// must dispose of the sprite tag				DBG_DisposePtr( (Ptr) theTag );				theKind.moverSprite->userData = NULL;				SWRemoveSpriteFromAnimation( cb->sw, theKind.moverSprite, true );			}		}		if ( theKind.isOliver )			KillOliver( cb->oliverSprite, false );			}}void IgniteExplosion( LevelCBInfo cb, Point loc ) {	PieceKind 	theKind;	short row, col;	Point where;		for ( row = loc.v - 1; row <= loc.v + 1; row++ )		for ( col = loc.h - 1; col <= loc.h + 1; col++ )			if ( row != loc.v || col != loc.h ) {				GetPieceKindFromLoc( cb, &theKind, row, col );				where.v = row;				where.h = col;				StartExplosion( cb, where, theKind.isIgnitable );			}}void IgniteQuarkExplosion( LevelCBInfo cb, Point loc ) {	PieceKind 	theKind;	short row, col;	Point where;		for ( row = loc.v - 1; row <= loc.v + 1; row++ )		for ( col = loc.h - 1; col <= loc.h + 1; col++ )			if ( row != loc.v || col != loc.h ) {				GetPieceKindFromLoc( cb, &theKind, row, col );				where.v = row;				where.h = col;				StartQuarkExplosion( cb, where, theKind.isIgnitable );			}}void CheckForMotions( LevelCBInfo cb, short row, short col ) {	// check around a given location for blank spaces, to see	// if something in that location should fall:	short tileID;	short rowCount, colCount;		for ( rowCount = row-1; rowCount<=row+1; rowCount++ )		for ( colCount = col-1; colCount<=col+1; colCount++ ) {				tileID = cb->tiles[rowCount][colCount];				if ( tileID == kBlankTile )					DrawLevelTile( cb->sw, rowCount, colCount, kBlankTile );		}}void KillOliver( SpritePtr oliverSprite, Boolean electric ) {	MRSpriteTag theTag = (MRSpriteTag) oliverSprite->userData;	short newTile;		// can't kill him if he's already dead!	if ( theTag->info.oliver.isDead )		return;		// set up the animation		theTag->info.oliver.oliverAnimState = kDeathAnimState;		theTag->cb->timer = false;		if ( electric ) {		theTag->info.oliver.oliverFrame = kShockDeathBubFirstFrame;		theTag->info.oliver.oliverFinalFrame = kShockDeathBubLastFrame;	} else if (GetRandom(1,9) <= 3) {		theTag->info.oliver.oliverFrame = kFadeDeathBubFirstFrame;		theTag->info.oliver.oliverFinalFrame = kFadeDeathBubLastFrame;	} else if (GetRandom(0,9) < 5) {		theTag->info.oliver.oliverFrame = kBubbleDeathBubFirstFrame;		theTag->info.oliver.oliverFinalFrame = kBubbleDeathBubLastFrame;	} else {		theTag->info.oliver.oliverFrame = kStaticDeathBubFirstFrame;		theTag->info.oliver.oliverFinalFrame = kStaticDeathBubLastFrame;	}		// can't move when you're dead!	oliverSprite->vertMoveDelta = 0;	oliverSprite->horizMoveDelta = 0;				// so we know	theTag->info.oliver.isDead = true;		// time is important!	theTag->cb->stopPlayTime = TickCount();		// bubbles explode when they die?	// well, yeah, what the heck.	// but first make sure the explosion gets off to a good start:	newTile = theTag->cb->tiles[theTag->loc.v][theTag->loc.h];	if ( (newTile >= kFirstExplTile) && (newTile<= kLastExplTile) )		IgniteExplosion( theTag->cb, theTag->loc );	else		StartExplosion( theTag->cb, theTag->loc, true );			// grim, isn't it?	NextSoundPriority();	PlaySoundID( kOliverDiedSnd );}void EatPiece( LevelCBInfo cbData, short newTile ) {	// is it an infotron?	if ( newTile == kInfotronTile ) {		cbData->infotronCount -= 1;		if ( cbData->infotronCount == 0 ) {			PlaySoundID( kGotLastInfotronSnd );			OpenAllExits( cbData );		} else			PlaySoundID( kGotInfotronSnd );					if ( cbData->infotronCount < 0 )			cbData->infotronCount = 0;					DrawLevelStatistics( cbData );	}		// else is it a red disk?	else if ( newTile == kRedDiskTile ) {		cbData->redDiskCount += 1;		PlaySoundID( kGotRedDiskSnd );		DrawLevelStatistics( cbData );				// too many red disks?		if ( cbData->redDiskCount > 9 )			KillOliver( cbData->oliverSprite, false );	}}void ActivateSingleLaser( LevelCBInfo cb, short v, short h, short dv, short dh ) {	MRChore laserChore = NULL;	PieceKind theKind;		GetPieceKindFromLoc( cb, &theKind, v+dv, h+dh );	if ( theKind.isExplodable && theKind.tileID != kLaserPowerTile ) {		AllocChore_Laser( cb, v, h, dv, dh );	}}short AbsOf( short number ) {	if ( number<0 )		return (-number);	else		return number;}short ProximityToOliver( LevelCBInfo cb, Point loc ) {	Point oliverLoc = cb->oliverCurLoc;	short prox = 0;		prox += AbsOf( oliverLoc.h - loc.h );	prox += AbsOf( oliverLoc.v - loc.v );		return prox;}short ProximityPanning( LevelCBInfo cb, Point loc ) {	Point oliverLoc = cb->oliverCurLoc;	short proxPan = 0;		proxPan = (loc.h - oliverLoc.h) >> 1;		if ( proxPan < -10 )		proxPan = -10;	else if ( proxPan > 10 )		proxPan = 10;			return proxPan;}SpritePtr FindSpriteAtLocation( LevelCBInfo cbData, short row, short col ) {	SpritePtr	theSprite;	MRSpriteTag	theTag;		theSprite = SWGetNextSprite( cbData->sLayer, NULL );		while ( theSprite ) {		theTag = (MRSpriteTag) theSprite->userData;				if (( theTag->loc.v == row && theTag->loc.h == col ))			return theSprite;					theSprite = SWGetNextSprite( cbData->sLayer, theSprite );	}		return NULL;}SpritePtr FindMoverAtLocation( LevelCBInfo cbData, short row, short col ) {	SpritePtr	theSprite;	MRSpriteTag	theTag;		theSprite = cbData->sLayer->headSpriteP;		while ( theSprite ) {		theTag = (MRSpriteTag) theSprite->userData;				if ( (theTag->loc.v == row && theTag->loc.h == col ) ||			 (theTag->newLoc.v == row && theTag->newLoc.h == col ) ) {			 			if ( theTag->spriteType == kQuarkSpriteType || theTag->spriteType == kScissorSpriteType )				return theSprite;			else				return NULL;						}						theSprite = theSprite->nextSpriteP;	}		return NULL;}void OpenAllExits( LevelCBInfo cb ) {	short h, v;	MRChore exitChore;		for ( h = 0; h < cb->levSize.h; h++ ) 		for ( v = 0; v < cb->levSize.v; v++ ) {			if (cb->tiles[v][h] == kExitTile)				AllocChore_Exit( cb, v, h, kFirstExitTile );		}	}void DrawLevelStatistics( LevelCBInfo cb ) {	GrafPtr		oldPort;	RGBColor 	newColor;	short		helveticaNum;		GetPort( &oldPort );	SetPort( cb->mainWind );		// the default stat-color, a somewhat aqua green.	newColor.red = 39168;	newColor.green = 52224;	newColor.blue = 52224;	// the default font & size	GetFNum( "\pHelvetica", &helveticaNum );	TextSize( 9 );	TextFont( helveticaNum );		// draw the infotron info	if ( cb->infotronCount != cb->lastInfotronCount ) {		DrawNumberInRect( cb->infotronCount, cb->infoCountRect, newColor );		cb->lastInfotronCount = cb->infotronCount;	}		// and the rd info	if ( cb->redDiskCount != cb->lastRedDiskCount ) {		DrawNumberInRect( cb->redDiskCount, cb->rdCountRect, newColor );		cb->lastRedDiskCount = cb->redDiskCount;	}		SetPort( oldPort );		DrawTimeRemaining( cb );}void DrawNumberInRect( short num, Rect r, RGBColor drawColor ) {	char	cNum[255];	StringPtr pNum;	short	sWidth;		// translate short to a pascal string.	sprintf( cNum, "%d", num );	pNum = C2PStr( cNum );		// erase rect - the number changed.	FillRect( &r, &qd.black );		// set the color	RGBForeColor( &drawColor );	BackColor( blackColor );		// get ready	sWidth = StringWidth( pNum );	MoveTo( ((r.right + r.left) / 2) - (sWidth/2), r.bottom - 4 );		// draw it	DrawString( pNum );		// colors to normal	ForeColor( blackColor );	BackColor( whiteColor );}void DrawNumberInRectSize( short num, Rect r, RGBColor drawColor, short theSize ) {	char	cNum[255];	StringPtr pNum;	short	sWidth;		// translate short to a pascal string.	if ( theSize == 1 )		sprintf( cNum, "%.1d", num );	else		sprintf( cNum, "%.2d", num );	pNum = C2PStr( cNum );		// erase rect - the number changed.	FillRect( &r, &qd.black );		// set the color	RGBForeColor( &drawColor );	BackColor( blackColor );		// get ready	sWidth = StringWidth( pNum );	MoveTo( ((r.right + r.left) / 2) - (sWidth/2) + 1, r.bottom - 2 );		// draw it	DrawString( pNum );		// colors to normal	ForeColor( blackColor );	BackColor( whiteColor );}void DrawTimeRemaining( LevelCBInfo cb ) {	GrafPtr		oldPort;	RGBColor	newColor;	short		helveticaNum;		if ( cb->timer ) {		GetPort( &oldPort );		SetPort( cb->mainWind );				// the default stat-color, a somewhat aqua green.		newColor.red = 39168;		newColor.green = 52224;		newColor.blue = 52224;		// the default font & size		GetFNum( "\pHelvetica", &helveticaNum );		TextSize( 9 );		TextFont( helveticaNum );				// draw the hour info		if ( cb->ldHours != cb->hours ) {			DrawNumberInRectSize( cb->hours, cb->hoursBox, newColor, 1 );			cb->ldHours = cb->hours;				}				// draw the mins info		if ( cb->ldMins != cb->mins ) {			DrawNumberInRectSize( cb->mins, cb->minsBox, newColor, 2 );			cb->ldMins = cb->mins;				}		// draw the secs info		if ( cb->ldSecs != cb->secs ) {			DrawNumberInRectSize( cb->secs, cb->secsBox, newColor, 2 );			cb->ldSecs = cb->secs;				}		SetPort( oldPort );	}}void HitBottomCheck( LevelCBInfo cbData, short row, short col ) {	PieceKind theKind;	Point explLoc;		GetPieceKindFromLoc( cbData, &theKind, row, col );		if ( theKind.moverSprite ) {		explLoc.v = row;		explLoc.h = col;		StartExplosion( cbData, explLoc, true );	}}void ActivateLaser( LevelCBInfo cb, short v, short h ) {	ActivateSingleLaser( cb, v, h, 1, 0 );	ActivateSingleLaser( cb, v, h, -1, 0 );	ActivateSingleLaser( cb, v, h, 0, 1 );	ActivateSingleLaser( cb, v, h, 0, -1 );}short RotateClockwise( short facing ) {	if ( facing == kMoverStatic )		return kMoverStatic;	facing += 1;	if ( facing > kMoverFacingLeft )		facing = kMoverFacingUp;		return facing;}short RotateCounterClockwise( short facing ) {	if ( facing == kMoverStatic )		return kMoverStatic;	facing -= 1;	if ( facing < kMoverFacingUp )		facing = kMoverFacingLeft;		return facing;}void AbsoluteFacingDeltas( short facing, short *rowDelta, short *colDelta ) {	*rowDelta = 0;	*colDelta = 0;		switch (facing) {		case kMoverFacingUp:			*rowDelta = -1;			break;					case kMoverFacingLeft:			*colDelta = -1;			break;				case kMoverFacingRight:			*colDelta = 1;			break;				case kMoverFacingDown:			*rowDelta = 1;			break;				defaut:			break;		}}short AbsoluteFacing( short facing, short inDirection ) {	short count;		// this isn't too hard. Just rotate "facing" by inDirection-1 times.	for ( count = 0; count < inDirection-1; count++ ) 		facing = RotateClockwise( facing );	return facing;}void SetDeltasFromFacing( short facing, short inDirection, short* rowDelta, short* colDelta ) {	AbsoluteFacingDeltas( AbsoluteFacing(facing, inDirection), rowDelta, colDelta );}short GetTileFromFacing( LevelCBInfo cb, short row, short col, short facing, short inDirection ) {	// suppose we're located at (col,row).	// Then suppose we're facing in the direction specified by 'facing'.	// What piece is located to the 'inDirection' of us?	// for example, suppose facing = right and inDirection = up.	// then the deltas would be col = 1, row = 0 (absolute right.)	// but if facing = right and inDirection = left,	// deltas would be col = 0, row = -1 (absolute up.)		short rowDelta, colDelta;		SetDeltasFromFacing( facing, inDirection, &rowDelta, &colDelta );		return cb->tiles[row+rowDelta][col+colDelta];}void ExplodeYellowDisks( LevelCBInfo cb ) {	short h, v;	Point explLoc;	short count = 0;	long elapsedTime = TickCount() - cb->lastTermSound;		for ( h = 0; h < cb->levSize.h; h++ ) 		for ( v = 0; v < cb->levSize.v; v++ ) {			if (cb->tiles[v][h] == kYellowDiskTile) {				explLoc.h = h;				explLoc.v = v;				StartExplosion(cb, explLoc, true);				count += 1;			}		}			if ( (count > 0) && (elapsedTime > kTermSoundDelay) ) {		PlaySoundID( kTermUseSnd );		cb->lastTermSound = TickCount();	} else if ( elapsedTime > kTermSoundDelay ) {		PlaySoundID( kTermBadSnd );		cb->lastTermSound = TickCount();	}	}void PhaseHardware( LevelCBInfo cb ) {	int cnt;	long phaseDiff = TickCount() - cb->phase->lastPhaseTime;			if ( phaseDiff < kPhaseTermDelay )		return;			for (cnt = 0; cnt < cb->phase->phaseCount; cnt++ ) {			if ( cb->phase->phaseState[cnt] ) {			// phase it out ( it is IN right now )			DrawLevelTile( cb->sw, cb->phase->phaseLoc[cnt].v,						   cb->phase->phaseLoc[cnt].h,						   kBlankTile );		} else {			// phase it in ( it is OUT right now )			DrawLevelTile( cb->sw, cb->phase->phaseLoc[cnt].v,						   cb->phase->phaseLoc[cnt].h,						   kFullPhaseTile );		}			cb->phase->phaseState[cnt] = 1-(cb->phase->phaseState[cnt]);	}		cb->phase->lastPhaseTime = TickCount();}void GetPortPassable( PieceKind *theKind, TileMapPtr tiles, short hLoc, short vLoc, short hDelta, short vDelta ) {	short checkH, checkV;	short tileID;		theKind->isPassable = false;		if (( hDelta == 0 ) && ( vDelta == 0 )) {		theKind->isPassable = true;		return;	}		checkH = hLoc + hDelta;	checkV = vLoc + vDelta;		if ( tiles[checkV][checkH] != kBlankTile )		return;		tileID = tiles[vLoc][hLoc];		switch (tileID) {		case kFourWayPortTile:			theKind->isPassable = true;			break;		case kUpDownPortTile:			if ( hDelta == 0 )				theKind->isPassable = true;			break;		case kLeftRightPortTile:			if ( vDelta == 0 )				theKind->isPassable = true;			break;		case kLeftPortTile:			if ( hDelta == -1 )				theKind->isPassable = true;			break;		case kDownPortTile:			if ( vDelta == 1 )				theKind->isPassable = true;			break;		case kRightPortTile:			if ( hDelta == 1 )				theKind->isPassable = true;			break;		case kUpPortTile:			if ( vDelta == -1 )				theKind->isPassable = true;			break;		default:			break;	}}Boolean SafeToPush( LevelCBInfo cb, short h, short v, short hDelta, short vDelta ) {	short tile = cb->tiles[v+vDelta][h+hDelta];		// only yellow & gold disks & the blank chip can be pushed up & down.	if ( (( tile == kZonkTile ) || 		 ( tile == kUpZonkTile ) ||		 ( tile == kGreenDiskTile )) &&		 ( vDelta != 0 ) )		return false;		if ( tile != kGoldDiskTile )		return ( cb->tiles[v+vDelta+vDelta][h+hDelta+hDelta] == kBlankTile );	else		return ( cb->tiles[v+vDelta+vDelta][h+hDelta+hDelta] == kBlankTile ||				 cb->tiles[v+vDelta+vDelta][h+hDelta+hDelta] == kCircuitTile );	}DrawProcPtr OFFDRAWPROC() {	return _OFFDRAWPROC;}DrawProcPtr ONDRAWPROC() {	return _ONDRAWPROC;}DrawProcPtr TILEDRAWPROC() {	return _TILEDRAWPROC;}DrawProcPtr SPRITEDRAWPROC() {	return _SPRITEDRAWPROC;}DrawProcPtr OFFDRAWPROCINT() {	return _OFFDRAWPROCINT;}DrawProcPtr ONDRAWPROCINT() {	return _ONDRAWPROCINT;}DrawProcPtr TILEDRAWPROCINT() {	return _TILEDRAWPROCINT;}DrawProcPtr SPRITEDRAWPROCINT() {	return _SPRITEDRAWPROCINT;}void PlayDrawProcsInit() {	MRPrefs mp = GetCurrentPrefs();		if ( mp.compatibleDraws ) {			_OFFDRAWPROC = SWStdWorldDrawProc;		_ONDRAWPROC = SWStdWorldDrawProc;		_TILEDRAWPROC = SWStdWorldDrawProc;		_SPRITEDRAWPROC = SWStdSpriteDrawProc;				_OFFDRAWPROCINT = SWStdWorldDrawProc;		_ONDRAWPROCINT = SWStdWorldDrawProc;		_TILEDRAWPROCINT = SWStdWorldDrawProc;		_SPRITEDRAWPROCINT = SWStdSpriteDrawProc;		} else {			_OFFDRAWPROC = BlitPixie8BitRectDrawProc;		_ONDRAWPROC = BlitPixie8BitRectDrawProc;		_TILEDRAWPROC = BlitPixie8BitPartialMaskDrawProc;		_SPRITEDRAWPROC = BlitPixie8BitRectDrawProc;				_OFFDRAWPROCINT = BP8BitInterlacedRectDrawProc;		_ONDRAWPROCINT = BP8BitInterlacedRectDrawProc;		_TILEDRAWPROCINT = BP8BitInterlacedPartialMaskDrawProc;		_SPRITEDRAWPROCINT = BP8BitInterlacedRectDrawProc;			}	}